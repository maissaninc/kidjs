/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/matter-js/build/matter.js":
/*!************************************************!*\
  !*** ./node_modules/matter-js/build/matter.js ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*!\n * matter-js 0.19.0 by @liabru\n * http://brm.io/matter-js/\n * License MIT\n * \n * The MIT License (MIT)\n * \n * Copyright (c) Liam Brummitt and contributors.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_1787__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1787__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_1787__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_1787__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_1787__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_1787__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_1787__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_1787__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_1787__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_1787__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_1787__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_1787__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_1787__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_1787__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_1787__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_1787__(__nested_webpack_require_1787__.s = 20);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Common` module contains utility functions that are common to all modules.\n*\n* @class Common\n*/\n\nvar Common = {};\n\nmodule.exports = Common;\n\n(function() {\n\n    Common._baseDelta = 1000 / 60;\n    Common._nextId = 0;\n    Common._seed = 0;\n    Common._nowStartTime = +(new Date());\n    Common._warnedOnce = {};\n    Common._decomp = null;\n    \n    /**\n     * Extends the object in the first argument using the object in the second argument.\n     * @method extend\n     * @param {} obj\n     * @param {boolean} deep\n     * @return {} obj extended\n     */\n    Common.extend = function(obj, deep) {\n        var argsStart,\n            args,\n            deepClone;\n\n        if (typeof deep === 'boolean') {\n            argsStart = 2;\n            deepClone = deep;\n        } else {\n            argsStart = 1;\n            deepClone = true;\n        }\n\n        for (var i = argsStart; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            if (source) {\n                for (var prop in source) {\n                    if (deepClone && source[prop] && source[prop].constructor === Object) {\n                        if (!obj[prop] || obj[prop].constructor === Object) {\n                            obj[prop] = obj[prop] || {};\n                            Common.extend(obj[prop], deepClone, source[prop]);\n                        } else {\n                            obj[prop] = source[prop];\n                        }\n                    } else {\n                        obj[prop] = source[prop];\n                    }\n                }\n            }\n        }\n        \n        return obj;\n    };\n\n    /**\n     * Creates a new clone of the object, if deep is true references will also be cloned.\n     * @method clone\n     * @param {} obj\n     * @param {bool} deep\n     * @return {} obj cloned\n     */\n    Common.clone = function(obj, deep) {\n        return Common.extend({}, deep, obj);\n    };\n\n    /**\n     * Returns the list of keys for the given object.\n     * @method keys\n     * @param {} obj\n     * @return {string[]} keys\n     */\n    Common.keys = function(obj) {\n        if (Object.keys)\n            return Object.keys(obj);\n\n        // avoid hasOwnProperty for performance\n        var keys = [];\n        for (var key in obj)\n            keys.push(key);\n        return keys;\n    };\n\n    /**\n     * Returns the list of values for the given object.\n     * @method values\n     * @param {} obj\n     * @return {array} Array of the objects property values\n     */\n    Common.values = function(obj) {\n        var values = [];\n        \n        if (Object.keys) {\n            var keys = Object.keys(obj);\n            for (var i = 0; i < keys.length; i++) {\n                values.push(obj[keys[i]]);\n            }\n            return values;\n        }\n        \n        // avoid hasOwnProperty for performance\n        for (var key in obj)\n            values.push(obj[key]);\n        return values;\n    };\n\n    /**\n     * Gets a value from `base` relative to the `path` string.\n     * @method get\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} The object at the given path\n     */\n    Common.get = function(obj, path, begin, end) {\n        path = path.split('.').slice(begin, end);\n\n        for (var i = 0; i < path.length; i += 1) {\n            obj = obj[path[i]];\n        }\n\n        return obj;\n    };\n\n    /**\n     * Sets a value on `base` relative to the given `path` string.\n     * @method set\n     * @param {} obj The base object\n     * @param {string} path The path relative to `base`, e.g. 'Foo.Bar.baz'\n     * @param {} val The value to set\n     * @param {number} [begin] Path slice begin\n     * @param {number} [end] Path slice end\n     * @return {} Pass through `val` for chaining\n     */\n    Common.set = function(obj, path, val, begin, end) {\n        var parts = path.split('.').slice(begin, end);\n        Common.get(obj, path, 0, -1)[parts[parts.length - 1]] = val;\n        return val;\n    };\n\n    /**\n     * Shuffles the given array in-place.\n     * The function uses a seeded random generator.\n     * @method shuffle\n     * @param {array} array\n     * @return {array} array shuffled randomly\n     */\n    Common.shuffle = function(array) {\n        for (var i = array.length - 1; i > 0; i--) {\n            var j = Math.floor(Common.random() * (i + 1));\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n        return array;\n    };\n\n    /**\n     * Randomly chooses a value from a list with equal probability.\n     * The function uses a seeded random generator.\n     * @method choose\n     * @param {array} choices\n     * @return {object} A random choice object from the array\n     */\n    Common.choose = function(choices) {\n        return choices[Math.floor(Common.random() * choices.length)];\n    };\n\n    /**\n     * Returns true if the object is a HTMLElement, otherwise false.\n     * @method isElement\n     * @param {object} obj\n     * @return {boolean} True if the object is a HTMLElement, otherwise false\n     */\n    Common.isElement = function(obj) {\n        if (typeof HTMLElement !== 'undefined') {\n            return obj instanceof HTMLElement;\n        }\n\n        return !!(obj && obj.nodeType && obj.nodeName);\n    };\n\n    /**\n     * Returns true if the object is an array.\n     * @method isArray\n     * @param {object} obj\n     * @return {boolean} True if the object is an array, otherwise false\n     */\n    Common.isArray = function(obj) {\n        return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n\n    /**\n     * Returns true if the object is a function.\n     * @method isFunction\n     * @param {object} obj\n     * @return {boolean} True if the object is a function, otherwise false\n     */\n    Common.isFunction = function(obj) {\n        return typeof obj === \"function\";\n    };\n\n    /**\n     * Returns true if the object is a plain object.\n     * @method isPlainObject\n     * @param {object} obj\n     * @return {boolean} True if the object is a plain object, otherwise false\n     */\n    Common.isPlainObject = function(obj) {\n        return typeof obj === 'object' && obj.constructor === Object;\n    };\n\n    /**\n     * Returns true if the object is a string.\n     * @method isString\n     * @param {object} obj\n     * @return {boolean} True if the object is a string, otherwise false\n     */\n    Common.isString = function(obj) {\n        return toString.call(obj) === '[object String]';\n    };\n    \n    /**\n     * Returns the given value clamped between a minimum and maximum value.\n     * @method clamp\n     * @param {number} value\n     * @param {number} min\n     * @param {number} max\n     * @return {number} The value clamped between min and max inclusive\n     */\n    Common.clamp = function(value, min, max) {\n        if (value < min)\n            return min;\n        if (value > max)\n            return max;\n        return value;\n    };\n    \n    /**\n     * Returns the sign of the given value.\n     * @method sign\n     * @param {number} value\n     * @return {number} -1 if negative, +1 if 0 or positive\n     */\n    Common.sign = function(value) {\n        return value < 0 ? -1 : 1;\n    };\n    \n    /**\n     * Returns the current timestamp since the time origin (e.g. from page load).\n     * The result is in milliseconds and will use high-resolution timing if available.\n     * @method now\n     * @return {number} the current timestamp in milliseconds\n     */\n    Common.now = function() {\n        if (typeof window !== 'undefined' && window.performance) {\n            if (window.performance.now) {\n                return window.performance.now();\n            } else if (window.performance.webkitNow) {\n                return window.performance.webkitNow();\n            }\n        }\n\n        if (Date.now) {\n            return Date.now();\n        }\n\n        return (new Date()) - Common._nowStartTime;\n    };\n    \n    /**\n     * Returns a random value between a minimum and a maximum value inclusive.\n     * The function uses a seeded random generator.\n     * @method random\n     * @param {number} min\n     * @param {number} max\n     * @return {number} A random number between min and max inclusive\n     */\n    Common.random = function(min, max) {\n        min = (typeof min !== \"undefined\") ? min : 0;\n        max = (typeof max !== \"undefined\") ? max : 1;\n        return min + _seededRandom() * (max - min);\n    };\n\n    var _seededRandom = function() {\n        // https://en.wikipedia.org/wiki/Linear_congruential_generator\n        Common._seed = (Common._seed * 9301 + 49297) % 233280;\n        return Common._seed / 233280;\n    };\n\n    /**\n     * Converts a CSS hex colour string into an integer.\n     * @method colorToNumber\n     * @param {string} colorString\n     * @return {number} An integer representing the CSS hex string\n     */\n    Common.colorToNumber = function(colorString) {\n        colorString = colorString.replace('#','');\n\n        if (colorString.length == 3) {\n            colorString = colorString.charAt(0) + colorString.charAt(0)\n                        + colorString.charAt(1) + colorString.charAt(1)\n                        + colorString.charAt(2) + colorString.charAt(2);\n        }\n\n        return parseInt(colorString, 16);\n    };\n\n    /**\n     * The console logging level to use, where each level includes all levels above and excludes the levels below.\n     * The default level is 'debug' which shows all console messages.  \n     *\n     * Possible level values are:\n     * - 0 = None\n     * - 1 = Debug\n     * - 2 = Info\n     * - 3 = Warn\n     * - 4 = Error\n     * @static\n     * @property logLevel\n     * @type {Number}\n     * @default 1\n     */\n    Common.logLevel = 1;\n\n    /**\n     * Shows a `console.log` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method log\n     * @param ...objs {} The objects to log.\n     */\n    Common.log = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Shows a `console.info` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method info\n     * @param ...objs {} The objects to log.\n     */\n    Common.info = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 2) {\n            console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Shows a `console.warn` message only if the current `Common.logLevel` allows it.\n     * The message will be prefixed with 'matter-js' to make it easily identifiable.\n     * @method warn\n     * @param ...objs {} The objects to log.\n     */\n    Common.warn = function() {\n        if (console && Common.logLevel > 0 && Common.logLevel <= 3) {\n            console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments)));\n        }\n    };\n\n    /**\n     * Uses `Common.warn` to log the given message one time only.\n     * @method warnOnce\n     * @param ...objs {} The objects to log.\n     */\n    Common.warnOnce = function() {\n        var message = Array.prototype.slice.call(arguments).join(' ');\n\n        if (!Common._warnedOnce[message]) {\n            Common.warn(message);\n            Common._warnedOnce[message] = true;\n        }\n    };\n\n    /**\n     * Shows a deprecated console warning when the function on the given object is called.\n     * The target function will be replaced with a new function that first shows the warning\n     * and then calls the original function.\n     * @method deprecated\n     * @param {object} obj The object or module\n     * @param {string} name The property name of the function on obj\n     * @param {string} warning The one-time message to show if the function is called\n     */\n    Common.deprecated = function(obj, prop, warning) {\n        obj[prop] = Common.chain(function() {\n            Common.warnOnce('ðŸ”… deprecated ðŸ”…', warning);\n        }, obj[prop]);\n    };\n\n    /**\n     * Returns the next unique sequential ID.\n     * @method nextId\n     * @return {Number} Unique sequential ID\n     */\n    Common.nextId = function() {\n        return Common._nextId++;\n    };\n\n    /**\n     * A cross browser compatible indexOf implementation.\n     * @method indexOf\n     * @param {array} haystack\n     * @param {object} needle\n     * @return {number} The position of needle in haystack, otherwise -1.\n     */\n    Common.indexOf = function(haystack, needle) {\n        if (haystack.indexOf)\n            return haystack.indexOf(needle);\n\n        for (var i = 0; i < haystack.length; i++) {\n            if (haystack[i] === needle)\n                return i;\n        }\n\n        return -1;\n    };\n\n    /**\n     * A cross browser compatible array map implementation.\n     * @method map\n     * @param {array} list\n     * @param {function} func\n     * @return {array} Values from list transformed by func.\n     */\n    Common.map = function(list, func) {\n        if (list.map) {\n            return list.map(func);\n        }\n\n        var mapped = [];\n\n        for (var i = 0; i < list.length; i += 1) {\n            mapped.push(func(list[i]));\n        }\n\n        return mapped;\n    };\n\n    /**\n     * Takes a directed graph and returns the partially ordered set of vertices in topological order.\n     * Circular dependencies are allowed.\n     * @method topologicalSort\n     * @param {object} graph\n     * @return {array} Partially ordered set of vertices in topological order.\n     */\n    Common.topologicalSort = function(graph) {\n        // https://github.com/mgechev/javascript-algorithms\n        // Copyright (c) Minko Gechev (MIT license)\n        // Modifications: tidy formatting and naming\n        var result = [],\n            visited = [],\n            temp = [];\n\n        for (var node in graph) {\n            if (!visited[node] && !temp[node]) {\n                Common._topologicalSort(node, visited, temp, graph, result);\n            }\n        }\n\n        return result;\n    };\n\n    Common._topologicalSort = function(node, visited, temp, graph, result) {\n        var neighbors = graph[node] || [];\n        temp[node] = true;\n\n        for (var i = 0; i < neighbors.length; i += 1) {\n            var neighbor = neighbors[i];\n\n            if (temp[neighbor]) {\n                // skip circular dependencies\n                continue;\n            }\n\n            if (!visited[neighbor]) {\n                Common._topologicalSort(neighbor, visited, temp, graph, result);\n            }\n        }\n\n        temp[node] = false;\n        visited[node] = true;\n\n        result.push(node);\n    };\n\n    /**\n     * Takes _n_ functions as arguments and returns a new function that calls them in order.\n     * The arguments applied when calling the new function will also be applied to every function passed.\n     * The value of `this` refers to the last value returned in the chain that was not `undefined`.\n     * Therefore if a passed function does not return a value, the previously returned value is maintained.\n     * After all passed functions have been called the new function returns the last returned value (if any).\n     * If any of the passed functions are a chain, then the chain will be flattened.\n     * @method chain\n     * @param ...funcs {function} The functions to chain.\n     * @return {function} A new function that calls the passed functions in order.\n     */\n    Common.chain = function() {\n        var funcs = [];\n\n        for (var i = 0; i < arguments.length; i += 1) {\n            var func = arguments[i];\n\n            if (func._chained) {\n                // flatten already chained functions\n                funcs.push.apply(funcs, func._chained);\n            } else {\n                funcs.push(func);\n            }\n        }\n\n        var chain = function() {\n            // https://github.com/GoogleChrome/devtools-docs/issues/53#issuecomment-51941358\n            var lastResult,\n                args = new Array(arguments.length);\n\n            for (var i = 0, l = arguments.length; i < l; i++) {\n                args[i] = arguments[i];\n            }\n\n            for (i = 0; i < funcs.length; i += 1) {\n                var result = funcs[i].apply(lastResult, args);\n\n                if (typeof result !== 'undefined') {\n                    lastResult = result;\n                }\n            }\n\n            return lastResult;\n        };\n\n        chain._chained = funcs;\n\n        return chain;\n    };\n\n    /**\n     * Chains a function to excute before the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathBefore\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain before the original\n     * @return {function} The chained function that replaced the original\n     */\n    Common.chainPathBefore = function(base, path, func) {\n        return Common.set(base, path, Common.chain(\n            func,\n            Common.get(base, path)\n        ));\n    };\n\n    /**\n     * Chains a function to excute after the original function on the given `path` relative to `base`.\n     * See also docs for `Common.chain`.\n     * @method chainPathAfter\n     * @param {} base The base object\n     * @param {string} path The path relative to `base`\n     * @param {function} func The function to chain after the original\n     * @return {function} The chained function that replaced the original\n     */\n    Common.chainPathAfter = function(base, path, func) {\n        return Common.set(base, path, Common.chain(\n            Common.get(base, path),\n            func\n        ));\n    };\n\n    /**\n     * Provide the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module to enable\n     * concave vertex decomposition support when using `Bodies.fromVertices` e.g. `Common.setDecomp(require('poly-decomp'))`.\n     * @method setDecomp\n     * @param {} decomp The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module.\n     */\n    Common.setDecomp = function(decomp) {\n        Common._decomp = decomp;\n    };\n\n    /**\n     * Returns the [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module provided through `Common.setDecomp`,\n     * otherwise returns the global `decomp` if set.\n     * @method getDecomp\n     * @return {} The [poly-decomp](https://github.com/schteppe/poly-decomp.js) library module if provided.\n     */\n    Common.getDecomp = function() {\n        // get user provided decomp if set\n        var decomp = Common._decomp;\n\n        try {\n            // otherwise from window global\n            if (!decomp && typeof window !== 'undefined') {\n                decomp = window.decomp;\n            }\n    \n            // otherwise from node global\n            if (!decomp && typeof __webpack_require__.g !== 'undefined') {\n                decomp = __webpack_require__.g.decomp;\n            }\n        } catch (e) {\n            // decomp not available\n            decomp = null;\n        }\n\n        return decomp;\n    };\n})();\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Bounds` module contains methods for creating and manipulating axis-aligned bounding boxes (AABB).\n*\n* @class Bounds\n*/\n\nvar Bounds = {};\n\nmodule.exports = Bounds;\n\n(function() {\n\n    /**\n     * Creates a new axis-aligned bounding box (AABB) for the given vertices.\n     * @method create\n     * @param {vertices} vertices\n     * @return {bounds} A new bounds object\n     */\n    Bounds.create = function(vertices) {\n        var bounds = { \n            min: { x: 0, y: 0 }, \n            max: { x: 0, y: 0 }\n        };\n\n        if (vertices)\n            Bounds.update(bounds, vertices);\n        \n        return bounds;\n    };\n\n    /**\n     * Updates bounds using the given vertices and extends the bounds given a velocity.\n     * @method update\n     * @param {bounds} bounds\n     * @param {vertices} vertices\n     * @param {vector} velocity\n     */\n    Bounds.update = function(bounds, vertices, velocity) {\n        bounds.min.x = Infinity;\n        bounds.max.x = -Infinity;\n        bounds.min.y = Infinity;\n        bounds.max.y = -Infinity;\n\n        for (var i = 0; i < vertices.length; i++) {\n            var vertex = vertices[i];\n            if (vertex.x > bounds.max.x) bounds.max.x = vertex.x;\n            if (vertex.x < bounds.min.x) bounds.min.x = vertex.x;\n            if (vertex.y > bounds.max.y) bounds.max.y = vertex.y;\n            if (vertex.y < bounds.min.y) bounds.min.y = vertex.y;\n        }\n        \n        if (velocity) {\n            if (velocity.x > 0) {\n                bounds.max.x += velocity.x;\n            } else {\n                bounds.min.x += velocity.x;\n            }\n            \n            if (velocity.y > 0) {\n                bounds.max.y += velocity.y;\n            } else {\n                bounds.min.y += velocity.y;\n            }\n        }\n    };\n\n    /**\n     * Returns true if the bounds contains the given point.\n     * @method contains\n     * @param {bounds} bounds\n     * @param {vector} point\n     * @return {boolean} True if the bounds contain the point, otherwise false\n     */\n    Bounds.contains = function(bounds, point) {\n        return point.x >= bounds.min.x && point.x <= bounds.max.x \n               && point.y >= bounds.min.y && point.y <= bounds.max.y;\n    };\n\n    /**\n     * Returns true if the two bounds intersect.\n     * @method overlaps\n     * @param {bounds} boundsA\n     * @param {bounds} boundsB\n     * @return {boolean} True if the bounds overlap, otherwise false\n     */\n    Bounds.overlaps = function(boundsA, boundsB) {\n        return (boundsA.min.x <= boundsB.max.x && boundsA.max.x >= boundsB.min.x\n                && boundsA.max.y >= boundsB.min.y && boundsA.min.y <= boundsB.max.y);\n    };\n\n    /**\n     * Translates the bounds by the given vector.\n     * @method translate\n     * @param {bounds} bounds\n     * @param {vector} vector\n     */\n    Bounds.translate = function(bounds, vector) {\n        bounds.min.x += vector.x;\n        bounds.max.x += vector.x;\n        bounds.min.y += vector.y;\n        bounds.max.y += vector.y;\n    };\n\n    /**\n     * Shifts the bounds to the given position.\n     * @method shift\n     * @param {bounds} bounds\n     * @param {vector} position\n     */\n    Bounds.shift = function(bounds, position) {\n        var deltaX = bounds.max.x - bounds.min.x,\n            deltaY = bounds.max.y - bounds.min.y;\n            \n        bounds.min.x = position.x;\n        bounds.max.x = position.x + deltaX;\n        bounds.min.y = position.y;\n        bounds.max.y = position.y + deltaY;\n    };\n    \n})();\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Vector` module contains methods for creating and manipulating vectors.\n* Vectors are the basis of all the geometry related operations in the engine.\n* A `Matter.Vector` object is of the form `{ x: 0, y: 0 }`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vector\n*/\n\n// TODO: consider params for reusing vector objects\n\nvar Vector = {};\n\nmodule.exports = Vector;\n\n(function() {\n\n    /**\n     * Creates a new vector.\n     * @method create\n     * @param {number} x\n     * @param {number} y\n     * @return {vector} A new vector\n     */\n    Vector.create = function(x, y) {\n        return { x: x || 0, y: y || 0 };\n    };\n\n    /**\n     * Returns a new vector with `x` and `y` copied from the given `vector`.\n     * @method clone\n     * @param {vector} vector\n     * @return {vector} A new cloned vector\n     */\n    Vector.clone = function(vector) {\n        return { x: vector.x, y: vector.y };\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector.\n     * @method magnitude\n     * @param {vector} vector\n     * @return {number} The magnitude of the vector\n     */\n    Vector.magnitude = function(vector) {\n        return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));\n    };\n\n    /**\n     * Returns the magnitude (length) of a vector (therefore saving a `sqrt` operation).\n     * @method magnitudeSquared\n     * @param {vector} vector\n     * @return {number} The squared magnitude of the vector\n     */\n    Vector.magnitudeSquared = function(vector) {\n        return (vector.x * vector.x) + (vector.y * vector.y);\n    };\n\n    /**\n     * Rotates the vector about (0, 0) by specified angle.\n     * @method rotate\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} [output]\n     * @return {vector} The vector rotated about (0, 0)\n     */\n    Vector.rotate = function(vector, angle, output) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        if (!output) output = {};\n        var x = vector.x * cos - vector.y * sin;\n        output.y = vector.x * sin + vector.y * cos;\n        output.x = x;\n        return output;\n    };\n\n    /**\n     * Rotates the vector about a specified point by specified angle.\n     * @method rotateAbout\n     * @param {vector} vector\n     * @param {number} angle\n     * @param {vector} point\n     * @param {vector} [output]\n     * @return {vector} A new vector rotated about the point\n     */\n    Vector.rotateAbout = function(vector, angle, point, output) {\n        var cos = Math.cos(angle), sin = Math.sin(angle);\n        if (!output) output = {};\n        var x = point.x + ((vector.x - point.x) * cos - (vector.y - point.y) * sin);\n        output.y = point.y + ((vector.x - point.x) * sin + (vector.y - point.y) * cos);\n        output.x = x;\n        return output;\n    };\n\n    /**\n     * Normalises a vector (such that its magnitude is `1`).\n     * @method normalise\n     * @param {vector} vector\n     * @return {vector} A new vector normalised\n     */\n    Vector.normalise = function(vector) {\n        var magnitude = Vector.magnitude(vector);\n        if (magnitude === 0)\n            return { x: 0, y: 0 };\n        return { x: vector.x / magnitude, y: vector.y / magnitude };\n    };\n\n    /**\n     * Returns the dot-product of two vectors.\n     * @method dot\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The dot product of the two vectors\n     */\n    Vector.dot = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.x) + (vectorA.y * vectorB.y);\n    };\n\n    /**\n     * Returns the cross-product of two vectors.\n     * @method cross\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The cross product of the two vectors\n     */\n    Vector.cross = function(vectorA, vectorB) {\n        return (vectorA.x * vectorB.y) - (vectorA.y * vectorB.x);\n    };\n\n    /**\n     * Returns the cross-product of three vectors.\n     * @method cross3\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} vectorC\n     * @return {number} The cross product of the three vectors\n     */\n    Vector.cross3 = function(vectorA, vectorB, vectorC) {\n        return (vectorB.x - vectorA.x) * (vectorC.y - vectorA.y) - (vectorB.y - vectorA.y) * (vectorC.x - vectorA.x);\n    };\n\n    /**\n     * Adds the two vectors.\n     * @method add\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB added\n     */\n    Vector.add = function(vectorA, vectorB, output) {\n        if (!output) output = {};\n        output.x = vectorA.x + vectorB.x;\n        output.y = vectorA.y + vectorB.y;\n        return output;\n    };\n\n    /**\n     * Subtracts the two vectors.\n     * @method sub\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @param {vector} [output]\n     * @return {vector} A new vector of vectorA and vectorB subtracted\n     */\n    Vector.sub = function(vectorA, vectorB, output) {\n        if (!output) output = {};\n        output.x = vectorA.x - vectorB.x;\n        output.y = vectorA.y - vectorB.y;\n        return output;\n    };\n\n    /**\n     * Multiplies a vector and a scalar.\n     * @method mult\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector multiplied by scalar\n     */\n    Vector.mult = function(vector, scalar) {\n        return { x: vector.x * scalar, y: vector.y * scalar };\n    };\n\n    /**\n     * Divides a vector and a scalar.\n     * @method div\n     * @param {vector} vector\n     * @param {number} scalar\n     * @return {vector} A new vector divided by scalar\n     */\n    Vector.div = function(vector, scalar) {\n        return { x: vector.x / scalar, y: vector.y / scalar };\n    };\n\n    /**\n     * Returns the perpendicular vector. Set `negate` to true for the perpendicular in the opposite direction.\n     * @method perp\n     * @param {vector} vector\n     * @param {bool} [negate=false]\n     * @return {vector} The perpendicular vector\n     */\n    Vector.perp = function(vector, negate) {\n        negate = negate === true ? -1 : 1;\n        return { x: negate * -vector.y, y: negate * vector.x };\n    };\n\n    /**\n     * Negates both components of a vector such that it points in the opposite direction.\n     * @method neg\n     * @param {vector} vector\n     * @return {vector} The negated vector\n     */\n    Vector.neg = function(vector) {\n        return { x: -vector.x, y: -vector.y };\n    };\n\n    /**\n     * Returns the angle between the vector `vectorB - vectorA` and the x-axis in radians.\n     * @method angle\n     * @param {vector} vectorA\n     * @param {vector} vectorB\n     * @return {number} The angle in radians\n     */\n    Vector.angle = function(vectorA, vectorB) {\n        return Math.atan2(vectorB.y - vectorA.y, vectorB.x - vectorA.x);\n    };\n\n    /**\n     * Temporary vector pool (not thread-safe).\n     * @property _temp\n     * @type {vector[]}\n     * @private\n     */\n    Vector._temp = [\n        Vector.create(), Vector.create(), \n        Vector.create(), Vector.create(), \n        Vector.create(), Vector.create()\n    ];\n\n})();\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_35421__) {\n\n/**\n* The `Matter.Vertices` module contains methods for creating and manipulating sets of vertices.\n* A set of vertices is an array of `Matter.Vector` with additional indexing properties inserted by `Vertices.create`.\n* A `Matter.Body` maintains a set of vertices to represent the shape of the object (its convex hull).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Vertices\n*/\n\nvar Vertices = {};\n\nmodule.exports = Vertices;\n\nvar Vector = __nested_webpack_require_35421__(2);\nvar Common = __nested_webpack_require_35421__(0);\n\n(function() {\n\n    /**\n     * Creates a new set of `Matter.Body` compatible vertices.\n     * The `points` argument accepts an array of `Matter.Vector` points orientated around the origin `(0, 0)`, for example:\n     *\n     *     [{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]\n     *\n     * The `Vertices.create` method returns a new array of vertices, which are similar to Matter.Vector objects,\n     * but with some additional references required for efficient collision detection routines.\n     *\n     * Vertices must be specified in clockwise order.\n     *\n     * Note that the `body` argument is not optional, a `Matter.Body` reference must be provided.\n     *\n     * @method create\n     * @param {vector[]} points\n     * @param {body} body\n     */\n    Vertices.create = function(points, body) {\n        var vertices = [];\n\n        for (var i = 0; i < points.length; i++) {\n            var point = points[i],\n                vertex = {\n                    x: point.x,\n                    y: point.y,\n                    index: i,\n                    body: body,\n                    isInternal: false\n                };\n\n            vertices.push(vertex);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Parses a string containing ordered x y pairs separated by spaces (and optionally commas), \n     * into a `Matter.Vertices` object for the given `Matter.Body`.\n     * For parsing SVG paths, see `Svg.pathToVertices`.\n     * @method fromPath\n     * @param {string} path\n     * @param {body} body\n     * @return {vertices} vertices\n     */\n    Vertices.fromPath = function(path, body) {\n        var pathPattern = /L?\\s*([-\\d.e]+)[\\s,]*([-\\d.e]+)*/ig,\n            points = [];\n\n        path.replace(pathPattern, function(match, x, y) {\n            points.push({ x: parseFloat(x), y: parseFloat(y) });\n        });\n\n        return Vertices.create(points, body);\n    };\n\n    /**\n     * Returns the centre (centroid) of the set of vertices.\n     * @method centre\n     * @param {vertices} vertices\n     * @return {vector} The centre point\n     */\n    Vertices.centre = function(vertices) {\n        var area = Vertices.area(vertices, true),\n            centre = { x: 0, y: 0 },\n            cross,\n            temp,\n            j;\n\n        for (var i = 0; i < vertices.length; i++) {\n            j = (i + 1) % vertices.length;\n            cross = Vector.cross(vertices[i], vertices[j]);\n            temp = Vector.mult(Vector.add(vertices[i], vertices[j]), cross);\n            centre = Vector.add(centre, temp);\n        }\n\n        return Vector.div(centre, 6 * area);\n    };\n\n    /**\n     * Returns the average (mean) of the set of vertices.\n     * @method mean\n     * @param {vertices} vertices\n     * @return {vector} The average point\n     */\n    Vertices.mean = function(vertices) {\n        var average = { x: 0, y: 0 };\n\n        for (var i = 0; i < vertices.length; i++) {\n            average.x += vertices[i].x;\n            average.y += vertices[i].y;\n        }\n\n        return Vector.div(average, vertices.length);\n    };\n\n    /**\n     * Returns the area of the set of vertices.\n     * @method area\n     * @param {vertices} vertices\n     * @param {bool} signed\n     * @return {number} The area\n     */\n    Vertices.area = function(vertices, signed) {\n        var area = 0,\n            j = vertices.length - 1;\n\n        for (var i = 0; i < vertices.length; i++) {\n            area += (vertices[j].x - vertices[i].x) * (vertices[j].y + vertices[i].y);\n            j = i;\n        }\n\n        if (signed)\n            return area / 2;\n\n        return Math.abs(area) / 2;\n    };\n\n    /**\n     * Returns the moment of inertia (second moment of area) of the set of vertices given the total mass.\n     * @method inertia\n     * @param {vertices} vertices\n     * @param {number} mass\n     * @return {number} The polygon's moment of inertia\n     */\n    Vertices.inertia = function(vertices, mass) {\n        var numerator = 0,\n            denominator = 0,\n            v = vertices,\n            cross,\n            j;\n\n        // find the polygon's moment of inertia, using second moment of area\n        // from equations at http://www.physicsforums.com/showthread.php?t=25293\n        for (var n = 0; n < v.length; n++) {\n            j = (n + 1) % v.length;\n            cross = Math.abs(Vector.cross(v[j], v[n]));\n            numerator += cross * (Vector.dot(v[j], v[j]) + Vector.dot(v[j], v[n]) + Vector.dot(v[n], v[n]));\n            denominator += cross;\n        }\n\n        return (mass / 6) * (numerator / denominator);\n    };\n\n    /**\n     * Translates the set of vertices in-place.\n     * @method translate\n     * @param {vertices} vertices\n     * @param {vector} vector\n     * @param {number} scalar\n     */\n    Vertices.translate = function(vertices, vector, scalar) {\n        scalar = typeof scalar !== 'undefined' ? scalar : 1;\n\n        var verticesLength = vertices.length,\n            translateX = vector.x * scalar,\n            translateY = vector.y * scalar,\n            i;\n        \n        for (i = 0; i < verticesLength; i++) {\n            vertices[i].x += translateX;\n            vertices[i].y += translateY;\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Rotates the set of vertices in-place.\n     * @method rotate\n     * @param {vertices} vertices\n     * @param {number} angle\n     * @param {vector} point\n     */\n    Vertices.rotate = function(vertices, angle, point) {\n        if (angle === 0)\n            return;\n\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            pointX = point.x,\n            pointY = point.y,\n            verticesLength = vertices.length,\n            vertex,\n            dx,\n            dy,\n            i;\n\n        for (i = 0; i < verticesLength; i++) {\n            vertex = vertices[i];\n            dx = vertex.x - pointX;\n            dy = vertex.y - pointY;\n            vertex.x = pointX + (dx * cos - dy * sin);\n            vertex.y = pointY + (dx * sin + dy * cos);\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Returns `true` if the `point` is inside the set of `vertices`.\n     * @method contains\n     * @param {vertices} vertices\n     * @param {vector} point\n     * @return {boolean} True if the vertices contains point, otherwise false\n     */\n    Vertices.contains = function(vertices, point) {\n        var pointX = point.x,\n            pointY = point.y,\n            verticesLength = vertices.length,\n            vertex = vertices[verticesLength - 1],\n            nextVertex;\n\n        for (var i = 0; i < verticesLength; i++) {\n            nextVertex = vertices[i];\n\n            if ((pointX - vertex.x) * (nextVertex.y - vertex.y) \n                + (pointY - vertex.y) * (vertex.x - nextVertex.x) > 0) {\n                return false;\n            }\n\n            vertex = nextVertex;\n        }\n\n        return true;\n    };\n\n    /**\n     * Scales the vertices from a point (default is centre) in-place.\n     * @method scale\n     * @param {vertices} vertices\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     */\n    Vertices.scale = function(vertices, scaleX, scaleY, point) {\n        if (scaleX === 1 && scaleY === 1)\n            return vertices;\n\n        point = point || Vertices.centre(vertices);\n\n        var vertex,\n            delta;\n\n        for (var i = 0; i < vertices.length; i++) {\n            vertex = vertices[i];\n            delta = Vector.sub(vertex, point);\n            vertices[i].x = point.x + delta.x * scaleX;\n            vertices[i].y = point.y + delta.y * scaleY;\n        }\n\n        return vertices;\n    };\n\n    /**\n     * Chamfers a set of vertices by giving them rounded corners, returns a new set of vertices.\n     * The radius parameter is a single number or an array to specify the radius for each vertex.\n     * @method chamfer\n     * @param {vertices} vertices\n     * @param {number[]} radius\n     * @param {number} quality\n     * @param {number} qualityMin\n     * @param {number} qualityMax\n     */\n    Vertices.chamfer = function(vertices, radius, quality, qualityMin, qualityMax) {\n        if (typeof radius === 'number') {\n            radius = [radius];\n        } else {\n            radius = radius || [8];\n        }\n\n        // quality defaults to -1, which is auto\n        quality = (typeof quality !== 'undefined') ? quality : -1;\n        qualityMin = qualityMin || 2;\n        qualityMax = qualityMax || 14;\n\n        var newVertices = [];\n\n        for (var i = 0; i < vertices.length; i++) {\n            var prevVertex = vertices[i - 1 >= 0 ? i - 1 : vertices.length - 1],\n                vertex = vertices[i],\n                nextVertex = vertices[(i + 1) % vertices.length],\n                currentRadius = radius[i < radius.length ? i : radius.length - 1];\n\n            if (currentRadius === 0) {\n                newVertices.push(vertex);\n                continue;\n            }\n\n            var prevNormal = Vector.normalise({ \n                x: vertex.y - prevVertex.y, \n                y: prevVertex.x - vertex.x\n            });\n\n            var nextNormal = Vector.normalise({ \n                x: nextVertex.y - vertex.y, \n                y: vertex.x - nextVertex.x\n            });\n\n            var diagonalRadius = Math.sqrt(2 * Math.pow(currentRadius, 2)),\n                radiusVector = Vector.mult(Common.clone(prevNormal), currentRadius),\n                midNormal = Vector.normalise(Vector.mult(Vector.add(prevNormal, nextNormal), 0.5)),\n                scaledVertex = Vector.sub(vertex, Vector.mult(midNormal, diagonalRadius));\n\n            var precision = quality;\n\n            if (quality === -1) {\n                // automatically decide precision\n                precision = Math.pow(currentRadius, 0.32) * 1.75;\n            }\n\n            precision = Common.clamp(precision, qualityMin, qualityMax);\n\n            // use an even value for precision, more likely to reduce axes by using symmetry\n            if (precision % 2 === 1)\n                precision += 1;\n\n            var alpha = Math.acos(Vector.dot(prevNormal, nextNormal)),\n                theta = alpha / precision;\n\n            for (var j = 0; j < precision; j++) {\n                newVertices.push(Vector.add(Vector.rotate(radiusVector, theta * j), scaledVertex));\n            }\n        }\n\n        return newVertices;\n    };\n\n    /**\n     * Sorts the input vertices into clockwise order in place.\n     * @method clockwiseSort\n     * @param {vertices} vertices\n     * @return {vertices} vertices\n     */\n    Vertices.clockwiseSort = function(vertices) {\n        var centre = Vertices.mean(vertices);\n\n        vertices.sort(function(vertexA, vertexB) {\n            return Vector.angle(centre, vertexA) - Vector.angle(centre, vertexB);\n        });\n\n        return vertices;\n    };\n\n    /**\n     * Returns true if the vertices form a convex shape (vertices must be in clockwise order).\n     * @method isConvex\n     * @param {vertices} vertices\n     * @return {bool} `true` if the `vertices` are convex, `false` if not (or `null` if not computable).\n     */\n    Vertices.isConvex = function(vertices) {\n        // http://paulbourke.net/geometry/polygonmesh/\n        // Copyright (c) Paul Bourke (use permitted)\n\n        var flag = 0,\n            n = vertices.length,\n            i,\n            j,\n            k,\n            z;\n\n        if (n < 3)\n            return null;\n\n        for (i = 0; i < n; i++) {\n            j = (i + 1) % n;\n            k = (i + 2) % n;\n            z = (vertices[j].x - vertices[i].x) * (vertices[k].y - vertices[j].y);\n            z -= (vertices[j].y - vertices[i].y) * (vertices[k].x - vertices[j].x);\n\n            if (z < 0) {\n                flag |= 1;\n            } else if (z > 0) {\n                flag |= 2;\n            }\n\n            if (flag === 3) {\n                return false;\n            }\n        }\n\n        if (flag !== 0){\n            return true;\n        } else {\n            return null;\n        }\n    };\n\n    /**\n     * Returns the convex hull of the input vertices as a new array of points.\n     * @method hull\n     * @param {vertices} vertices\n     * @return [vertex] vertices\n     */\n    Vertices.hull = function(vertices) {\n        // http://geomalgorithms.com/a10-_hull-1.html\n\n        var upper = [],\n            lower = [], \n            vertex,\n            i;\n\n        // sort vertices on x-axis (y-axis for ties)\n        vertices = vertices.slice(0);\n        vertices.sort(function(vertexA, vertexB) {\n            var dx = vertexA.x - vertexB.x;\n            return dx !== 0 ? dx : vertexA.y - vertexB.y;\n        });\n\n        // build lower hull\n        for (i = 0; i < vertices.length; i += 1) {\n            vertex = vertices[i];\n\n            while (lower.length >= 2 \n                   && Vector.cross3(lower[lower.length - 2], lower[lower.length - 1], vertex) <= 0) {\n                lower.pop();\n            }\n\n            lower.push(vertex);\n        }\n\n        // build upper hull\n        for (i = vertices.length - 1; i >= 0; i -= 1) {\n            vertex = vertices[i];\n\n            while (upper.length >= 2 \n                   && Vector.cross3(upper[upper.length - 2], upper[upper.length - 1], vertex) <= 0) {\n                upper.pop();\n            }\n\n            upper.push(vertex);\n        }\n\n        // concatenation of the lower and upper hulls gives the convex hull\n        // omit last points because they are repeated at the beginning of the other list\n        upper.pop();\n        lower.pop();\n\n        return upper.concat(lower);\n    };\n\n})();\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_49544__) {\n\n/**\n* The `Matter.Body` module contains methods for creating and manipulating rigid bodies.\n* For creating bodies with common configurations such as rectangles, circles and other polygons see the module `Matter.Bodies`.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n\n* @class Body\n*/\n\nvar Body = {};\n\nmodule.exports = Body;\n\nvar Vertices = __nested_webpack_require_49544__(3);\nvar Vector = __nested_webpack_require_49544__(2);\nvar Sleeping = __nested_webpack_require_49544__(7);\nvar Common = __nested_webpack_require_49544__(0);\nvar Bounds = __nested_webpack_require_49544__(1);\nvar Axes = __nested_webpack_require_49544__(11);\n\n(function() {\n\n    Body._timeCorrection = true;\n    Body._inertiaScale = 4;\n    Body._nextCollidingGroupId = 1;\n    Body._nextNonCollidingGroupId = -1;\n    Body._nextCategory = 0x0001;\n    Body._baseDelta = 1000 / 60;\n\n    /**\n     * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * Vertices must be specified in clockwise order.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {body} body\n     */\n    Body.create = function(options) {\n        var defaults = {\n            id: Common.nextId(),\n            type: 'body',\n            label: 'Body',\n            parts: [],\n            plugin: {},\n            angle: 0,\n            vertices: Vertices.fromPath('L 0 0 L 40 0 L 40 40 L 0 40'),\n            position: { x: 0, y: 0 },\n            force: { x: 0, y: 0 },\n            torque: 0,\n            positionImpulse: { x: 0, y: 0 },\n            constraintImpulse: { x: 0, y: 0, angle: 0 },\n            totalContacts: 0,\n            speed: 0,\n            angularSpeed: 0,\n            velocity: { x: 0, y: 0 },\n            angularVelocity: 0,\n            isSensor: false,\n            isStatic: false,\n            isSleeping: false,\n            motion: 0,\n            sleepThreshold: 60,\n            density: 0.001,\n            restitution: 0,\n            friction: 0.1,\n            frictionStatic: 0.5,\n            frictionAir: 0.01,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            },\n            slop: 0.05,\n            timeScale: 1,\n            render: {\n                visible: true,\n                opacity: 1,\n                strokeStyle: null,\n                fillStyle: null,\n                lineWidth: null,\n                sprite: {\n                    xScale: 1,\n                    yScale: 1,\n                    xOffset: 0,\n                    yOffset: 0\n                }\n            },\n            events: null,\n            bounds: null,\n            chamfer: null,\n            circleRadius: 0,\n            positionPrev: null,\n            anglePrev: 0,\n            parent: null,\n            axes: null,\n            area: 0,\n            mass: 0,\n            inertia: 0,\n            deltaTime: 1000 / 60,\n            _original: null\n        };\n\n        var body = Common.extend(defaults, options);\n\n        _initProperties(body, options);\n\n        return body;\n    };\n\n    /**\n     * Returns the next unique group index for which bodies will collide.\n     * If `isNonColliding` is `true`, returns the next unique group index for which bodies will _not_ collide.\n     * See `body.collisionFilter` for more information.\n     * @method nextGroup\n     * @param {bool} [isNonColliding=false]\n     * @return {Number} Unique group index\n     */\n    Body.nextGroup = function(isNonColliding) {\n        if (isNonColliding)\n            return Body._nextNonCollidingGroupId--;\n\n        return Body._nextCollidingGroupId++;\n    };\n\n    /**\n     * Returns the next unique category bitfield (starting after the initial default category `0x0001`).\n     * There are 32 available. See `body.collisionFilter` for more information.\n     * @method nextCategory\n     * @return {Number} Unique category bitfield\n     */\n    Body.nextCategory = function() {\n        Body._nextCategory = Body._nextCategory << 1;\n        return Body._nextCategory;\n    };\n\n    /**\n     * Initialises body properties.\n     * @method _initProperties\n     * @private\n     * @param {body} body\n     * @param {} [options]\n     */\n    var _initProperties = function(body, options) {\n        options = options || {};\n\n        // init required properties (order is important)\n        Body.set(body, {\n            bounds: body.bounds || Bounds.create(body.vertices),\n            positionPrev: body.positionPrev || Vector.clone(body.position),\n            anglePrev: body.anglePrev || body.angle,\n            vertices: body.vertices,\n            parts: body.parts || [body],\n            isStatic: body.isStatic,\n            isSleeping: body.isSleeping,\n            parent: body.parent || body\n        });\n\n        Vertices.rotate(body.vertices, body.angle, body.position);\n        Axes.rotate(body.axes, body.angle);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n\n        // allow options to override the automatically calculated properties\n        Body.set(body, {\n            axes: options.axes || body.axes,\n            area: options.area || body.area,\n            mass: options.mass || body.mass,\n            inertia: options.inertia || body.inertia\n        });\n\n        // render properties\n        var defaultFillStyle = (body.isStatic ? '#14151f' : Common.choose(['#f19648', '#f5d259', '#f55a3c', '#063e7b', '#ececd1'])),\n            defaultStrokeStyle = body.isStatic ? '#555' : '#ccc',\n            defaultLineWidth = body.isStatic && body.render.fillStyle === null ? 1 : 0;\n        body.render.fillStyle = body.render.fillStyle || defaultFillStyle;\n        body.render.strokeStyle = body.render.strokeStyle || defaultStrokeStyle;\n        body.render.lineWidth = body.render.lineWidth || defaultLineWidth;\n        body.render.sprite.xOffset += -(body.bounds.min.x - body.position.x) / (body.bounds.max.x - body.bounds.min.x);\n        body.render.sprite.yOffset += -(body.bounds.min.y - body.position.y) / (body.bounds.max.y - body.bounds.min.y);\n    };\n\n    /**\n     * Given a property and a value (or map of), sets the property(s) on the body, using the appropriate setter functions if they exist.\n     * Prefer to use the actual setter functions in performance critical situations.\n     * @method set\n     * @param {body} body\n     * @param {} settings A property name (or map of properties and values) to set on the body.\n     * @param {} value The value to set if `settings` is a single property name.\n     */\n    Body.set = function(body, settings, value) {\n        var property;\n\n        if (typeof settings === 'string') {\n            property = settings;\n            settings = {};\n            settings[property] = value;\n        }\n\n        for (property in settings) {\n            if (!Object.prototype.hasOwnProperty.call(settings, property))\n                continue;\n\n            value = settings[property];\n            switch (property) {\n\n            case 'isStatic':\n                Body.setStatic(body, value);\n                break;\n            case 'isSleeping':\n                Sleeping.set(body, value);\n                break;\n            case 'mass':\n                Body.setMass(body, value);\n                break;\n            case 'density':\n                Body.setDensity(body, value);\n                break;\n            case 'inertia':\n                Body.setInertia(body, value);\n                break;\n            case 'vertices':\n                Body.setVertices(body, value);\n                break;\n            case 'position':\n                Body.setPosition(body, value);\n                break;\n            case 'angle':\n                Body.setAngle(body, value);\n                break;\n            case 'velocity':\n                Body.setVelocity(body, value);\n                break;\n            case 'angularVelocity':\n                Body.setAngularVelocity(body, value);\n                break;\n            case 'speed':\n                Body.setSpeed(body, value);\n                break;\n            case 'angularSpeed':\n                Body.setAngularSpeed(body, value);\n                break;\n            case 'parts':\n                Body.setParts(body, value);\n                break;\n            case 'centre':\n                Body.setCentre(body, value);\n                break;\n            default:\n                body[property] = value;\n\n            }\n        }\n    };\n\n    /**\n     * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.\n     * @method setStatic\n     * @param {body} body\n     * @param {bool} isStatic\n     */\n    Body.setStatic = function(body, isStatic) {\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.isStatic = isStatic;\n\n            if (isStatic) {\n                part._original = {\n                    restitution: part.restitution,\n                    friction: part.friction,\n                    mass: part.mass,\n                    inertia: part.inertia,\n                    density: part.density,\n                    inverseMass: part.inverseMass,\n                    inverseInertia: part.inverseInertia\n                };\n\n                part.restitution = 0;\n                part.friction = 1;\n                part.mass = part.inertia = part.density = Infinity;\n                part.inverseMass = part.inverseInertia = 0;\n\n                part.positionPrev.x = part.position.x;\n                part.positionPrev.y = part.position.y;\n                part.anglePrev = part.angle;\n                part.angularVelocity = 0;\n                part.speed = 0;\n                part.angularSpeed = 0;\n                part.motion = 0;\n            } else if (part._original) {\n                part.restitution = part._original.restitution;\n                part.friction = part._original.friction;\n                part.mass = part._original.mass;\n                part.inertia = part._original.inertia;\n                part.density = part._original.density;\n                part.inverseMass = part._original.inverseMass;\n                part.inverseInertia = part._original.inverseInertia;\n\n                part._original = null;\n            }\n        }\n    };\n\n    /**\n     * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.\n     * @method setMass\n     * @param {body} body\n     * @param {number} mass\n     */\n    Body.setMass = function(body, mass) {\n        var moment = body.inertia / (body.mass / 6);\n        body.inertia = moment * (mass / 6);\n        body.inverseInertia = 1 / body.inertia;\n\n        body.mass = mass;\n        body.inverseMass = 1 / body.mass;\n        body.density = body.mass / body.area;\n    };\n\n    /**\n     * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.\n     * @method setDensity\n     * @param {body} body\n     * @param {number} density\n     */\n    Body.setDensity = function(body, density) {\n        Body.setMass(body, density * body.area);\n        body.density = density;\n    };\n\n    /**\n     * Sets the moment of inertia of the body. This is the second moment of area in two dimensions.\n     * Inverse inertia is automatically updated to reflect the change. Mass is not changed.\n     * @method setInertia\n     * @param {body} body\n     * @param {number} inertia\n     */\n    Body.setInertia = function(body, inertia) {\n        body.inertia = inertia;\n        body.inverseInertia = 1 / body.inertia;\n    };\n\n    /**\n     * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).\n     * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.\n     * They are then automatically translated to world space based on `body.position`.\n     *\n     * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).\n     * Vertices must form a convex hull. Concave vertices must be decomposed into convex parts.\n     * \n     * @method setVertices\n     * @param {body} body\n     * @param {vector[]} vertices\n     */\n    Body.setVertices = function(body, vertices) {\n        // change vertices\n        if (vertices[0].body === body) {\n            body.vertices = vertices;\n        } else {\n            body.vertices = Vertices.create(vertices, body);\n        }\n\n        // update properties\n        body.axes = Axes.fromVertices(body.vertices);\n        body.area = Vertices.area(body.vertices);\n        Body.setMass(body, body.density * body.area);\n\n        // orient vertices around the centre of mass at origin (0, 0)\n        var centre = Vertices.centre(body.vertices);\n        Vertices.translate(body.vertices, centre, -1);\n\n        // update inertia while vertices are at origin (0, 0)\n        Body.setInertia(body, Body._inertiaScale * Vertices.inertia(body.vertices, body.mass));\n\n        // update geometry\n        Vertices.translate(body.vertices, body.position);\n        Bounds.update(body.bounds, body.vertices, body.velocity);\n    };\n\n    /**\n     * Sets the parts of the `body` and updates mass, inertia and centroid.\n     * Each part will have its parent set to `body`.\n     * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`\n     * Note that this method will ensure that the first part in `body.parts` will always be the `body`.\n     * @method setParts\n     * @param {body} body\n     * @param {body[]} parts\n     * @param {bool} [autoHull=true]\n     */\n    Body.setParts = function(body, parts, autoHull) {\n        var i;\n\n        // add all the parts, ensuring that the first part is always the parent body\n        parts = parts.slice(0);\n        body.parts.length = 0;\n        body.parts.push(body);\n        body.parent = body;\n\n        for (i = 0; i < parts.length; i++) {\n            var part = parts[i];\n            if (part !== body) {\n                part.parent = body;\n                body.parts.push(part);\n            }\n        }\n\n        if (body.parts.length === 1)\n            return;\n\n        autoHull = typeof autoHull !== 'undefined' ? autoHull : true;\n\n        // find the convex hull of all parts to set on the parent body\n        if (autoHull) {\n            var vertices = [];\n            for (i = 0; i < parts.length; i++) {\n                vertices = vertices.concat(parts[i].vertices);\n            }\n\n            Vertices.clockwiseSort(vertices);\n\n            var hull = Vertices.hull(vertices),\n                hullCentre = Vertices.centre(hull);\n\n            Body.setVertices(body, hull);\n            Vertices.translate(body.vertices, hullCentre);\n        }\n\n        // sum the properties of all compound parts of the parent body\n        var total = Body._totalProperties(body);\n\n        body.area = total.area;\n        body.parent = body;\n        body.position.x = total.centre.x;\n        body.position.y = total.centre.y;\n        body.positionPrev.x = total.centre.x;\n        body.positionPrev.y = total.centre.y;\n\n        Body.setMass(body, total.mass);\n        Body.setInertia(body, total.inertia);\n        Body.setPosition(body, total.centre);\n    };\n\n    /**\n     * Set the centre of mass of the body. \n     * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.\n     * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.\n     * This is equal to moving `body.position` but not the `body.vertices`.\n     * Invalid if the `centre` falls outside the body's convex hull.\n     * @method setCentre\n     * @param {body} body\n     * @param {vector} centre\n     * @param {bool} relative\n     */\n    Body.setCentre = function(body, centre, relative) {\n        if (!relative) {\n            body.positionPrev.x = centre.x - (body.position.x - body.positionPrev.x);\n            body.positionPrev.y = centre.y - (body.position.y - body.positionPrev.y);\n            body.position.x = centre.x;\n            body.position.y = centre.y;\n        } else {\n            body.positionPrev.x += centre.x;\n            body.positionPrev.y += centre.y;\n            body.position.x += centre.x;\n            body.position.y += centre.y;\n        }\n    };\n\n    /**\n     * Sets the position of the body. By default velocity is unchanged.\n     * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n     * @method setPosition\n     * @param {body} body\n     * @param {vector} position\n     * @param {boolean} [updateVelocity=false]\n     */\n    Body.setPosition = function(body, position, updateVelocity) {\n        var delta = Vector.sub(position, body.position);\n\n        if (updateVelocity) {\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n            body.velocity.x = delta.x;\n            body.velocity.y = delta.y;\n            body.speed = Vector.magnitude(delta);\n        } else {\n            body.positionPrev.x += delta.x;\n            body.positionPrev.y += delta.y;\n        }\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.position.x += delta.x;\n            part.position.y += delta.y;\n            Vertices.translate(part.vertices, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n    };\n\n    /**\n     * Sets the angle of the body. By default angular velocity is unchanged.\n     * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n     * @method setAngle\n     * @param {body} body\n     * @param {number} angle\n     * @param {boolean} [updateVelocity=false]\n     */\n    Body.setAngle = function(body, angle, updateVelocity) {\n        var delta = angle - body.angle;\n        \n        if (updateVelocity) {\n            body.anglePrev = body.angle;\n            body.angularVelocity = delta;\n            body.angularSpeed = Math.abs(delta);\n        } else {\n            body.anglePrev += delta;\n        }\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n            part.angle += delta;\n            Vertices.rotate(part.vertices, delta, body.position);\n            Axes.rotate(part.axes, delta);\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n            if (i > 0) {\n                Vector.rotateAbout(part.position, delta, body.position, part.position);\n            }\n        }\n    };\n\n    /**\n     * Sets the current linear velocity of the body.  \n     * Affects body speed.\n     * @method setVelocity\n     * @param {body} body\n     * @param {vector} velocity\n     */\n    Body.setVelocity = function(body, velocity) {\n        var timeScale = body.deltaTime / Body._baseDelta;\n        body.positionPrev.x = body.position.x - velocity.x * timeScale;\n        body.positionPrev.y = body.position.y - velocity.y * timeScale;\n        body.velocity.x = (body.position.x - body.positionPrev.x) / timeScale;\n        body.velocity.y = (body.position.y - body.positionPrev.y) / timeScale;\n        body.speed = Vector.magnitude(body.velocity);\n    };\n\n    /**\n     * Gets the current linear velocity of the body.\n     * @method getVelocity\n     * @param {body} body\n     * @return {vector} velocity\n     */\n    Body.getVelocity = function(body) {\n        var timeScale = Body._baseDelta / body.deltaTime;\n\n        return {\n            x: (body.position.x - body.positionPrev.x) * timeScale,\n            y: (body.position.y - body.positionPrev.y) * timeScale\n        };\n    };\n\n    /**\n     * Gets the current linear speed of the body.  \n     * Equivalent to the magnitude of its velocity.\n     * @method getSpeed\n     * @param {body} body\n     * @return {number} speed\n     */\n    Body.getSpeed = function(body) {\n        return Vector.magnitude(Body.getVelocity(body));\n    };\n\n    /**\n     * Sets the current linear speed of the body.  \n     * Direction is maintained. Affects body velocity.\n     * @method setSpeed\n     * @param {body} body\n     * @param {number} speed\n     */\n    Body.setSpeed = function(body, speed) {\n        Body.setVelocity(body, Vector.mult(Vector.normalise(Body.getVelocity(body)), speed));\n    };\n\n    /**\n     * Sets the current rotational velocity of the body.  \n     * Affects body angular speed.\n     * @method setAngularVelocity\n     * @param {body} body\n     * @param {number} velocity\n     */\n    Body.setAngularVelocity = function(body, velocity) {\n        var timeScale = body.deltaTime / Body._baseDelta;\n        body.anglePrev = body.angle - velocity * timeScale;\n        body.angularVelocity = (body.angle - body.anglePrev) / timeScale;\n        body.angularSpeed = Math.abs(body.angularVelocity);\n    };\n\n    /**\n     * Gets the current rotational velocity of the body.\n     * @method getAngularVelocity\n     * @param {body} body\n     * @return {number} angular velocity\n     */\n    Body.getAngularVelocity = function(body) {\n        return (body.angle - body.anglePrev) * Body._baseDelta / body.deltaTime;\n    };\n\n    /**\n     * Gets the current rotational speed of the body.  \n     * Equivalent to the magnitude of its angular velocity.\n     * @method getAngularSpeed\n     * @param {body} body\n     * @return {number} angular speed\n     */\n    Body.getAngularSpeed = function(body) {\n        return Math.abs(Body.getAngularVelocity(body));\n    };\n\n    /**\n     * Sets the current rotational speed of the body.  \n     * Direction is maintained. Affects body angular velocity.\n     * @method setAngularSpeed\n     * @param {body} body\n     * @param {number} speed\n     */\n    Body.setAngularSpeed = function(body, speed) {\n        Body.setAngularVelocity(body, Common.sign(Body.getAngularVelocity(body)) * speed);\n    };\n\n    /**\n     * Moves a body by a given vector relative to its current position. By default velocity is unchanged.\n     * If `updateVelocity` is `true` then velocity is inferred from the change in position.\n     * @method translate\n     * @param {body} body\n     * @param {vector} translation\n     * @param {boolean} [updateVelocity=false]\n     */\n    Body.translate = function(body, translation, updateVelocity) {\n        Body.setPosition(body, Vector.add(body.position, translation), updateVelocity);\n    };\n\n    /**\n     * Rotates a body by a given angle relative to its current angle. By default angular velocity is unchanged.\n     * If `updateVelocity` is `true` then angular velocity is inferred from the change in angle.\n     * @method rotate\n     * @param {body} body\n     * @param {number} rotation\n     * @param {vector} [point]\n     * @param {boolean} [updateVelocity=false]\n     */\n    Body.rotate = function(body, rotation, point, updateVelocity) {\n        if (!point) {\n            Body.setAngle(body, body.angle + rotation, updateVelocity);\n        } else {\n            var cos = Math.cos(rotation),\n                sin = Math.sin(rotation),\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + (dx * cos - dy * sin),\n                y: point.y + (dx * sin + dy * cos)\n            }, updateVelocity);\n\n            Body.setAngle(body, body.angle + rotation, updateVelocity);\n        }\n    };\n\n    /**\n     * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).\n     * @method scale\n     * @param {body} body\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} [point]\n     */\n    Body.scale = function(body, scaleX, scaleY, point) {\n        var totalArea = 0,\n            totalInertia = 0;\n\n        point = point || body.position;\n\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            // scale vertices\n            Vertices.scale(part.vertices, scaleX, scaleY, point);\n\n            // update properties\n            part.axes = Axes.fromVertices(part.vertices);\n            part.area = Vertices.area(part.vertices);\n            Body.setMass(part, body.density * part.area);\n\n            // update inertia (requires vertices to be at origin)\n            Vertices.translate(part.vertices, { x: -part.position.x, y: -part.position.y });\n            Body.setInertia(part, Body._inertiaScale * Vertices.inertia(part.vertices, part.mass));\n            Vertices.translate(part.vertices, { x: part.position.x, y: part.position.y });\n\n            if (i > 0) {\n                totalArea += part.area;\n                totalInertia += part.inertia;\n            }\n\n            // scale position\n            part.position.x = point.x + (part.position.x - point.x) * scaleX;\n            part.position.y = point.y + (part.position.y - point.y) * scaleY;\n\n            // update bounds\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n\n        // handle parent body\n        if (body.parts.length > 1) {\n            body.area = totalArea;\n\n            if (!body.isStatic) {\n                Body.setMass(body, body.density * totalArea);\n                Body.setInertia(body, totalInertia);\n            }\n        }\n\n        // handle circles\n        if (body.circleRadius) { \n            if (scaleX === scaleY) {\n                body.circleRadius *= scaleX;\n            } else {\n                // body is no longer a circle\n                body.circleRadius = null;\n            }\n        }\n    };\n\n    /**\n     * Performs an update by integrating the equations of motion on the `body`.\n     * This is applied every update by `Matter.Engine` automatically.\n     * @method update\n     * @param {body} body\n     * @param {number} [deltaTime=16.666]\n     */\n    Body.update = function(body, deltaTime) {\n        deltaTime = (typeof deltaTime !== 'undefined' ? deltaTime : (1000 / 60)) * body.timeScale;\n\n        var deltaTimeSquared = deltaTime * deltaTime,\n            correction = Body._timeCorrection ? deltaTime / (body.deltaTime || deltaTime) : 1;\n\n        // from the previous step\n        var frictionAir = 1 - body.frictionAir * (deltaTime / Common._baseDelta),\n            velocityPrevX = (body.position.x - body.positionPrev.x) * correction,\n            velocityPrevY = (body.position.y - body.positionPrev.y) * correction;\n\n        // update velocity with Verlet integration\n        body.velocity.x = (velocityPrevX * frictionAir) + (body.force.x / body.mass) * deltaTimeSquared;\n        body.velocity.y = (velocityPrevY * frictionAir) + (body.force.y / body.mass) * deltaTimeSquared;\n\n        body.positionPrev.x = body.position.x;\n        body.positionPrev.y = body.position.y;\n        body.position.x += body.velocity.x;\n        body.position.y += body.velocity.y;\n        body.deltaTime = deltaTime;\n\n        // update angular velocity with Verlet integration\n        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;\n        body.anglePrev = body.angle;\n        body.angle += body.angularVelocity;\n\n        // transform the body geometry\n        for (var i = 0; i < body.parts.length; i++) {\n            var part = body.parts[i];\n\n            Vertices.translate(part.vertices, body.velocity);\n            \n            if (i > 0) {\n                part.position.x += body.velocity.x;\n                part.position.y += body.velocity.y;\n            }\n\n            if (body.angularVelocity !== 0) {\n                Vertices.rotate(part.vertices, body.angularVelocity, body.position);\n                Axes.rotate(part.axes, body.angularVelocity);\n                if (i > 0) {\n                    Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);\n                }\n            }\n\n            Bounds.update(part.bounds, part.vertices, body.velocity);\n        }\n    };\n\n    /**\n     * Updates properties `body.velocity`, `body.speed`, `body.angularVelocity` and `body.angularSpeed` which are normalised in relation to `Body._baseDelta`.\n     * @method updateVelocities\n     * @param {body} body\n     */\n    Body.updateVelocities = function(body) {\n        var timeScale = Body._baseDelta / body.deltaTime,\n            bodyVelocity = body.velocity;\n\n        bodyVelocity.x = (body.position.x - body.positionPrev.x) * timeScale;\n        bodyVelocity.y = (body.position.y - body.positionPrev.y) * timeScale;\n        body.speed = Math.sqrt((bodyVelocity.x * bodyVelocity.x) + (bodyVelocity.y * bodyVelocity.y));\n\n        body.angularVelocity = (body.angle - body.anglePrev) * timeScale;\n        body.angularSpeed = Math.abs(body.angularVelocity);\n    };\n\n    /**\n     * Applies the `force` to the `body` from the force origin `position` in world-space, over a single timestep, including applying any resulting angular torque.\n     * \n     * Forces are useful for effects like gravity, wind or rocket thrust, but can be difficult in practice when precise control is needed. In these cases see `Body.setVelocity` and `Body.setPosition` as an alternative.\n     * \n     * The force from this function is only applied once for the duration of a single timestep, in other words the duration depends directly on the current engine update `delta` and the rate of calls to this function.\n     * \n     * Therefore to account for time, you should apply the force constantly over as many engine updates as equivalent to the intended duration.\n     * \n     * If all or part of the force duration is some fraction of a timestep, first multiply the force by `duration / timestep`.\n     * \n     * The force origin `position` in world-space must also be specified. Passing `body.position` will result in zero angular effect as the force origin would be at the centre of mass.\n     * \n     * The `body` will take time to accelerate under a force, the resulting effect depends on duration of the force, the body mass and other forces on the body including friction combined.\n     * @method applyForce\n     * @param {body} body\n     * @param {vector} position The force origin in world-space. Pass `body.position` to avoid angular torque.\n     * @param {vector} force\n     */\n    Body.applyForce = function(body, position, force) {\n        var offset = { x: position.x - body.position.x, y: position.y - body.position.y };\n        body.force.x += force.x;\n        body.force.y += force.y;\n        body.torque += offset.x * force.y - offset.y * force.x;\n    };\n\n    /**\n     * Returns the sums of the properties of all compound parts of the parent body.\n     * @method _totalProperties\n     * @private\n     * @param {body} body\n     * @return {}\n     */\n    Body._totalProperties = function(body) {\n        // from equations at:\n        // https://ecourses.ou.edu/cgi-bin/ebook.cgi?doc=&topic=st&chap_sec=07.2&page=theory\n        // http://output.to/sideway/default.asp?qno=121100087\n\n        var properties = {\n            mass: 0,\n            area: 0,\n            inertia: 0,\n            centre: { x: 0, y: 0 }\n        };\n\n        // sum the properties of all compound parts of the parent body\n        for (var i = body.parts.length === 1 ? 0 : 1; i < body.parts.length; i++) {\n            var part = body.parts[i],\n                mass = part.mass !== Infinity ? part.mass : 1;\n\n            properties.mass += mass;\n            properties.area += part.area;\n            properties.inertia += part.inertia;\n            properties.centre = Vector.add(properties.centre, Vector.mult(part.position, mass));\n        }\n\n        properties.centre = Vector.div(properties.centre, properties.mass);\n\n        return properties;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when a body starts sleeping (where `this` is the body).\n    *\n    * @event sleepStart\n    * @this {body} The body that has started sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a body ends sleeping (where `this` is the body).\n    *\n    * @event sleepEnd\n    * @this {body} The body that has ended sleeping\n    * @param {} event An event object\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Body.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * _Read only_. Set by `Body.create`.\n     * \n     * A `String` denoting the type of object.\n     *\n     * @readOnly\n     * @property type\n     * @type string\n     * @default \"body\"\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Body\"\n     */\n\n    /**\n     * _Read only_. Use `Body.setParts` to set. \n     * \n     * An array of bodies that make up this body. \n     * The first body in the array must always be a self reference to the current body instance.\n     * All bodies in the `parts` array together form a single rigid compound body.\n     * Parts are allowed to overlap, have gaps or holes or even form concave bodies.\n     * Parts themselves should never be added to a `World`, only the parent body should be.\n     * Use `Body.setParts` when setting parts to ensure correct updates of all properties.\n     *\n     * @readOnly\n     * @property parts\n     * @type body[]\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * _Read only_. Updated by `Body.setParts`.\n     * \n     * A reference to the body that this is a part of. See `body.parts`.\n     * This is a self reference if the body is not a part of another body.\n     *\n     * @readOnly\n     * @property parent\n     * @type body\n     */\n\n    /**\n     * A `Number` specifying the angle of the body, in radians.\n     *\n     * @property angle\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setVertices` or `Body.setParts` to set. See also `Bodies.fromVertices`.\n     * \n     * An array of `Vector` objects that specify the convex hull of the rigid body.\n     * These should be provided about the origin `(0, 0)`. E.g.\n     *\n     * `[{ x: 0, y: 0 }, { x: 25, y: 50 }, { x: 50, y: 0 }]`\n     * \n     * Vertices must always be convex, in clockwise order and must not contain any duplicate points.\n     * \n     * Concave vertices should be decomposed into convex `parts`, see `Bodies.fromVertices` and `Body.setParts`.\n     *\n     * When set the vertices are translated such that `body.position` is at the centre of mass.\n     * Many other body properties are automatically calculated from these vertices when set including `density`, `area` and `inertia`.\n     * \n     * The module `Matter.Vertices` contains useful methods for working with vertices.\n     *\n     * @readOnly\n     * @property vertices\n     * @type vector[]\n     */\n\n    /**\n     * _Read only_. Use `Body.setPosition` to set. \n     * \n     * A `Vector` that specifies the current world-space position of the body.\n     * \n     * @readOnly\n     * @property position\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that accumulates the total force applied to the body for a single update.\n     * Force is zeroed after every `Engine.update`, so constant forces should be applied for every update they are needed. See also `Body.applyForce`.\n     * \n     * @property force\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that accumulates the total torque (turning force) applied to the body for a single update. See also `Body.applyForce`.\n     * Torque is zeroed after every `Engine.update`, so constant torques should be applied for every update they are needed.\n     *\n     * Torques result in angular acceleration on every update, which depends on body inertia and the engine update delta.\n     * \n     * @property torque\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setSpeed` to set. \n     * \n     * See `Body.getSpeed` for details.\n     * \n     * Equivalent to the magnitude of `body.velocity` (always positive).\n     * \n     * @readOnly\n     * @property speed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setVelocity` to set. \n     * \n     * See `Body.getVelocity` for details.\n     * \n     * Equivalent to the magnitude of `body.angularVelocity` (always positive).\n     * \n     * @readOnly\n     * @property velocity\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * _Read only_. Use `Body.setAngularSpeed` to set. \n     * \n     * See `Body.getAngularSpeed` for details.\n     * \n     * \n     * @readOnly\n     * @property angularSpeed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setAngularVelocity` to set. \n     * \n     * See `Body.getAngularVelocity` for details.\n     * \n     *\n     * @readOnly\n     * @property angularVelocity\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * _Read only_. Use `Body.setStatic` to set. \n     * \n     * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.\n     *\n     * @readOnly\n     * @property isStatic\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.\n     *\n     * @property isSensor\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * _Read only_. Use `Sleeping.set` to set. \n     * \n     * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.\n     *\n     * @readOnly\n     * @property isSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * _Read only_. Calculated during engine update only when sleeping is enabled.\n     * \n     * A `Number` that loosely measures the amount of movement a body currently has.\n     *\n     * Derived from `body.speed^2 + body.angularSpeed^2`. See `Sleeping.update`.\n     * \n     * @readOnly\n     * @property motion\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the length of time during which this body must have near-zero velocity before it is set as sleeping by the `Matter.Sleeping` module (if sleeping is enabled by the engine).\n     * \n     * @property sleepThreshold\n     * @type number\n     * @default 60\n     */\n\n    /**\n     * _Read only_. Use `Body.setDensity` to set. \n     * \n     * A `Number` that defines the density of the body (mass per unit area).\n     * \n     * Mass will also be updated when set.\n     *\n     * @readOnly\n     * @property density\n     * @type number\n     * @default 0.001\n     */\n\n    /**\n     * _Read only_. Use `Body.setMass` to set. \n     * \n     * A `Number` that defines the mass of the body.\n     * \n     * Density will also be updated when set.\n     * \n     * @readOnly\n     * @property mass\n     * @type number\n     */\n\n    /**\n     * _Read only_. Use `Body.setMass` to set. \n     * \n     * A `Number` that defines the inverse mass of the body (`1 / mass`).\n     *\n     * @readOnly\n     * @property inverseMass\n     * @type number\n     */\n\n    /**\n     * _Read only_. Automatically calculated when vertices, mass or density are set or set through `Body.setInertia`.\n     * \n     * A `Number` that defines the moment of inertia of the body. This is the second moment of area in two dimensions.\n     * \n     * Can be manually set to `Infinity` to prevent rotation of the body. See `Body.setInertia`.\n     * \n     * @readOnly\n     * @property inertia\n     * @type number\n     */\n\n    /**\n     * _Read only_. Automatically calculated when vertices, mass or density are set or calculated by `Body.setInertia`.\n     * \n     * A `Number` that defines the inverse moment of inertia of the body (`1 / inertia`).\n     * \n     * @readOnly\n     * @property inverseInertia\n     * @type number\n     */\n\n    /**\n     * A `Number` that defines the restitution (elasticity) of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means collisions may be perfectly inelastic and no bouncing may occur. \n     * A value of `0.8` means the body may bounce back with approximately 80% of its kinetic energy.\n     * Note that collision response is based on _pairs_ of bodies, and that `restitution` values are _combined_ with the following formula:\n     *\n     * `Math.max(bodyA.restitution, bodyB.restitution)`\n     *\n     * @property restitution\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that defines the friction of the body. The value is always positive and is in the range `(0, 1)`.\n     * A value of `0` means that the body may slide indefinitely.\n     * A value of `1` means the body may come to a stop almost instantly after a force is applied.\n     *\n     * The effects of the value may be non-linear. \n     * High values may be unstable depending on the body.\n     * The engine uses a Coulomb friction model including static and kinetic friction.\n     * Note that collision response is based on _pairs_ of bodies, and that `friction` values are _combined_ with the following formula:\n     *\n     * `Math.min(bodyA.friction, bodyB.friction)`\n     *\n     * @property friction\n     * @type number\n     * @default 0.1\n     */\n\n    /**\n     * A `Number` that defines the static friction of the body (in the Coulomb friction model). \n     * A value of `0` means the body will never 'stick' when it is nearly stationary and only dynamic `friction` is used.\n     * The higher the value (e.g. `10`), the more force it will take to initially get the body moving when nearly stationary.\n     * This value is multiplied with the `friction` property to make it easier to change `friction` and maintain an appropriate amount of static friction.\n     *\n     * @property frictionStatic\n     * @type number\n     * @default 0.5\n     */\n\n    /**\n     * A `Number` that defines the air friction of the body (air resistance). \n     * A value of `0` means the body will never slow as it moves through space.\n     * The higher the value, the faster a body slows when moving through space.\n     * The effects of the value are non-linear. \n     *\n     * @property frictionAir\n     * @type number\n     * @default 0.01\n     */\n\n    /**\n     * An `Object` that specifies the collision filtering properties of this body.\n     *\n     * Collisions between two bodies will obey the following rules:\n     * - If the two bodies have the same non-zero value of `collisionFilter.group`,\n     *   they will always collide if the value is positive, and they will never collide\n     *   if the value is negative.\n     * - If the two bodies have different values of `collisionFilter.group` or if one\n     *   (or both) of the bodies has a value of 0, then the category/mask rules apply as follows:\n     *\n     * Each body belongs to a collision category, given by `collisionFilter.category`. This\n     * value is used as a bit field and the category should have only one bit set, meaning that\n     * the value of this property is a power of two in the range [1, 2^31]. Thus, there are 32\n     * different collision categories available.\n     *\n     * Each body also defines a collision bitmask, given by `collisionFilter.mask` which specifies\n     * the categories it collides with (the value is the bitwise AND value of all these categories).\n     *\n     * Using the category/mask rules, two bodies `A` and `B` collide if each includes the other's\n     * category in its mask, i.e. `(categoryA & maskB) !== 0` and `(categoryB & maskA) !== 0`\n     * are both true.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n    /**\n     * An Integer `Number`, that specifies the collision group this body belongs to.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.group\n     * @type object\n     * @default 0\n     */\n\n    /**\n     * A bit field that specifies the collision category this body belongs to.\n     * The category value should have only one bit set, for example `0x0001`.\n     * This means there are up to 32 unique collision categories available.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.category\n     * @type object\n     * @default 1\n     */\n\n    /**\n     * A bit mask that specifies the collision categories this body may collide with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter.mask\n     * @type object\n     * @default -1\n     */\n\n    /**\n     * A `Number` that specifies a thin boundary around the body where it is allowed to slightly sink into other bodies.\n     * \n     * This is required for proper collision response, including friction and restitution effects.\n     * \n     * The default should generally suffice in most cases. You may need to decrease this value for very small bodies that are nearing the default value in scale.\n     *\n     * @property slop\n     * @type number\n     * @default 0.05\n     */\n\n    /**\n     * A `Number` that specifies per-body time scaling.\n     *\n     * @property timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * _Read only_. Updated during engine update.\n     * \n     * A `Number` that records the last delta time value used to update this body.\n     * Used to calculate speed and velocity.\n     *\n     * @readOnly\n     * @property deltaTime\n     * @type number\n     * @default 1000 / 60\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the body should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * Sets the opacity to use when rendering.\n     *\n     * @property render.opacity\n     * @type number\n     * @default 1\n    */\n\n    /**\n     * An `Object` that defines the sprite properties to use when rendering, if any.\n     *\n     * @property render.sprite\n     * @type object\n     */\n\n    /**\n     * An `String` that defines the path to the image to use as the sprite texture, if any.\n     *\n     * @property render.sprite.texture\n     * @type string\n     */\n     \n    /**\n     * A `Number` that defines the scaling in the x-axis for the sprite, if any.\n     *\n     * @property render.sprite.xScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that defines the scaling in the y-axis for the sprite, if any.\n     *\n     * @property render.sprite.yScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n      * A `Number` that defines the offset in the x-axis for the sprite (normalised by texture width).\n      *\n      * @property render.sprite.xOffset\n      * @type number\n      * @default 0\n      */\n\n    /**\n      * A `Number` that defines the offset in the y-axis for the sprite (normalised by texture height).\n      *\n      * @property render.sprite.yOffset\n      * @type number\n      * @default 0\n      */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the body outline (if a sprite is not defined).\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `String` that defines the fill style to use when rendering the body (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.fillStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the body outline (if a sprite is not defined).\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * _Read only_. Calculated automatically when vertices are set.\n     * \n     * An array of unique axis vectors (edge normals) used for collision detection.\n     * These are automatically calculated when vertices are set.\n     * They are constantly updated by `Body.update` during the simulation.\n     *\n     * @readOnly\n     * @property axes\n     * @type vector[]\n     */\n     \n    /**\n     * _Read only_. Calculated automatically when vertices are set.\n     * \n     * A `Number` that measures the area of the body's convex hull.\n     * \n     * @readOnly\n     * @property area\n     * @type string\n     * @default \n     */\n\n    /**\n     * A `Bounds` object that defines the AABB region for the body.\n     * It is automatically calculated when vertices are set and constantly updated by `Body.update` during simulation.\n     * \n     * @property bounds\n     * @type bounds\n     */\n\n})();\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_99052__) {\n\n/**\n* The `Matter.Events` module contains methods to fire and listen to events on other objects.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Events\n*/\n\nvar Events = {};\n\nmodule.exports = Events;\n\nvar Common = __nested_webpack_require_99052__(0);\n\n(function() {\n\n    /**\n     * Subscribes a callback function to the given object's `eventName`.\n     * @method on\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.on = function(object, eventNames, callback) {\n        var names = eventNames.split(' '),\n            name;\n\n        for (var i = 0; i < names.length; i++) {\n            name = names[i];\n            object.events = object.events || {};\n            object.events[name] = object.events[name] || [];\n            object.events[name].push(callback);\n        }\n\n        return callback;\n    };\n\n    /**\n     * Removes the given event callback. If no callback, clears all callbacks in `eventNames`. If no `eventNames`, clears all events.\n     * @method off\n     * @param {} object\n     * @param {string} eventNames\n     * @param {function} callback\n     */\n    Events.off = function(object, eventNames, callback) {\n        if (!eventNames) {\n            object.events = {};\n            return;\n        }\n\n        // handle Events.off(object, callback)\n        if (typeof eventNames === 'function') {\n            callback = eventNames;\n            eventNames = Common.keys(object.events).join(' ');\n        }\n\n        var names = eventNames.split(' ');\n\n        for (var i = 0; i < names.length; i++) {\n            var callbacks = object.events[names[i]],\n                newCallbacks = [];\n\n            if (callback && callbacks) {\n                for (var j = 0; j < callbacks.length; j++) {\n                    if (callbacks[j] !== callback)\n                        newCallbacks.push(callbacks[j]);\n                }\n            }\n\n            object.events[names[i]] = newCallbacks;\n        }\n    };\n\n    /**\n     * Fires all the callbacks subscribed to the given object's `eventName`, in the order they subscribed, if any.\n     * @method trigger\n     * @param {} object\n     * @param {string} eventNames\n     * @param {} event\n     */\n    Events.trigger = function(object, eventNames, event) {\n        var names,\n            name,\n            callbacks,\n            eventClone;\n\n        var events = object.events;\n        \n        if (events && Common.keys(events).length > 0) {\n            if (!event)\n                event = {};\n\n            names = eventNames.split(' ');\n\n            for (var i = 0; i < names.length; i++) {\n                name = names[i];\n                callbacks = events[name];\n\n                if (callbacks) {\n                    eventClone = Common.clone(event, false);\n                    eventClone.name = name;\n                    eventClone.source = object;\n\n                    for (var j = 0; j < callbacks.length; j++) {\n                        callbacks[j].apply(object, [eventClone]);\n                    }\n                }\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_102250__) {\n\n/**\n* A composite is a collection of `Matter.Body`, `Matter.Constraint` and other `Matter.Composite` objects.\n*\n* They are a container that can represent complex objects made of multiple parts, even if they are not physically connected.\n* A composite could contain anything from a single body all the way up to a whole world.\n* \n* When making any changes to composites, use the included functions rather than changing their properties directly.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composite\n*/\n\nvar Composite = {};\n\nmodule.exports = Composite;\n\nvar Events = __nested_webpack_require_102250__(5);\nvar Common = __nested_webpack_require_102250__(0);\nvar Bounds = __nested_webpack_require_102250__(1);\nvar Body = __nested_webpack_require_102250__(4);\n\n(function() {\n\n    /**\n     * Creates a new composite. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properites section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} [options]\n     * @return {composite} A new composite\n     */\n    Composite.create = function(options) {\n        return Common.extend({ \n            id: Common.nextId(),\n            type: 'composite',\n            parent: null,\n            isModified: false,\n            bodies: [], \n            constraints: [], \n            composites: [],\n            label: 'Composite',\n            plugin: {},\n            cache: {\n                allBodies: null,\n                allConstraints: null,\n                allComposites: null\n            }\n        }, options);\n    };\n\n    /**\n     * Sets the composite's `isModified` flag. \n     * If `updateParents` is true, all parents will be set (default: false).\n     * If `updateChildren` is true, all children will be set (default: false).\n     * @private\n     * @method setModified\n     * @param {composite} composite\n     * @param {boolean} isModified\n     * @param {boolean} [updateParents=false]\n     * @param {boolean} [updateChildren=false]\n     */\n    Composite.setModified = function(composite, isModified, updateParents, updateChildren) {\n        composite.isModified = isModified;\n\n        if (isModified && composite.cache) {\n            composite.cache.allBodies = null;\n            composite.cache.allConstraints = null;\n            composite.cache.allComposites = null;\n        }\n\n        if (updateParents && composite.parent) {\n            Composite.setModified(composite.parent, isModified, updateParents, updateChildren);\n        }\n\n        if (updateChildren) {\n            for (var i = 0; i < composite.composites.length; i++) {\n                var childComposite = composite.composites[i];\n                Composite.setModified(childComposite, isModified, updateParents, updateChildren);\n            }\n        }\n    };\n\n    /**\n     * Generic single or multi-add function. Adds a single or an array of body(s), constraint(s) or composite(s) to the given composite.\n     * Triggers `beforeAdd` and `afterAdd` events on the `composite`.\n     * @method add\n     * @param {composite} composite\n     * @param {object|array} object A single or an array of body(s), constraint(s) or composite(s)\n     * @return {composite} The original composite with the objects added\n     */\n    Composite.add = function(composite, object) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeAdd', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                // skip adding compound parts\n                if (obj.parent !== obj) {\n                    Common.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)');\n                    break;\n                }\n\n                Composite.addBody(composite, obj);\n                break;\n            case 'constraint':\n                Composite.addConstraint(composite, obj);\n                break;\n            case 'composite':\n                Composite.addComposite(composite, obj);\n                break;\n            case 'mouseConstraint':\n                Composite.addConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterAdd', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Generic remove function. Removes one or many body(s), constraint(s) or a composite(s) to the given composite.\n     * Optionally searching its children recursively.\n     * Triggers `beforeRemove` and `afterRemove` events on the `composite`.\n     * @method remove\n     * @param {composite} composite\n     * @param {object|array} object\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the objects removed\n     */\n    Composite.remove = function(composite, object, deep) {\n        var objects = [].concat(object);\n\n        Events.trigger(composite, 'beforeRemove', { object: object });\n\n        for (var i = 0; i < objects.length; i++) {\n            var obj = objects[i];\n\n            switch (obj.type) {\n\n            case 'body':\n                Composite.removeBody(composite, obj, deep);\n                break;\n            case 'constraint':\n                Composite.removeConstraint(composite, obj, deep);\n                break;\n            case 'composite':\n                Composite.removeComposite(composite, obj, deep);\n                break;\n            case 'mouseConstraint':\n                Composite.removeConstraint(composite, obj.constraint);\n                break;\n\n            }\n        }\n\n        Events.trigger(composite, 'afterRemove', { object: object });\n\n        return composite;\n    };\n\n    /**\n     * Adds a composite to the given composite.\n     * @private\n     * @method addComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @return {composite} The original compositeA with the objects from compositeB added\n     */\n    Composite.addComposite = function(compositeA, compositeB) {\n        compositeA.composites.push(compositeB);\n        compositeB.parent = compositeA;\n        Composite.setModified(compositeA, true, true, false);\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeComposite\n     * @param {composite} compositeA\n     * @param {composite} compositeB\n     * @param {boolean} [deep=false]\n     * @return {composite} The original compositeA with the composite removed\n     */\n    Composite.removeComposite = function(compositeA, compositeB, deep) {\n        var position = Common.indexOf(compositeA.composites, compositeB);\n        if (position !== -1) {\n            Composite.removeCompositeAt(compositeA, position);\n        }\n\n        if (deep) {\n            for (var i = 0; i < compositeA.composites.length; i++){\n                Composite.removeComposite(compositeA.composites[i], compositeB, true);\n            }\n        }\n\n        return compositeA;\n    };\n\n    /**\n     * Removes a composite from the given composite.\n     * @private\n     * @method removeCompositeAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the composite removed\n     */\n    Composite.removeCompositeAt = function(composite, position) {\n        composite.composites.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a body to the given composite.\n     * @private\n     * @method addBody\n     * @param {composite} composite\n     * @param {body} body\n     * @return {composite} The original composite with the body added\n     */\n    Composite.addBody = function(composite, body) {\n        composite.bodies.push(body);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeBody\n     * @param {composite} composite\n     * @param {body} body\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBody = function(composite, body, deep) {\n        var position = Common.indexOf(composite.bodies, body);\n        if (position !== -1) {\n            Composite.removeBodyAt(composite, position);\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeBody(composite.composites[i], body, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeBodyAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the body removed\n     */\n    Composite.removeBodyAt = function(composite, position) {\n        composite.bodies.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Adds a constraint to the given composite.\n     * @private\n     * @method addConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @return {composite} The original composite with the constraint added\n     */\n    Composite.addConstraint = function(composite, constraint) {\n        composite.constraints.push(constraint);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes a constraint from the given composite, and optionally searching its children recursively.\n     * @private\n     * @method removeConstraint\n     * @param {composite} composite\n     * @param {constraint} constraint\n     * @param {boolean} [deep=false]\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraint = function(composite, constraint, deep) {\n        var position = Common.indexOf(composite.constraints, constraint);\n        if (position !== -1) {\n            Composite.removeConstraintAt(composite, position);\n        }\n\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.removeConstraint(composite.composites[i], constraint, true);\n            }\n        }\n\n        return composite;\n    };\n\n    /**\n     * Removes a body from the given composite.\n     * @private\n     * @method removeConstraintAt\n     * @param {composite} composite\n     * @param {number} position\n     * @return {composite} The original composite with the constraint removed\n     */\n    Composite.removeConstraintAt = function(composite, position) {\n        composite.constraints.splice(position, 1);\n        Composite.setModified(composite, true, true, false);\n        return composite;\n    };\n\n    /**\n     * Removes all bodies, constraints and composites from the given composite.\n     * Optionally clearing its children recursively.\n     * @method clear\n     * @param {composite} composite\n     * @param {boolean} keepStatic\n     * @param {boolean} [deep=false]\n     */\n    Composite.clear = function(composite, keepStatic, deep) {\n        if (deep) {\n            for (var i = 0; i < composite.composites.length; i++){\n                Composite.clear(composite.composites[i], keepStatic, true);\n            }\n        }\n        \n        if (keepStatic) {\n            composite.bodies = composite.bodies.filter(function(body) { return body.isStatic; });\n        } else {\n            composite.bodies.length = 0;\n        }\n\n        composite.constraints.length = 0;\n        composite.composites.length = 0;\n\n        Composite.setModified(composite, true, true, false);\n\n        return composite;\n    };\n\n    /**\n     * Returns all bodies in the given composite, including all bodies in its children, recursively.\n     * @method allBodies\n     * @param {composite} composite\n     * @return {body[]} All the bodies\n     */\n    Composite.allBodies = function(composite) {\n        if (composite.cache && composite.cache.allBodies) {\n            return composite.cache.allBodies;\n        }\n\n        var bodies = [].concat(composite.bodies);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            bodies = bodies.concat(Composite.allBodies(composite.composites[i]));\n\n        if (composite.cache) {\n            composite.cache.allBodies = bodies;\n        }\n\n        return bodies;\n    };\n\n    /**\n     * Returns all constraints in the given composite, including all constraints in its children, recursively.\n     * @method allConstraints\n     * @param {composite} composite\n     * @return {constraint[]} All the constraints\n     */\n    Composite.allConstraints = function(composite) {\n        if (composite.cache && composite.cache.allConstraints) {\n            return composite.cache.allConstraints;\n        }\n\n        var constraints = [].concat(composite.constraints);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            constraints = constraints.concat(Composite.allConstraints(composite.composites[i]));\n\n        if (composite.cache) {\n            composite.cache.allConstraints = constraints;\n        }\n\n        return constraints;\n    };\n\n    /**\n     * Returns all composites in the given composite, including all composites in its children, recursively.\n     * @method allComposites\n     * @param {composite} composite\n     * @return {composite[]} All the composites\n     */\n    Composite.allComposites = function(composite) {\n        if (composite.cache && composite.cache.allComposites) {\n            return composite.cache.allComposites;\n        }\n\n        var composites = [].concat(composite.composites);\n\n        for (var i = 0; i < composite.composites.length; i++)\n            composites = composites.concat(Composite.allComposites(composite.composites[i]));\n\n        if (composite.cache) {\n            composite.cache.allComposites = composites;\n        }\n\n        return composites;\n    };\n\n    /**\n     * Searches the composite recursively for an object matching the type and id supplied, null if not found.\n     * @method get\n     * @param {composite} composite\n     * @param {number} id\n     * @param {string} type\n     * @return {object} The requested object, if found\n     */\n    Composite.get = function(composite, id, type) {\n        var objects,\n            object;\n\n        switch (type) {\n        case 'body':\n            objects = Composite.allBodies(composite);\n            break;\n        case 'constraint':\n            objects = Composite.allConstraints(composite);\n            break;\n        case 'composite':\n            objects = Composite.allComposites(composite).concat(composite);\n            break;\n        }\n\n        if (!objects)\n            return null;\n\n        object = objects.filter(function(object) { \n            return object.id.toString() === id.toString(); \n        });\n\n        return object.length === 0 ? null : object[0];\n    };\n\n    /**\n     * Moves the given object(s) from compositeA to compositeB (equal to a remove followed by an add).\n     * @method move\n     * @param {compositeA} compositeA\n     * @param {object[]} objects\n     * @param {compositeB} compositeB\n     * @return {composite} Returns compositeA\n     */\n    Composite.move = function(compositeA, objects, compositeB) {\n        Composite.remove(compositeA, objects);\n        Composite.add(compositeB, objects);\n        return compositeA;\n    };\n\n    /**\n     * Assigns new ids for all objects in the composite, recursively.\n     * @method rebase\n     * @param {composite} composite\n     * @return {composite} Returns composite\n     */\n    Composite.rebase = function(composite) {\n        var objects = Composite.allBodies(composite)\n            .concat(Composite.allConstraints(composite))\n            .concat(Composite.allComposites(composite));\n\n        for (var i = 0; i < objects.length; i++) {\n            objects[i].id = Common.nextId();\n        }\n\n        return composite;\n    };\n\n    /**\n     * Translates all children in the composite by a given vector relative to their current positions, \n     * without imparting any velocity.\n     * @method translate\n     * @param {composite} composite\n     * @param {vector} translation\n     * @param {bool} [recursive=true]\n     */\n    Composite.translate = function(composite, translation, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            Body.translate(bodies[i], translation);\n        }\n\n        return composite;\n    };\n\n    /**\n     * Rotates all children in the composite by a given angle about the given point, without imparting any angular velocity.\n     * @method rotate\n     * @param {composite} composite\n     * @param {number} rotation\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.rotate = function(composite, rotation, point, recursive) {\n        var cos = Math.cos(rotation),\n            sin = Math.sin(rotation),\n            bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + (dx * cos - dy * sin),\n                y: point.y + (dx * sin + dy * cos)\n            });\n\n            Body.rotate(body, rotation);\n        }\n\n        return composite;\n    };\n\n    /**\n     * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.\n     * @method scale\n     * @param {composite} composite\n     * @param {number} scaleX\n     * @param {number} scaleY\n     * @param {vector} point\n     * @param {bool} [recursive=true]\n     */\n    Composite.scale = function(composite, scaleX, scaleY, point, recursive) {\n        var bodies = recursive ? Composite.allBodies(composite) : composite.bodies;\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                dx = body.position.x - point.x,\n                dy = body.position.y - point.y;\n                \n            Body.setPosition(body, {\n                x: point.x + dx * scaleX,\n                y: point.y + dy * scaleY\n            });\n\n            Body.scale(body, scaleX, scaleY);\n        }\n\n        return composite;\n    };\n\n    /**\n     * Returns the union of the bounds of all of the composite's bodies.\n     * @method bounds\n     * @param {composite} composite The composite.\n     * @returns {bounds} The composite bounds.\n     */\n    Composite.bounds = function(composite) {\n        var bodies = Composite.allBodies(composite),\n            vertices = [];\n\n        for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i];\n            vertices.push(body.bounds.min, body.bounds.max);\n        }\n\n        return Bounds.create(vertices);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, before objects have been added.\n    *\n    * @event beforeAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.add` is made, after objects have been added.\n    *\n    * @event afterAdd\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been added (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, before objects have been removed.\n    *\n    * @event beforeRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) to be removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when a call to `Composite.remove` is made, after objects have been removed.\n    *\n    * @event afterRemove\n    * @param {} event An event object\n    * @param {} event.object The object(s) that have been removed (may be a single body, constraint, composite or a mixed array of these)\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"composite\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage composites.\n     *\n     * @property label\n     * @type string\n     * @default \"Composite\"\n     */\n\n    /**\n     * A flag that specifies whether the composite has been modified during the current step.\n     * This is automatically managed when bodies, constraints or composites are added or removed.\n     *\n     * @property isModified\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * The `Composite` that is the parent of this composite. It is automatically managed by the `Matter.Composite` methods.\n     *\n     * @property parent\n     * @type composite\n     * @default null\n     */\n\n    /**\n     * An array of `Body` that are _direct_ children of this composite.\n     * To add or remove bodies you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allBodies` method.\n     *\n     * @property bodies\n     * @type body[]\n     * @default []\n     */\n\n    /**\n     * An array of `Constraint` that are _direct_ children of this composite.\n     * To add or remove constraints you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allConstraints` method.\n     *\n     * @property constraints\n     * @type constraint[]\n     * @default []\n     */\n\n    /**\n     * An array of `Composite` that are _direct_ children of this composite.\n     * To add or remove composites you should use `Composite.add` and `Composite.remove` methods rather than directly modifying this property.\n     * If you wish to recursively find all descendants, you should use the `Composite.allComposites` method.\n     *\n     * @property composites\n     * @type composite[]\n     * @default []\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * An object used for storing cached results for performance reasons.\n     * This is used internally only and is automatically managed.\n     *\n     * @private\n     * @property cache\n     * @type {}\n     */\n\n})();\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_125937__) {\n\n/**\n* The `Matter.Sleeping` module contains methods to manage the sleeping state of bodies.\n*\n* @class Sleeping\n*/\n\nvar Sleeping = {};\n\nmodule.exports = Sleeping;\n\nvar Body = __nested_webpack_require_125937__(4);\nvar Events = __nested_webpack_require_125937__(5);\nvar Common = __nested_webpack_require_125937__(0);\n\n(function() {\n\n    Sleeping._motionWakeThreshold = 0.18;\n    Sleeping._motionSleepThreshold = 0.08;\n    Sleeping._minBias = 0.9;\n\n    /**\n     * Puts bodies to sleep or wakes them up depending on their motion.\n     * @method update\n     * @param {body[]} bodies\n     * @param {number} delta\n     */\n    Sleeping.update = function(bodies, delta) {\n        var timeScale = delta / Common._baseDelta,\n            motionSleepThreshold = Sleeping._motionSleepThreshold;\n        \n        // update bodies sleeping status\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                speed = Body.getSpeed(body),\n                angularSpeed = Body.getAngularSpeed(body),\n                motion = speed * speed + angularSpeed * angularSpeed;\n\n            // wake up bodies if they have a force applied\n            if (body.force.x !== 0 || body.force.y !== 0) {\n                Sleeping.set(body, false);\n                continue;\n            }\n\n            var minMotion = Math.min(body.motion, motion),\n                maxMotion = Math.max(body.motion, motion);\n        \n            // biased average motion estimation between frames\n            body.motion = Sleeping._minBias * minMotion + (1 - Sleeping._minBias) * maxMotion;\n\n            if (body.sleepThreshold > 0 && body.motion < motionSleepThreshold) {\n                body.sleepCounter += 1;\n                \n                if (body.sleepCounter >= body.sleepThreshold / timeScale) {\n                    Sleeping.set(body, true);\n                }\n            } else if (body.sleepCounter > 0) {\n                body.sleepCounter -= 1;\n            }\n        }\n    };\n\n    /**\n     * Given a set of colliding pairs, wakes the sleeping bodies involved.\n     * @method afterCollisions\n     * @param {pair[]} pairs\n     */\n    Sleeping.afterCollisions = function(pairs) {\n        var motionSleepThreshold = Sleeping._motionSleepThreshold;\n\n        // wake up bodies involved in collisions\n        for (var i = 0; i < pairs.length; i++) {\n            var pair = pairs[i];\n            \n            // don't wake inactive pairs\n            if (!pair.isActive)\n                continue;\n\n            var collision = pair.collision,\n                bodyA = collision.bodyA.parent, \n                bodyB = collision.bodyB.parent;\n        \n            // don't wake if at least one body is static\n            if ((bodyA.isSleeping && bodyB.isSleeping) || bodyA.isStatic || bodyB.isStatic)\n                continue;\n        \n            if (bodyA.isSleeping || bodyB.isSleeping) {\n                var sleepingBody = (bodyA.isSleeping && !bodyA.isStatic) ? bodyA : bodyB,\n                    movingBody = sleepingBody === bodyA ? bodyB : bodyA;\n\n                if (!sleepingBody.isStatic && movingBody.motion > motionSleepThreshold) {\n                    Sleeping.set(sleepingBody, false);\n                }\n            }\n        }\n    };\n  \n    /**\n     * Set a body as sleeping or awake.\n     * @method set\n     * @param {body} body\n     * @param {boolean} isSleeping\n     */\n    Sleeping.set = function(body, isSleeping) {\n        var wasSleeping = body.isSleeping;\n\n        if (isSleeping) {\n            body.isSleeping = true;\n            body.sleepCounter = body.sleepThreshold;\n\n            body.positionImpulse.x = 0;\n            body.positionImpulse.y = 0;\n\n            body.positionPrev.x = body.position.x;\n            body.positionPrev.y = body.position.y;\n\n            body.anglePrev = body.angle;\n            body.speed = 0;\n            body.angularSpeed = 0;\n            body.motion = 0;\n\n            if (!wasSleeping) {\n                Events.trigger(body, 'sleepStart');\n            }\n        } else {\n            body.isSleeping = false;\n            body.sleepCounter = 0;\n\n            if (wasSleeping) {\n                Events.trigger(body, 'sleepEnd');\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_130181__) {\n\n/**\n* The `Matter.Collision` module contains methods for detecting collisions between a given pair of bodies.\n*\n* For efficient detection between a list of bodies, see `Matter.Detector` and `Matter.Query`.\n*\n* See `Matter.Engine` for collision events.\n*\n* @class Collision\n*/\n\nvar Collision = {};\n\nmodule.exports = Collision;\n\nvar Vertices = __nested_webpack_require_130181__(3);\nvar Pair = __nested_webpack_require_130181__(9);\n\n(function() {\n    var _supports = [];\n\n    var _overlapAB = {\n        overlap: 0,\n        axis: null\n    };\n\n    var _overlapBA = {\n        overlap: 0,\n        axis: null\n    };\n\n    /**\n     * Creates a new collision record.\n     * @method create\n     * @param {body} bodyA The first body part represented by the collision record\n     * @param {body} bodyB The second body part represented by the collision record\n     * @return {collision} A new collision record\n     */\n    Collision.create = function(bodyA, bodyB) {\n        return { \n            pair: null,\n            collided: false,\n            bodyA: bodyA,\n            bodyB: bodyB,\n            parentA: bodyA.parent,\n            parentB: bodyB.parent,\n            depth: 0,\n            normal: { x: 0, y: 0 },\n            tangent: { x: 0, y: 0 },\n            penetration: { x: 0, y: 0 },\n            supports: []\n        };\n    };\n\n    /**\n     * Detect collision between two bodies.\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {pairs} [pairs] Optionally reuse collision records from existing pairs.\n     * @return {collision|null} A collision record if detected, otherwise null\n     */\n    Collision.collides = function(bodyA, bodyB, pairs) {\n        Collision._overlapAxes(_overlapAB, bodyA.vertices, bodyB.vertices, bodyA.axes);\n\n        if (_overlapAB.overlap <= 0) {\n            return null;\n        }\n\n        Collision._overlapAxes(_overlapBA, bodyB.vertices, bodyA.vertices, bodyB.axes);\n\n        if (_overlapBA.overlap <= 0) {\n            return null;\n        }\n\n        // reuse collision records for gc efficiency\n        var pair = pairs && pairs.table[Pair.id(bodyA, bodyB)],\n            collision;\n\n        if (!pair) {\n            collision = Collision.create(bodyA, bodyB);\n            collision.collided = true;\n            collision.bodyA = bodyA.id < bodyB.id ? bodyA : bodyB;\n            collision.bodyB = bodyA.id < bodyB.id ? bodyB : bodyA;\n            collision.parentA = collision.bodyA.parent;\n            collision.parentB = collision.bodyB.parent;\n        } else {\n            collision = pair.collision;\n        }\n\n        bodyA = collision.bodyA;\n        bodyB = collision.bodyB;\n\n        var minOverlap;\n\n        if (_overlapAB.overlap < _overlapBA.overlap) {\n            minOverlap = _overlapAB;\n        } else {\n            minOverlap = _overlapBA;\n        }\n\n        var normal = collision.normal,\n            supports = collision.supports,\n            minAxis = minOverlap.axis,\n            minAxisX = minAxis.x,\n            minAxisY = minAxis.y;\n\n        // ensure normal is facing away from bodyA\n        if (minAxisX * (bodyB.position.x - bodyA.position.x) + minAxisY * (bodyB.position.y - bodyA.position.y) < 0) {\n            normal.x = minAxisX;\n            normal.y = minAxisY;\n        } else {\n            normal.x = -minAxisX;\n            normal.y = -minAxisY;\n        }\n        \n        collision.tangent.x = -normal.y;\n        collision.tangent.y = normal.x;\n\n        collision.depth = minOverlap.overlap;\n\n        collision.penetration.x = normal.x * collision.depth;\n        collision.penetration.y = normal.y * collision.depth;\n\n        // find support points, there is always either exactly one or two\n        var supportsB = Collision._findSupports(bodyA, bodyB, normal, 1),\n            supportCount = 0;\n\n        // find the supports from bodyB that are inside bodyA\n        if (Vertices.contains(bodyA.vertices, supportsB[0])) {\n            supports[supportCount++] = supportsB[0];\n        }\n\n        if (Vertices.contains(bodyA.vertices, supportsB[1])) {\n            supports[supportCount++] = supportsB[1];\n        }\n\n        // find the supports from bodyA that are inside bodyB\n        if (supportCount < 2) {\n            var supportsA = Collision._findSupports(bodyB, bodyA, normal, -1);\n\n            if (Vertices.contains(bodyB.vertices, supportsA[0])) {\n                supports[supportCount++] = supportsA[0];\n            }\n\n            if (supportCount < 2 && Vertices.contains(bodyB.vertices, supportsA[1])) {\n                supports[supportCount++] = supportsA[1];\n            }\n        }\n\n        // account for the edge case of overlapping but no vertex containment\n        if (supportCount === 0) {\n            supports[supportCount++] = supportsB[0];\n        }\n\n        // update supports array size\n        supports.length = supportCount;\n\n        return collision;\n    };\n\n    /**\n     * Find the overlap between two sets of vertices.\n     * @method _overlapAxes\n     * @private\n     * @param {object} result\n     * @param {vertices} verticesA\n     * @param {vertices} verticesB\n     * @param {axes} axes\n     */\n    Collision._overlapAxes = function(result, verticesA, verticesB, axes) {\n        var verticesALength = verticesA.length,\n            verticesBLength = verticesB.length,\n            verticesAX = verticesA[0].x,\n            verticesAY = verticesA[0].y,\n            verticesBX = verticesB[0].x,\n            verticesBY = verticesB[0].y,\n            axesLength = axes.length,\n            overlapMin = Number.MAX_VALUE,\n            overlapAxisNumber = 0,\n            overlap,\n            overlapAB,\n            overlapBA,\n            dot,\n            i,\n            j;\n\n        for (i = 0; i < axesLength; i++) {\n            var axis = axes[i],\n                axisX = axis.x,\n                axisY = axis.y,\n                minA = verticesAX * axisX + verticesAY * axisY,\n                minB = verticesBX * axisX + verticesBY * axisY,\n                maxA = minA,\n                maxB = minB;\n            \n            for (j = 1; j < verticesALength; j += 1) {\n                dot = verticesA[j].x * axisX + verticesA[j].y * axisY;\n\n                if (dot > maxA) { \n                    maxA = dot;\n                } else if (dot < minA) { \n                    minA = dot;\n                }\n            }\n\n            for (j = 1; j < verticesBLength; j += 1) {\n                dot = verticesB[j].x * axisX + verticesB[j].y * axisY;\n\n                if (dot > maxB) { \n                    maxB = dot;\n                } else if (dot < minB) { \n                    minB = dot;\n                }\n            }\n\n            overlapAB = maxA - minB;\n            overlapBA = maxB - minA;\n            overlap = overlapAB < overlapBA ? overlapAB : overlapBA;\n\n            if (overlap < overlapMin) {\n                overlapMin = overlap;\n                overlapAxisNumber = i;\n\n                if (overlap <= 0) {\n                    // can not be intersecting\n                    break;\n                }\n            } \n        }\n\n        result.axis = axes[overlapAxisNumber];\n        result.overlap = overlapMin;\n    };\n\n    /**\n     * Projects vertices on an axis and returns an interval.\n     * @method _projectToAxis\n     * @private\n     * @param {} projection\n     * @param {} vertices\n     * @param {} axis\n     */\n    Collision._projectToAxis = function(projection, vertices, axis) {\n        var min = vertices[0].x * axis.x + vertices[0].y * axis.y,\n            max = min;\n\n        for (var i = 1; i < vertices.length; i += 1) {\n            var dot = vertices[i].x * axis.x + vertices[i].y * axis.y;\n\n            if (dot > max) { \n                max = dot; \n            } else if (dot < min) { \n                min = dot; \n            }\n        }\n\n        projection.min = min;\n        projection.max = max;\n    };\n\n    /**\n     * Finds supporting vertices given two bodies along a given direction using hill-climbing.\n     * @method _findSupports\n     * @private\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @param {vector} normal\n     * @param {number} direction\n     * @return [vector]\n     */\n    Collision._findSupports = function(bodyA, bodyB, normal, direction) {\n        var vertices = bodyB.vertices,\n            verticesLength = vertices.length,\n            bodyAPositionX = bodyA.position.x,\n            bodyAPositionY = bodyA.position.y,\n            normalX = normal.x * direction,\n            normalY = normal.y * direction,\n            nearestDistance = Number.MAX_VALUE,\n            vertexA,\n            vertexB,\n            vertexC,\n            distance,\n            j;\n\n        // find deepest vertex relative to the axis\n        for (j = 0; j < verticesLength; j += 1) {\n            vertexB = vertices[j];\n            distance = normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y);\n\n            // convex hill-climbing\n            if (distance < nearestDistance) {\n                nearestDistance = distance;\n                vertexA = vertexB;\n            }\n        }\n\n        // measure next vertex\n        vertexC = vertices[(verticesLength + vertexA.index - 1) % verticesLength];\n        nearestDistance = normalX * (bodyAPositionX - vertexC.x) + normalY * (bodyAPositionY - vertexC.y);\n\n        // compare with previous vertex\n        vertexB = vertices[(vertexA.index + 1) % verticesLength];\n        if (normalX * (bodyAPositionX - vertexB.x) + normalY * (bodyAPositionY - vertexB.y) < nearestDistance) {\n            _supports[0] = vertexA;\n            _supports[1] = vertexB;\n\n            return _supports;\n        }\n\n        _supports[0] = vertexA;\n        _supports[1] = vertexC;\n\n        return _supports;\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A reference to the pair using this collision record, if there is one.\n     *\n     * @property pair\n     * @type {pair|null}\n     * @default null\n     */\n\n    /**\n     * A flag that indicates if the bodies were colliding when the collision was last updated.\n     * \n     * @property collided\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * The first body part represented by the collision (see also `collision.parentA`).\n     * \n     * @property bodyA\n     * @type body\n     */\n\n    /**\n     * The second body part represented by the collision (see also `collision.parentB`).\n     * \n     * @property bodyB\n     * @type body\n     */\n\n    /**\n     * The first body represented by the collision (i.e. `collision.bodyA.parent`).\n     * \n     * @property parentA\n     * @type body\n     */\n\n    /**\n     * The second body represented by the collision (i.e. `collision.bodyB.parent`).\n     * \n     * @property parentB\n     * @type body\n     */\n\n    /**\n     * A `Number` that represents the minimum separating distance between the bodies along the collision normal.\n     *\n     * @readOnly\n     * @property depth\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A normalised `Vector` that represents the direction between the bodies that provides the minimum separating distance.\n     *\n     * @property normal\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A normalised `Vector` that is the tangent direction to the collision normal.\n     *\n     * @property tangent\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that represents the direction and depth of the collision.\n     *\n     * @property penetration\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * An array of body vertices that represent the support points in the collision.\n     * These are the deepest vertices (along the collision normal) of each body that are contained by the other body's vertices.\n     *\n     * @property supports\n     * @type vector[]\n     * @default []\n     */\n\n})();\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __nested_webpack_require_142084__) {\n\n/**\n* The `Matter.Pair` module contains methods for creating and manipulating collision pairs.\n*\n* @class Pair\n*/\n\nvar Pair = {};\n\nmodule.exports = Pair;\n\nvar Contact = __nested_webpack_require_142084__(16);\n\n(function() {\n    \n    /**\n     * Creates a pair.\n     * @method create\n     * @param {collision} collision\n     * @param {number} timestamp\n     * @return {pair} A new pair\n     */\n    Pair.create = function(collision, timestamp) {\n        var bodyA = collision.bodyA,\n            bodyB = collision.bodyB;\n\n        var pair = {\n            id: Pair.id(bodyA, bodyB),\n            bodyA: bodyA,\n            bodyB: bodyB,\n            collision: collision,\n            contacts: [],\n            activeContacts: [],\n            separation: 0,\n            isActive: true,\n            confirmedActive: true,\n            isSensor: bodyA.isSensor || bodyB.isSensor,\n            timeCreated: timestamp,\n            timeUpdated: timestamp,\n            inverseMass: 0,\n            friction: 0,\n            frictionStatic: 0,\n            restitution: 0,\n            slop: 0\n        };\n\n        Pair.update(pair, collision, timestamp);\n\n        return pair;\n    };\n\n    /**\n     * Updates a pair given a collision.\n     * @method update\n     * @param {pair} pair\n     * @param {collision} collision\n     * @param {number} timestamp\n     */\n    Pair.update = function(pair, collision, timestamp) {\n        var contacts = pair.contacts,\n            supports = collision.supports,\n            activeContacts = pair.activeContacts,\n            parentA = collision.parentA,\n            parentB = collision.parentB,\n            parentAVerticesLength = parentA.vertices.length;\n        \n        pair.isActive = true;\n        pair.timeUpdated = timestamp;\n        pair.collision = collision;\n        pair.separation = collision.depth;\n        pair.inverseMass = parentA.inverseMass + parentB.inverseMass;\n        pair.friction = parentA.friction < parentB.friction ? parentA.friction : parentB.friction;\n        pair.frictionStatic = parentA.frictionStatic > parentB.frictionStatic ? parentA.frictionStatic : parentB.frictionStatic;\n        pair.restitution = parentA.restitution > parentB.restitution ? parentA.restitution : parentB.restitution;\n        pair.slop = parentA.slop > parentB.slop ? parentA.slop : parentB.slop;\n\n        collision.pair = pair;\n        activeContacts.length = 0;\n        \n        for (var i = 0; i < supports.length; i++) {\n            var support = supports[i],\n                contactId = support.body === parentA ? support.index : parentAVerticesLength + support.index,\n                contact = contacts[contactId];\n\n            if (contact) {\n                activeContacts.push(contact);\n            } else {\n                activeContacts.push(contacts[contactId] = Contact.create(support));\n            }\n        }\n    };\n    \n    /**\n     * Set a pair as active or inactive.\n     * @method setActive\n     * @param {pair} pair\n     * @param {bool} isActive\n     * @param {number} timestamp\n     */\n    Pair.setActive = function(pair, isActive, timestamp) {\n        if (isActive) {\n            pair.isActive = true;\n            pair.timeUpdated = timestamp;\n        } else {\n            pair.isActive = false;\n            pair.activeContacts.length = 0;\n        }\n    };\n\n    /**\n     * Get the id for the given pair.\n     * @method id\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {string} Unique pairId\n     */\n    Pair.id = function(bodyA, bodyB) {\n        if (bodyA.id < bodyB.id) {\n            return 'A' + bodyA.id + 'B' + bodyB.id;\n        } else {\n            return 'A' + bodyB.id + 'B' + bodyA.id;\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __nested_webpack_require_145828__) {\n\n/**\n* The `Matter.Constraint` module contains methods for creating and manipulating constraints.\n* Constraints are used for specifying that a fixed distance must be maintained between two bodies (or a body and a fixed world-space position).\n* The stiffness of constraints can be modified to create springs or elastic.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Constraint\n*/\n\nvar Constraint = {};\n\nmodule.exports = Constraint;\n\nvar Vertices = __nested_webpack_require_145828__(3);\nvar Vector = __nested_webpack_require_145828__(2);\nvar Sleeping = __nested_webpack_require_145828__(7);\nvar Bounds = __nested_webpack_require_145828__(1);\nvar Axes = __nested_webpack_require_145828__(11);\nvar Common = __nested_webpack_require_145828__(0);\n\n(function() {\n\n    Constraint._warming = 0.4;\n    Constraint._torqueDampen = 1;\n    Constraint._minLength = 0.000001;\n\n    /**\n     * Creates a new constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * To simulate a revolute constraint (or pin joint) set `length: 0` and a high `stiffness` value (e.g. `0.7` or above).\n     * If the constraint is unstable, try lowering the `stiffness` value and / or increasing `engine.constraintIterations`.\n     * For compound bodies, constraints must be applied to the parent body (not one of its parts).\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {} options\n     * @return {constraint} constraint\n     */\n    Constraint.create = function(options) {\n        var constraint = options;\n\n        // if bodies defined but no points, use body centre\n        if (constraint.bodyA && !constraint.pointA)\n            constraint.pointA = { x: 0, y: 0 };\n        if (constraint.bodyB && !constraint.pointB)\n            constraint.pointB = { x: 0, y: 0 };\n\n        // calculate static length using initial world space points\n        var initialPointA = constraint.bodyA ? Vector.add(constraint.bodyA.position, constraint.pointA) : constraint.pointA,\n            initialPointB = constraint.bodyB ? Vector.add(constraint.bodyB.position, constraint.pointB) : constraint.pointB,\n            length = Vector.magnitude(Vector.sub(initialPointA, initialPointB));\n    \n        constraint.length = typeof constraint.length !== 'undefined' ? constraint.length : length;\n\n        // option defaults\n        constraint.id = constraint.id || Common.nextId();\n        constraint.label = constraint.label || 'Constraint';\n        constraint.type = 'constraint';\n        constraint.stiffness = constraint.stiffness || (constraint.length > 0 ? 1 : 0.7);\n        constraint.damping = constraint.damping || 0;\n        constraint.angularStiffness = constraint.angularStiffness || 0;\n        constraint.angleA = constraint.bodyA ? constraint.bodyA.angle : constraint.angleA;\n        constraint.angleB = constraint.bodyB ? constraint.bodyB.angle : constraint.angleB;\n        constraint.plugin = {};\n\n        // render\n        var render = {\n            visible: true,\n            lineWidth: 2,\n            strokeStyle: '#ffffff',\n            type: 'line',\n            anchors: true\n        };\n\n        if (constraint.length === 0 && constraint.stiffness > 0.1) {\n            render.type = 'pin';\n            render.anchors = false;\n        } else if (constraint.stiffness < 0.9) {\n            render.type = 'spring';\n        }\n\n        constraint.render = Common.extend(render, constraint.render);\n\n        return constraint;\n    };\n\n    /**\n     * Prepares for solving by constraint warming.\n     * @private\n     * @method preSolveAll\n     * @param {body[]} bodies\n     */\n    Constraint.preSolveAll = function(bodies) {\n        for (var i = 0; i < bodies.length; i += 1) {\n            var body = bodies[i],\n                impulse = body.constraintImpulse;\n\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\n                continue;\n            }\n\n            body.position.x += impulse.x;\n            body.position.y += impulse.y;\n            body.angle += impulse.angle;\n        }\n    };\n\n    /**\n     * Solves all constraints in a list of collisions.\n     * @private\n     * @method solveAll\n     * @param {constraint[]} constraints\n     * @param {number} delta\n     */\n    Constraint.solveAll = function(constraints, delta) {\n        var timeScale = Common.clamp(delta / Common._baseDelta, 0, 1);\n\n        // Solve fixed constraints first.\n        for (var i = 0; i < constraints.length; i += 1) {\n            var constraint = constraints[i],\n                fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic),\n                fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\n\n            if (fixedA || fixedB) {\n                Constraint.solve(constraints[i], timeScale);\n            }\n        }\n\n        // Solve free constraints last.\n        for (i = 0; i < constraints.length; i += 1) {\n            constraint = constraints[i];\n            fixedA = !constraint.bodyA || (constraint.bodyA && constraint.bodyA.isStatic);\n            fixedB = !constraint.bodyB || (constraint.bodyB && constraint.bodyB.isStatic);\n\n            if (!fixedA && !fixedB) {\n                Constraint.solve(constraints[i], timeScale);\n            }\n        }\n    };\n\n    /**\n     * Solves a distance constraint with Gauss-Siedel method.\n     * @private\n     * @method solve\n     * @param {constraint} constraint\n     * @param {number} timeScale\n     */\n    Constraint.solve = function(constraint, timeScale) {\n        var bodyA = constraint.bodyA,\n            bodyB = constraint.bodyB,\n            pointA = constraint.pointA,\n            pointB = constraint.pointB;\n\n        if (!bodyA && !bodyB)\n            return;\n\n        // update reference angle\n        if (bodyA && !bodyA.isStatic) {\n            Vector.rotate(pointA, bodyA.angle - constraint.angleA, pointA);\n            constraint.angleA = bodyA.angle;\n        }\n        \n        // update reference angle\n        if (bodyB && !bodyB.isStatic) {\n            Vector.rotate(pointB, bodyB.angle - constraint.angleB, pointB);\n            constraint.angleB = bodyB.angle;\n        }\n\n        var pointAWorld = pointA,\n            pointBWorld = pointB;\n\n        if (bodyA) pointAWorld = Vector.add(bodyA.position, pointA);\n        if (bodyB) pointBWorld = Vector.add(bodyB.position, pointB);\n\n        if (!pointAWorld || !pointBWorld)\n            return;\n\n        var delta = Vector.sub(pointAWorld, pointBWorld),\n            currentLength = Vector.magnitude(delta);\n\n        // prevent singularity\n        if (currentLength < Constraint._minLength) {\n            currentLength = Constraint._minLength;\n        }\n\n        // solve distance constraint with Gauss-Siedel method\n        var difference = (currentLength - constraint.length) / currentLength,\n            isRigid = constraint.stiffness >= 1 || constraint.length === 0,\n            stiffness = isRigid ? constraint.stiffness * timeScale \n                : constraint.stiffness * timeScale * timeScale,\n            damping = constraint.damping * timeScale,\n            force = Vector.mult(delta, difference * stiffness),\n            massTotal = (bodyA ? bodyA.inverseMass : 0) + (bodyB ? bodyB.inverseMass : 0),\n            inertiaTotal = (bodyA ? bodyA.inverseInertia : 0) + (bodyB ? bodyB.inverseInertia : 0),\n            resistanceTotal = massTotal + inertiaTotal,\n            torque,\n            share,\n            normal,\n            normalVelocity,\n            relativeVelocity;\n    \n        if (damping > 0) {\n            var zero = Vector.create();\n            normal = Vector.div(delta, currentLength);\n\n            relativeVelocity = Vector.sub(\n                bodyB && Vector.sub(bodyB.position, bodyB.positionPrev) || zero,\n                bodyA && Vector.sub(bodyA.position, bodyA.positionPrev) || zero\n            );\n\n            normalVelocity = Vector.dot(normal, relativeVelocity);\n        }\n\n        if (bodyA && !bodyA.isStatic) {\n            share = bodyA.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyA.constraintImpulse.x -= force.x * share;\n            bodyA.constraintImpulse.y -= force.y * share;\n\n            // apply forces\n            bodyA.position.x -= force.x * share;\n            bodyA.position.y -= force.y * share;\n\n            // apply damping\n            if (damping > 0) {\n                bodyA.positionPrev.x -= damping * normal.x * normalVelocity * share;\n                bodyA.positionPrev.y -= damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = (Vector.cross(pointA, force) / resistanceTotal) * Constraint._torqueDampen * bodyA.inverseInertia * (1 - constraint.angularStiffness);\n            bodyA.constraintImpulse.angle -= torque;\n            bodyA.angle -= torque;\n        }\n\n        if (bodyB && !bodyB.isStatic) {\n            share = bodyB.inverseMass / massTotal;\n\n            // keep track of applied impulses for post solving\n            bodyB.constraintImpulse.x += force.x * share;\n            bodyB.constraintImpulse.y += force.y * share;\n            \n            // apply forces\n            bodyB.position.x += force.x * share;\n            bodyB.position.y += force.y * share;\n\n            // apply damping\n            if (damping > 0) {\n                bodyB.positionPrev.x += damping * normal.x * normalVelocity * share;\n                bodyB.positionPrev.y += damping * normal.y * normalVelocity * share;\n            }\n\n            // apply torque\n            torque = (Vector.cross(pointB, force) / resistanceTotal) * Constraint._torqueDampen * bodyB.inverseInertia * (1 - constraint.angularStiffness);\n            bodyB.constraintImpulse.angle += torque;\n            bodyB.angle += torque;\n        }\n\n    };\n\n    /**\n     * Performs body updates required after solving constraints.\n     * @private\n     * @method postSolveAll\n     * @param {body[]} bodies\n     */\n    Constraint.postSolveAll = function(bodies) {\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                impulse = body.constraintImpulse;\n\n            if (body.isStatic || (impulse.x === 0 && impulse.y === 0 && impulse.angle === 0)) {\n                continue;\n            }\n\n            Sleeping.set(body, false);\n\n            // update geometry and reset\n            for (var j = 0; j < body.parts.length; j++) {\n                var part = body.parts[j];\n                \n                Vertices.translate(part.vertices, impulse);\n\n                if (j > 0) {\n                    part.position.x += impulse.x;\n                    part.position.y += impulse.y;\n                }\n\n                if (impulse.angle !== 0) {\n                    Vertices.rotate(part.vertices, impulse.angle, body.position);\n                    Axes.rotate(part.axes, impulse.angle);\n                    if (j > 0) {\n                        Vector.rotateAbout(part.position, impulse.angle, body.position, part.position);\n                    }\n                }\n\n                Bounds.update(part.bounds, part.vertices, body.velocity);\n            }\n\n            // dampen the cached impulse for warming next step\n            impulse.angle *= Constraint._warming;\n            impulse.x *= Constraint._warming;\n            impulse.y *= Constraint._warming;\n        }\n    };\n\n    /**\n     * Returns the world-space position of `constraint.pointA`, accounting for `constraint.bodyA`.\n     * @method pointAWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */\n    Constraint.pointAWorld = function(constraint) {\n        return {\n            x: (constraint.bodyA ? constraint.bodyA.position.x : 0) \n                + (constraint.pointA ? constraint.pointA.x : 0),\n            y: (constraint.bodyA ? constraint.bodyA.position.y : 0) \n                + (constraint.pointA ? constraint.pointA.y : 0)\n        };\n    };\n\n    /**\n     * Returns the world-space position of `constraint.pointB`, accounting for `constraint.bodyB`.\n     * @method pointBWorld\n     * @param {constraint} constraint\n     * @returns {vector} the world-space position\n     */\n    Constraint.pointBWorld = function(constraint) {\n        return {\n            x: (constraint.bodyB ? constraint.bodyB.position.x : 0) \n                + (constraint.pointB ? constraint.pointB.x : 0),\n            y: (constraint.bodyB ? constraint.bodyB.position.y : 0) \n                + (constraint.pointB ? constraint.pointB.y : 0)\n        };\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` uniquely identifying number generated in `Composite.create` by `Common.nextId`.\n     *\n     * @property id\n     * @type number\n     */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */\n\n    /**\n     * An arbitrary `String` name to help the user identify and manage bodies.\n     *\n     * @property label\n     * @type string\n     * @default \"Constraint\"\n     */\n\n    /**\n     * An `Object` that defines the rendering properties to be consumed by the module `Matter.Render`.\n     *\n     * @property render\n     * @type object\n     */\n\n    /**\n     * A flag that indicates if the constraint should be rendered.\n     *\n     * @property render.visible\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A `Number` that defines the line width to use when rendering the constraint outline.\n     * A value of `0` means no outline will be rendered.\n     *\n     * @property render.lineWidth\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A `String` that defines the stroke style to use when rendering the constraint outline.\n     * It is the same as when using a canvas, so it accepts CSS style property values.\n     *\n     * @property render.strokeStyle\n     * @type string\n     * @default a random colour\n     */\n\n    /**\n     * A `String` that defines the constraint rendering type. \n     * The possible values are 'line', 'pin', 'spring'.\n     * An appropriate render type will be automatically chosen unless one is given in options.\n     *\n     * @property render.type\n     * @type string\n     * @default 'line'\n     */\n\n    /**\n     * A `Boolean` that defines if the constraint's anchor points should be rendered.\n     *\n     * @property render.anchors\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * The first possible `Body` that this constraint is attached to.\n     *\n     * @property bodyA\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The second possible `Body` that this constraint is attached to.\n     *\n     * @property bodyB\n     * @type body\n     * @default null\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyA` if defined, otherwise a world-space position.\n     *\n     * @property pointA\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Vector` that specifies the offset of the constraint from center of the `constraint.bodyB` if defined, otherwise a world-space position.\n     *\n     * @property pointB\n     * @type vector\n     * @default { x: 0, y: 0 }\n     */\n\n    /**\n     * A `Number` that specifies the stiffness of the constraint, i.e. the rate at which it returns to its resting `constraint.length`.\n     * A value of `1` means the constraint should be very stiff.\n     * A value of `0.2` means the constraint acts like a soft spring.\n     *\n     * @property stiffness\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the damping of the constraint, \n     * i.e. the amount of resistance applied to each body based on their velocities to limit the amount of oscillation.\n     * Damping will only be apparent when the constraint also has a very low `stiffness`.\n     * A value of `0.1` means the constraint will apply heavy damping, resulting in little to no oscillation.\n     * A value of `0` means the constraint will apply no damping.\n     *\n     * @property damping\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that specifies the target resting length of the constraint. \n     * It is calculated automatically in `Constraint.create` from initial positions of the `constraint.bodyA` and `constraint.bodyB`.\n     *\n     * @property length\n     * @type number\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n})();\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __nested_webpack_require_162575__) {\n\n/**\n* The `Matter.Axes` module contains methods for creating and manipulating sets of axes.\n*\n* @class Axes\n*/\n\nvar Axes = {};\n\nmodule.exports = Axes;\n\nvar Vector = __nested_webpack_require_162575__(2);\nvar Common = __nested_webpack_require_162575__(0);\n\n(function() {\n\n    /**\n     * Creates a new set of axes from the given vertices.\n     * @method fromVertices\n     * @param {vertices} vertices\n     * @return {axes} A new axes from the given vertices\n     */\n    Axes.fromVertices = function(vertices) {\n        var axes = {};\n\n        // find the unique axes, using edge normal gradients\n        for (var i = 0; i < vertices.length; i++) {\n            var j = (i + 1) % vertices.length, \n                normal = Vector.normalise({ \n                    x: vertices[j].y - vertices[i].y, \n                    y: vertices[i].x - vertices[j].x\n                }),\n                gradient = (normal.y === 0) ? Infinity : (normal.x / normal.y);\n            \n            // limit precision\n            gradient = gradient.toFixed(3).toString();\n            axes[gradient] = normal;\n        }\n\n        return Common.values(axes);\n    };\n\n    /**\n     * Rotates a set of axes by the given angle.\n     * @method rotate\n     * @param {axes} axes\n     * @param {number} angle\n     */\n    Axes.rotate = function(axes, angle) {\n        if (angle === 0)\n            return;\n        \n        var cos = Math.cos(angle),\n            sin = Math.sin(angle);\n\n        for (var i = 0; i < axes.length; i++) {\n            var axis = axes[i],\n                xx;\n            xx = axis.x * cos - axis.y * sin;\n            axis.y = axis.x * sin + axis.y * cos;\n            axis.x = xx;\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __nested_webpack_require_164316__) {\n\n/**\n* The `Matter.Bodies` module contains factory methods for creating rigid body models \n* with commonly used body configurations (such as rectangles, circles and other polygons).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Bodies\n*/\n\n// TODO: true circle bodies\n\nvar Bodies = {};\n\nmodule.exports = Bodies;\n\nvar Vertices = __nested_webpack_require_164316__(3);\nvar Common = __nested_webpack_require_164316__(0);\nvar Body = __nested_webpack_require_164316__(4);\nvar Bounds = __nested_webpack_require_164316__(1);\nvar Vector = __nested_webpack_require_164316__(2);\n\n(function() {\n\n    /**\n     * Creates a new rigid body model with a rectangle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method rectangle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {object} [options]\n     * @return {body} A new rectangle body\n     */\n    Bodies.rectangle = function(x, y, width, height, options) {\n        options = options || {};\n\n        var rectangle = { \n            label: 'Rectangle Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath('L 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            rectangle.vertices = Vertices.chamfer(rectangle.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, rectangle, options));\n    };\n    \n    /**\n     * Creates a new rigid body model with a trapezoid hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method trapezoid\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} slope\n     * @param {object} [options]\n     * @return {body} A new trapezoid body\n     */\n    Bodies.trapezoid = function(x, y, width, height, slope, options) {\n        options = options || {};\n\n        slope *= 0.5;\n        var roof = (1 - (slope * 2)) * width;\n        \n        var x1 = width * slope,\n            x2 = x1 + roof,\n            x3 = x2 + x1,\n            verticesPath;\n\n        if (slope < 0.5) {\n            verticesPath = 'L 0 0 L ' + x1 + ' ' + (-height) + ' L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\n        } else {\n            verticesPath = 'L 0 0 L ' + x2 + ' ' + (-height) + ' L ' + x3 + ' 0';\n        }\n\n        var trapezoid = { \n            label: 'Trapezoid Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath(verticesPath)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            trapezoid.vertices = Vertices.chamfer(trapezoid.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, trapezoid, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a circle hull. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method circle\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {object} [options]\n     * @param {number} [maxSides]\n     * @return {body} A new circle body\n     */\n    Bodies.circle = function(x, y, radius, options, maxSides) {\n        options = options || {};\n\n        var circle = {\n            label: 'Circle Body',\n            circleRadius: radius\n        };\n        \n        // approximate circles with polygons until true circles implemented in SAT\n        maxSides = maxSides || 25;\n        var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));\n\n        // optimisation: always use even number of sides (half the number of unique axes)\n        if (sides % 2 === 1)\n            sides += 1;\n\n        return Bodies.polygon(x, y, sides, radius, Common.extend({}, circle, options));\n    };\n\n    /**\n     * Creates a new rigid body model with a regular polygon hull with the given number of sides. \n     * The options parameter is an object that specifies any properties you wish to override the defaults.\n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method polygon\n     * @param {number} x\n     * @param {number} y\n     * @param {number} sides\n     * @param {number} radius\n     * @param {object} [options]\n     * @return {body} A new regular polygon body\n     */\n    Bodies.polygon = function(x, y, sides, radius, options) {\n        options = options || {};\n\n        if (sides < 3)\n            return Bodies.circle(x, y, radius, options);\n\n        var theta = 2 * Math.PI / sides,\n            path = '',\n            offset = theta * 0.5;\n\n        for (var i = 0; i < sides; i += 1) {\n            var angle = offset + (i * theta),\n                xx = Math.cos(angle) * radius,\n                yy = Math.sin(angle) * radius;\n\n            path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';\n        }\n\n        var polygon = { \n            label: 'Polygon Body',\n            position: { x: x, y: y },\n            vertices: Vertices.fromPath(path)\n        };\n\n        if (options.chamfer) {\n            var chamfer = options.chamfer;\n            polygon.vertices = Vertices.chamfer(polygon.vertices, chamfer.radius, \n                chamfer.quality, chamfer.qualityMin, chamfer.qualityMax);\n            delete options.chamfer;\n        }\n\n        return Body.create(Common.extend({}, polygon, options));\n    };\n\n    /**\n     * Utility to create a compound body based on set(s) of vertices.\n     * \n     * _Note:_ To optionally enable automatic concave vertices decomposition the [poly-decomp](https://github.com/schteppe/poly-decomp.js) \n     * package must be first installed and provided see `Common.setDecomp`, otherwise the convex hull of each vertex set will be used.\n     * \n     * The resulting vertices are reorientated about their centre of mass,\n     * and offset such that `body.position` corresponds to this point.\n     * \n     * The resulting offset may be found if needed by subtracting `body.bounds` from the original input bounds.\n     * To later move the centre of mass see `Body.setCentre`.\n     * \n     * Note that automatic conconcave decomposition results are not always optimal. \n     * For best results, simplify the input vertices as much as possible first.\n     * By default this function applies some addtional simplification to help.\n     * \n     * Some outputs may also require further manual processing afterwards to be robust.\n     * In particular some parts may need to be overlapped to avoid collision gaps.\n     * Thin parts and sharp points should be avoided or removed where possible.\n     *\n     * The options parameter object specifies any `Matter.Body` properties you wish to override the defaults.\n     * \n     * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.\n     * @method fromVertices\n     * @param {number} x\n     * @param {number} y\n     * @param {array} vertexSets One or more arrays of vertex points e.g. `[[{ x: 0, y: 0 }...], ...]`.\n     * @param {object} [options] The body options.\n     * @param {bool} [flagInternal=false] Optionally marks internal edges with `isInternal`.\n     * @param {number} [removeCollinear=0.01] Threshold when simplifying vertices along the same edge.\n     * @param {number} [minimumArea=10] Threshold when removing small parts.\n     * @param {number} [removeDuplicatePoints=0.01] Threshold when simplifying nearby vertices.\n     * @return {body}\n     */\n    Bodies.fromVertices = function(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea, removeDuplicatePoints) {\n        var decomp = Common.getDecomp(),\n            canDecomp,\n            body,\n            parts,\n            isConvex,\n            isConcave,\n            vertices,\n            i,\n            j,\n            k,\n            v,\n            z;\n\n        // check decomp is as expected\n        canDecomp = Boolean(decomp && decomp.quickDecomp);\n\n        options = options || {};\n        parts = [];\n\n        flagInternal = typeof flagInternal !== 'undefined' ? flagInternal : false;\n        removeCollinear = typeof removeCollinear !== 'undefined' ? removeCollinear : 0.01;\n        minimumArea = typeof minimumArea !== 'undefined' ? minimumArea : 10;\n        removeDuplicatePoints = typeof removeDuplicatePoints !== 'undefined' ? removeDuplicatePoints : 0.01;\n\n        // ensure vertexSets is an array of arrays\n        if (!Common.isArray(vertexSets[0])) {\n            vertexSets = [vertexSets];\n        }\n\n        for (v = 0; v < vertexSets.length; v += 1) {\n            vertices = vertexSets[v];\n            isConvex = Vertices.isConvex(vertices);\n            isConcave = !isConvex;\n\n            if (isConcave && !canDecomp) {\n                Common.warnOnce(\n                    'Bodies.fromVertices: Install the \\'poly-decomp\\' library and use Common.setDecomp or provide \\'decomp\\' as a global to decompose concave vertices.'\n                );\n            }\n\n            if (isConvex || !canDecomp) {\n                if (isConvex) {\n                    vertices = Vertices.clockwiseSort(vertices);\n                } else {\n                    // fallback to convex hull when decomposition is not possible\n                    vertices = Vertices.hull(vertices);\n                }\n\n                parts.push({\n                    position: { x: x, y: y },\n                    vertices: vertices\n                });\n            } else {\n                // initialise a decomposition\n                var concave = vertices.map(function(vertex) {\n                    return [vertex.x, vertex.y];\n                });\n\n                // vertices are concave and simple, we can decompose into parts\n                decomp.makeCCW(concave);\n                if (removeCollinear !== false)\n                    decomp.removeCollinearPoints(concave, removeCollinear);\n                if (removeDuplicatePoints !== false && decomp.removeDuplicatePoints)\n                    decomp.removeDuplicatePoints(concave, removeDuplicatePoints);\n\n                // use the quick decomposition algorithm (Bayazit)\n                var decomposed = decomp.quickDecomp(concave);\n\n                // for each decomposed chunk\n                for (i = 0; i < decomposed.length; i++) {\n                    var chunk = decomposed[i];\n\n                    // convert vertices into the correct structure\n                    var chunkVertices = chunk.map(function(vertices) {\n                        return {\n                            x: vertices[0],\n                            y: vertices[1]\n                        };\n                    });\n\n                    // skip small chunks\n                    if (minimumArea > 0 && Vertices.area(chunkVertices) < minimumArea)\n                        continue;\n\n                    // create a compound part\n                    parts.push({\n                        position: Vertices.centre(chunkVertices),\n                        vertices: chunkVertices\n                    });\n                }\n            }\n        }\n\n        // create body parts\n        for (i = 0; i < parts.length; i++) {\n            parts[i] = Body.create(Common.extend(parts[i], options));\n        }\n\n        // flag internal edges (coincident part edges)\n        if (flagInternal) {\n            var coincident_max_dist = 5;\n\n            for (i = 0; i < parts.length; i++) {\n                var partA = parts[i];\n\n                for (j = i + 1; j < parts.length; j++) {\n                    var partB = parts[j];\n\n                    if (Bounds.overlaps(partA.bounds, partB.bounds)) {\n                        var pav = partA.vertices,\n                            pbv = partB.vertices;\n\n                        // iterate vertices of both parts\n                        for (k = 0; k < partA.vertices.length; k++) {\n                            for (z = 0; z < partB.vertices.length; z++) {\n                                // find distances between the vertices\n                                var da = Vector.magnitudeSquared(Vector.sub(pav[(k + 1) % pav.length], pbv[z])),\n                                    db = Vector.magnitudeSquared(Vector.sub(pav[k], pbv[(z + 1) % pbv.length]));\n\n                                // if both vertices are very close, consider the edge concident (internal)\n                                if (da < coincident_max_dist && db < coincident_max_dist) {\n                                    pav[k].isInternal = true;\n                                    pbv[z].isInternal = true;\n                                }\n                            }\n                        }\n\n                    }\n                }\n            }\n        }\n\n        if (parts.length > 1) {\n            // create the parent body to be returned, that contains generated compound parts\n            body = Body.create(Common.extend({ parts: parts.slice(0) }, options));\n\n            // offset such that body.position is at the centre off mass\n            Body.setPosition(body, { x: x, y: y });\n\n            return body;\n        } else {\n            return parts[0];\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __nested_webpack_require_178316__) {\n\n/**\n* The `Matter.Detector` module contains methods for efficiently detecting collisions between a list of bodies using a broadphase algorithm.\n*\n* @class Detector\n*/\n\nvar Detector = {};\n\nmodule.exports = Detector;\n\nvar Common = __nested_webpack_require_178316__(0);\nvar Collision = __nested_webpack_require_178316__(8);\n\n(function() {\n\n    /**\n     * Creates a new collision detector.\n     * @method create\n     * @param {} options\n     * @return {detector} A new collision detector\n     */\n    Detector.create = function(options) {\n        var defaults = {\n            bodies: [],\n            pairs: null\n        };\n\n        return Common.extend(defaults, options);\n    };\n\n    /**\n     * Sets the list of bodies in the detector.\n     * @method setBodies\n     * @param {detector} detector\n     * @param {body[]} bodies\n     */\n    Detector.setBodies = function(detector, bodies) {\n        detector.bodies = bodies.slice(0);\n    };\n\n    /**\n     * Clears the detector including its list of bodies.\n     * @method clear\n     * @param {detector} detector\n     */\n    Detector.clear = function(detector) {\n        detector.bodies = [];\n    };\n\n    /**\n     * Efficiently finds all collisions among all the bodies in `detector.bodies` using a broadphase algorithm.\n     * \n     * _Note:_ The specific ordering of collisions returned is not guaranteed between releases and may change for performance reasons.\n     * If a specific ordering is required then apply a sort to the resulting array.\n     * @method collisions\n     * @param {detector} detector\n     * @return {collision[]} collisions\n     */\n    Detector.collisions = function(detector) {\n        var collisions = [],\n            pairs = detector.pairs,\n            bodies = detector.bodies,\n            bodiesLength = bodies.length,\n            canCollide = Detector.canCollide,\n            collides = Collision.collides,\n            i,\n            j;\n\n        bodies.sort(Detector._compareBoundsX);\n\n        for (i = 0; i < bodiesLength; i++) {\n            var bodyA = bodies[i],\n                boundsA = bodyA.bounds,\n                boundXMax = bodyA.bounds.max.x,\n                boundYMax = bodyA.bounds.max.y,\n                boundYMin = bodyA.bounds.min.y,\n                bodyAStatic = bodyA.isStatic || bodyA.isSleeping,\n                partsALength = bodyA.parts.length,\n                partsASingle = partsALength === 1;\n\n            for (j = i + 1; j < bodiesLength; j++) {\n                var bodyB = bodies[j],\n                    boundsB = bodyB.bounds;\n\n                if (boundsB.min.x > boundXMax) {\n                    break;\n                }\n\n                if (boundYMax < boundsB.min.y || boundYMin > boundsB.max.y) {\n                    continue;\n                }\n\n                if (bodyAStatic && (bodyB.isStatic || bodyB.isSleeping)) {\n                    continue;\n                }\n\n                if (!canCollide(bodyA.collisionFilter, bodyB.collisionFilter)) {\n                    continue;\n                }\n\n                var partsBLength = bodyB.parts.length;\n\n                if (partsASingle && partsBLength === 1) {\n                    var collision = collides(bodyA, bodyB, pairs);\n\n                    if (collision) {\n                        collisions.push(collision);\n                    }\n                } else {\n                    var partsAStart = partsALength > 1 ? 1 : 0,\n                        partsBStart = partsBLength > 1 ? 1 : 0;\n                    \n                    for (var k = partsAStart; k < partsALength; k++) {\n                        var partA = bodyA.parts[k],\n                            boundsA = partA.bounds;\n\n                        for (var z = partsBStart; z < partsBLength; z++) {\n                            var partB = bodyB.parts[z],\n                                boundsB = partB.bounds;\n\n                            if (boundsA.min.x > boundsB.max.x || boundsA.max.x < boundsB.min.x\n                                || boundsA.max.y < boundsB.min.y || boundsA.min.y > boundsB.max.y) {\n                                continue;\n                            }\n\n                            var collision = collides(partA, partB, pairs);\n\n                            if (collision) {\n                                collisions.push(collision);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns `true` if both supplied collision filters will allow a collision to occur.\n     * See `body.collisionFilter` for more information.\n     * @method canCollide\n     * @param {} filterA\n     * @param {} filterB\n     * @return {bool} `true` if collision can occur\n     */\n    Detector.canCollide = function(filterA, filterB) {\n        if (filterA.group === filterB.group && filterA.group !== 0)\n            return filterA.group > 0;\n\n        return (filterA.mask & filterB.category) !== 0 && (filterB.mask & filterA.category) !== 0;\n    };\n\n    /**\n     * The comparison function used in the broadphase algorithm.\n     * Returns the signed delta of the bodies bounds on the x-axis.\n     * @private\n     * @method _sortCompare\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {number} The signed delta used for sorting\n     */\n    Detector._compareBoundsX = function(bodyA, bodyB) {\n        return bodyA.bounds.min.x - bodyB.bounds.min.x;\n    };\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * The array of `Matter.Body` between which the detector finds collisions.\n     * \n     * _Note:_ The order of bodies in this array _is not fixed_ and will be continually managed by the detector.\n     * @property bodies\n     * @type body[]\n     * @default []\n     */\n\n    /**\n     * Optional. A `Matter.Pairs` object from which previous collision objects may be reused. Intended for internal `Matter.Engine` usage.\n     * @property pairs\n     * @type {pairs|null}\n     * @default null\n     */\n\n})();\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __nested_webpack_require_184361__) {\n\n/**\n* The `Matter.Mouse` module contains methods for creating and manipulating mouse inputs.\n*\n* @class Mouse\n*/\n\nvar Mouse = {};\n\nmodule.exports = Mouse;\n\nvar Common = __nested_webpack_require_184361__(0);\n\n(function() {\n\n    /**\n     * Creates a mouse input.\n     * @method create\n     * @param {HTMLElement} element\n     * @return {mouse} A new mouse\n     */\n    Mouse.create = function(element) {\n        var mouse = {};\n\n        if (!element) {\n            Common.log('Mouse.create: element was undefined, defaulting to document.body', 'warn');\n        }\n        \n        mouse.element = element || document.body;\n        mouse.absolute = { x: 0, y: 0 };\n        mouse.position = { x: 0, y: 0 };\n        mouse.mousedownPosition = { x: 0, y: 0 };\n        mouse.mouseupPosition = { x: 0, y: 0 };\n        mouse.offset = { x: 0, y: 0 };\n        mouse.scale = { x: 1, y: 1 };\n        mouse.wheelDelta = 0;\n        mouse.button = -1;\n        mouse.pixelRatio = parseInt(mouse.element.getAttribute('data-pixel-ratio'), 10) || 1;\n\n        mouse.sourceEvents = {\n            mousemove: null,\n            mousedown: null,\n            mouseup: null,\n            mousewheel: null\n        };\n        \n        mouse.mousemove = function(event) { \n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.sourceEvents.mousemove = event;\n        };\n        \n        mouse.mousedown = function(event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                mouse.button = 0;\n                event.preventDefault();\n            } else {\n                mouse.button = event.button;\n            }\n\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mousedownPosition.x = mouse.position.x;\n            mouse.mousedownPosition.y = mouse.position.y;\n            mouse.sourceEvents.mousedown = event;\n        };\n        \n        mouse.mouseup = function(event) {\n            var position = Mouse._getRelativeMousePosition(event, mouse.element, mouse.pixelRatio),\n                touches = event.changedTouches;\n\n            if (touches) {\n                event.preventDefault();\n            }\n            \n            mouse.button = -1;\n            mouse.absolute.x = position.x;\n            mouse.absolute.y = position.y;\n            mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n            mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n            mouse.mouseupPosition.x = mouse.position.x;\n            mouse.mouseupPosition.y = mouse.position.y;\n            mouse.sourceEvents.mouseup = event;\n        };\n\n        mouse.mousewheel = function(event) {\n            mouse.wheelDelta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));\n            event.preventDefault();\n        };\n\n        Mouse.setElement(mouse, mouse.element);\n\n        return mouse;\n    };\n\n    /**\n     * Sets the element the mouse is bound to (and relative to).\n     * @method setElement\n     * @param {mouse} mouse\n     * @param {HTMLElement} element\n     */\n    Mouse.setElement = function(mouse, element) {\n        mouse.element = element;\n\n        element.addEventListener('mousemove', mouse.mousemove);\n        element.addEventListener('mousedown', mouse.mousedown);\n        element.addEventListener('mouseup', mouse.mouseup);\n        \n        element.addEventListener('mousewheel', mouse.mousewheel);\n        element.addEventListener('DOMMouseScroll', mouse.mousewheel);\n\n        element.addEventListener('touchmove', mouse.mousemove);\n        element.addEventListener('touchstart', mouse.mousedown);\n        element.addEventListener('touchend', mouse.mouseup);\n    };\n\n    /**\n     * Clears all captured source events.\n     * @method clearSourceEvents\n     * @param {mouse} mouse\n     */\n    Mouse.clearSourceEvents = function(mouse) {\n        mouse.sourceEvents.mousemove = null;\n        mouse.sourceEvents.mousedown = null;\n        mouse.sourceEvents.mouseup = null;\n        mouse.sourceEvents.mousewheel = null;\n        mouse.wheelDelta = 0;\n    };\n\n    /**\n     * Sets the mouse position offset.\n     * @method setOffset\n     * @param {mouse} mouse\n     * @param {vector} offset\n     */\n    Mouse.setOffset = function(mouse, offset) {\n        mouse.offset.x = offset.x;\n        mouse.offset.y = offset.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n\n    /**\n     * Sets the mouse position scale.\n     * @method setScale\n     * @param {mouse} mouse\n     * @param {vector} scale\n     */\n    Mouse.setScale = function(mouse, scale) {\n        mouse.scale.x = scale.x;\n        mouse.scale.y = scale.y;\n        mouse.position.x = mouse.absolute.x * mouse.scale.x + mouse.offset.x;\n        mouse.position.y = mouse.absolute.y * mouse.scale.y + mouse.offset.y;\n    };\n    \n    /**\n     * Gets the mouse position relative to an element given a screen pixel ratio.\n     * @method _getRelativeMousePosition\n     * @private\n     * @param {} event\n     * @param {} element\n     * @param {number} pixelRatio\n     * @return {}\n     */\n    Mouse._getRelativeMousePosition = function(event, element, pixelRatio) {\n        var elementBounds = element.getBoundingClientRect(),\n            rootNode = (document.documentElement || document.body.parentNode || document.body),\n            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : rootNode.scrollLeft,\n            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : rootNode.scrollTop,\n            touches = event.changedTouches,\n            x, y;\n        \n        if (touches) {\n            x = touches[0].pageX - elementBounds.left - scrollX;\n            y = touches[0].pageY - elementBounds.top - scrollY;\n        } else {\n            x = event.pageX - elementBounds.left - scrollX;\n            y = event.pageY - elementBounds.top - scrollY;\n        }\n\n        return { \n            x: x / (element.clientWidth / (element.width || element.clientWidth) * pixelRatio),\n            y: y / (element.clientHeight / (element.height || element.clientHeight) * pixelRatio)\n        };\n    };\n\n})();\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_191365__) {\n\n/**\n* The `Matter.Plugin` module contains functions for registering and installing plugins on modules.\n*\n* @class Plugin\n*/\n\nvar Plugin = {};\n\nmodule.exports = Plugin;\n\nvar Common = __nested_webpack_require_191365__(0);\n\n(function() {\n\n    Plugin._registry = {};\n\n    /**\n     * Registers a plugin object so it can be resolved later by name.\n     * @method register\n     * @param plugin {} The plugin to register.\n     * @return {object} The plugin.\n     */\n    Plugin.register = function(plugin) {\n        if (!Plugin.isPlugin(plugin)) {\n            Common.warn('Plugin.register:', Plugin.toString(plugin), 'does not implement all required fields.');\n        }\n\n        if (plugin.name in Plugin._registry) {\n            var registered = Plugin._registry[plugin.name],\n                pluginVersion = Plugin.versionParse(plugin.version).number,\n                registeredVersion = Plugin.versionParse(registered.version).number;\n\n            if (pluginVersion > registeredVersion) {\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'was upgraded to', Plugin.toString(plugin));\n                Plugin._registry[plugin.name] = plugin;\n            } else if (pluginVersion < registeredVersion) {\n                Common.warn('Plugin.register:', Plugin.toString(registered), 'can not be downgraded to', Plugin.toString(plugin));\n            } else if (plugin !== registered) {\n                Common.warn('Plugin.register:', Plugin.toString(plugin), 'is already registered to different plugin object');\n            }\n        } else {\n            Plugin._registry[plugin.name] = plugin;\n        }\n\n        return plugin;\n    };\n\n    /**\n     * Resolves a dependency to a plugin object from the registry if it exists. \n     * The `dependency` may contain a version, but only the name matters when resolving.\n     * @method resolve\n     * @param dependency {string} The dependency.\n     * @return {object} The plugin if resolved, otherwise `undefined`.\n     */\n    Plugin.resolve = function(dependency) {\n        return Plugin._registry[Plugin.dependencyParse(dependency).name];\n    };\n\n    /**\n     * Returns a pretty printed plugin name and version.\n     * @method toString\n     * @param plugin {} The plugin.\n     * @return {string} Pretty printed plugin name and version.\n     */\n    Plugin.toString = function(plugin) {\n        return typeof plugin === 'string' ? plugin : (plugin.name || 'anonymous') + '@' + (plugin.version || plugin.range || '0.0.0');\n    };\n\n    /**\n     * Returns `true` if the object meets the minimum standard to be considered a plugin.\n     * This means it must define the following properties:\n     * - `name`\n     * - `version`\n     * - `install`\n     * @method isPlugin\n     * @param obj {} The obj to test.\n     * @return {boolean} `true` if the object can be considered a plugin otherwise `false`.\n     */\n    Plugin.isPlugin = function(obj) {\n        return obj && obj.name && obj.version && obj.install;\n    };\n\n    /**\n     * Returns `true` if a plugin with the given `name` been installed on `module`.\n     * @method isUsed\n     * @param module {} The module.\n     * @param name {string} The plugin name.\n     * @return {boolean} `true` if a plugin with the given `name` been installed on `module`, otherwise `false`.\n     */\n    Plugin.isUsed = function(module, name) {\n        return module.used.indexOf(name) > -1;\n    };\n\n    /**\n     * Returns `true` if `plugin.for` is applicable to `module` by comparing against `module.name` and `module.version`.\n     * If `plugin.for` is not specified then it is assumed to be applicable.\n     * The value of `plugin.for` is a string of the format `'module-name'` or `'module-name@version'`.\n     * @method isFor\n     * @param plugin {} The plugin.\n     * @param module {} The module.\n     * @return {boolean} `true` if `plugin.for` is applicable to `module`, otherwise `false`.\n     */\n    Plugin.isFor = function(plugin, module) {\n        var parsed = plugin.for && Plugin.dependencyParse(plugin.for);\n        return !plugin.for || (module.name === parsed.name && Plugin.versionSatisfies(module.version, parsed.range));\n    };\n\n    /**\n     * Installs the plugins by calling `plugin.install` on each plugin specified in `plugins` if passed, otherwise `module.uses`.\n     * For installing plugins on `Matter` see the convenience function `Matter.use`.\n     * Plugins may be specified either by their name or a reference to the plugin object.\n     * Plugins themselves may specify further dependencies, but each plugin is installed only once.\n     * Order is important, a topological sort is performed to find the best resulting order of installation.\n     * This sorting attempts to satisfy every dependency's requested ordering, but may not be exact in all cases.\n     * This function logs the resulting status of each dependency in the console, along with any warnings.\n     * - A green tick âœ… indicates a dependency was resolved and installed.\n     * - An orange diamond ðŸ”¶ indicates a dependency was resolved but a warning was thrown for it or one if its dependencies.\n     * - A red cross âŒ indicates a dependency could not be resolved.\n     * Avoid calling this function multiple times on the same module unless you intend to manually control installation order.\n     * @method use\n     * @param module {} The module install plugins on.\n     * @param [plugins=module.uses] {} The plugins to install on module (optional, defaults to `module.uses`).\n     */\n    Plugin.use = function(module, plugins) {\n        module.uses = (module.uses || []).concat(plugins || []);\n\n        if (module.uses.length === 0) {\n            Common.warn('Plugin.use:', Plugin.toString(module), 'does not specify any dependencies to install.');\n            return;\n        }\n\n        var dependencies = Plugin.dependencies(module),\n            sortedDependencies = Common.topologicalSort(dependencies),\n            status = [];\n\n        for (var i = 0; i < sortedDependencies.length; i += 1) {\n            if (sortedDependencies[i] === module.name) {\n                continue;\n            }\n\n            var plugin = Plugin.resolve(sortedDependencies[i]);\n\n            if (!plugin) {\n                status.push('âŒ ' + sortedDependencies[i]);\n                continue;\n            }\n\n            if (Plugin.isUsed(module, plugin.name)) {\n                continue;\n            }\n\n            if (!Plugin.isFor(plugin, module)) {\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'is for', plugin.for, 'but installed on', Plugin.toString(module) + '.');\n                plugin._warned = true;\n            }\n\n            if (plugin.install) {\n                plugin.install(module);\n            } else {\n                Common.warn('Plugin.use:', Plugin.toString(plugin), 'does not specify an install function.');\n                plugin._warned = true;\n            }\n\n            if (plugin._warned) {\n                status.push('ðŸ”¶ ' + Plugin.toString(plugin));\n                delete plugin._warned;\n            } else {\n                status.push('âœ… ' + Plugin.toString(plugin));\n            }\n\n            module.used.push(plugin.name);\n        }\n\n        if (status.length > 0) {\n            Common.info(status.join('  '));\n        }\n    };\n\n    /**\n     * Recursively finds all of a module's dependencies and returns a flat dependency graph.\n     * @method dependencies\n     * @param module {} The module.\n     * @return {object} A dependency graph.\n     */\n    Plugin.dependencies = function(module, tracked) {\n        var parsedBase = Plugin.dependencyParse(module),\n            name = parsedBase.name;\n\n        tracked = tracked || {};\n\n        if (name in tracked) {\n            return;\n        }\n\n        module = Plugin.resolve(module) || module;\n\n        tracked[name] = Common.map(module.uses || [], function(dependency) {\n            if (Plugin.isPlugin(dependency)) {\n                Plugin.register(dependency);\n            }\n\n            var parsed = Plugin.dependencyParse(dependency),\n                resolved = Plugin.resolve(dependency);\n\n            if (resolved && !Plugin.versionSatisfies(resolved.version, parsed.range)) {\n                Common.warn(\n                    'Plugin.dependencies:', Plugin.toString(resolved), 'does not satisfy',\n                    Plugin.toString(parsed), 'used by', Plugin.toString(parsedBase) + '.'\n                );\n\n                resolved._warned = true;\n                module._warned = true;\n            } else if (!resolved) {\n                Common.warn(\n                    'Plugin.dependencies:', Plugin.toString(dependency), 'used by',\n                    Plugin.toString(parsedBase), 'could not be resolved.'\n                );\n\n                module._warned = true;\n            }\n\n            return parsed.name;\n        });\n\n        for (var i = 0; i < tracked[name].length; i += 1) {\n            Plugin.dependencies(tracked[name][i], tracked);\n        }\n\n        return tracked;\n    };\n\n    /**\n     * Parses a dependency string into its components.\n     * The `dependency` is a string of the format `'module-name'` or `'module-name@version'`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * This function can also handle dependencies that are already resolved (e.g. a module object).\n     * @method dependencyParse\n     * @param dependency {string} The dependency of the format `'module-name'` or `'module-name@version'`.\n     * @return {object} The dependency parsed into its components.\n     */\n    Plugin.dependencyParse = function(dependency) {\n        if (Common.isString(dependency)) {\n            var pattern = /^[\\w-]+(@(\\*|[\\^~]?\\d+\\.\\d+\\.\\d+(-[0-9A-Za-z-+]+)?))?$/;\n\n            if (!pattern.test(dependency)) {\n                Common.warn('Plugin.dependencyParse:', dependency, 'is not a valid dependency string.');\n            }\n\n            return {\n                name: dependency.split('@')[0],\n                range: dependency.split('@')[1] || '*'\n            };\n        }\n\n        return {\n            name: dependency.name,\n            range: dependency.range || dependency.version\n        };\n    };\n\n    /**\n     * Parses a version string into its components.  \n     * Versions are strictly of the format `x.y.z` (as in [semver](http://semver.org/)).\n     * Versions may optionally have a prerelease tag in the format `x.y.z-alpha`.\n     * Ranges are a strict subset of [npm ranges](https://docs.npmjs.com/misc/semver#advanced-range-syntax).\n     * Only the following range types are supported:\n     * - Tilde ranges e.g. `~1.2.3`\n     * - Caret ranges e.g. `^1.2.3`\n     * - Greater than ranges e.g. `>1.2.3`\n     * - Greater than or equal ranges e.g. `>=1.2.3`\n     * - Exact version e.g. `1.2.3`\n     * - Any version `*`\n     * @method versionParse\n     * @param range {string} The version string.\n     * @return {object} The version range parsed into its components.\n     */\n    Plugin.versionParse = function(range) {\n        var pattern = /^(\\*)|(\\^|~|>=|>)?\\s*((\\d+)\\.(\\d+)\\.(\\d+))(-[0-9A-Za-z-+]+)?$/;\n\n        if (!pattern.test(range)) {\n            Common.warn('Plugin.versionParse:', range, 'is not a valid version or range.');\n        }\n\n        var parts = pattern.exec(range);\n        var major = Number(parts[4]);\n        var minor = Number(parts[5]);\n        var patch = Number(parts[6]);\n\n        return {\n            isRange: Boolean(parts[1] || parts[2]),\n            version: parts[3],\n            range: range,\n            operator: parts[1] || parts[2] || '',\n            major: major,\n            minor: minor,\n            patch: patch,\n            parts: [major, minor, patch],\n            prerelease: parts[7],\n            number: major * 1e8 + minor * 1e4 + patch\n        };\n    };\n\n    /**\n     * Returns `true` if `version` satisfies the given `range`.\n     * See documentation for `Plugin.versionParse` for a description of the format.\n     * If a version or range is not specified, then any version (`*`) is assumed to satisfy.\n     * @method versionSatisfies\n     * @param version {string} The version string.\n     * @param range {string} The range string.\n     * @return {boolean} `true` if `version` satisfies `range`, otherwise `false`.\n     */\n    Plugin.versionSatisfies = function(version, range) {\n        range = range || '*';\n\n        var r = Plugin.versionParse(range),\n            v = Plugin.versionParse(version);\n\n        if (r.isRange) {\n            if (r.operator === '*' || version === '*') {\n                return true;\n            }\n\n            if (r.operator === '>') {\n                return v.number > r.number;\n            }\n\n            if (r.operator === '>=') {\n                return v.number >= r.number;\n            }\n\n            if (r.operator === '~') {\n                return v.major === r.major && v.minor === r.minor && v.patch >= r.patch;\n            }\n\n            if (r.operator === '^') {\n                if (r.major > 0) {\n                    return v.major === r.major && v.number >= r.number;\n                }\n\n                if (r.minor > 0) {\n                    return v.minor === r.minor && v.patch >= r.patch;\n                }\n\n                return v.patch === r.patch;\n            }\n        }\n\n        return version === range || version === '*';\n    };\n\n})();\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n/**\n* The `Matter.Contact` module contains methods for creating and manipulating collision contacts.\n*\n* @class Contact\n*/\n\nvar Contact = {};\n\nmodule.exports = Contact;\n\n(function() {\n\n    /**\n     * Creates a new contact.\n     * @method create\n     * @param {vertex} vertex\n     * @return {contact} A new contact\n     */\n    Contact.create = function(vertex) {\n        return {\n            vertex: vertex,\n            normalImpulse: 0,\n            tangentImpulse: 0\n        };\n    };\n\n})();\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __nested_webpack_require_205269__) {\n\n/**\n* The `Matter.Engine` module contains methods for creating and manipulating engines.\n* An engine is a controller that manages updating the simulation of the world.\n* See `Matter.Runner` for an optional game loop utility.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Engine\n*/\n\nvar Engine = {};\n\nmodule.exports = Engine;\n\nvar Sleeping = __nested_webpack_require_205269__(7);\nvar Resolver = __nested_webpack_require_205269__(18);\nvar Detector = __nested_webpack_require_205269__(13);\nvar Pairs = __nested_webpack_require_205269__(19);\nvar Events = __nested_webpack_require_205269__(5);\nvar Composite = __nested_webpack_require_205269__(6);\nvar Constraint = __nested_webpack_require_205269__(10);\nvar Common = __nested_webpack_require_205269__(0);\nvar Body = __nested_webpack_require_205269__(4);\n\n(function() {\n\n    /**\n     * Creates a new engine. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {engine} engine\n     */\n    Engine.create = function(options) {\n        options = options || {};\n\n        var defaults = {\n            positionIterations: 6,\n            velocityIterations: 4,\n            constraintIterations: 2,\n            enableSleeping: false,\n            events: [],\n            plugin: {},\n            gravity: {\n                x: 0,\n                y: 1,\n                scale: 0.001\n            },\n            timing: {\n                timestamp: 0,\n                timeScale: 1,\n                lastDelta: 0,\n                lastElapsed: 0\n            }\n        };\n\n        var engine = Common.extend(defaults, options);\n\n        engine.world = options.world || Composite.create({ label: 'World' });\n        engine.pairs = options.pairs || Pairs.create();\n        engine.detector = options.detector || Detector.create();\n\n        // for temporary back compatibility only\n        engine.grid = { buckets: [] };\n        engine.world.gravity = engine.gravity;\n        engine.broadphase = engine.grid;\n        engine.metrics = {};\n        \n        return engine;\n    };\n\n    /**\n     * Moves the simulation forward in time by `delta` milliseconds.\n     * Triggers `beforeUpdate` and `afterUpdate` events.\n     * Triggers `collisionStart`, `collisionActive` and `collisionEnd` events.\n     * @method update\n     * @param {engine} engine\n     * @param {number} [delta=16.666]\n     */\n    Engine.update = function(engine, delta) {\n        var startTime = Common.now();\n\n        var world = engine.world,\n            detector = engine.detector,\n            pairs = engine.pairs,\n            timing = engine.timing,\n            timestamp = timing.timestamp,\n            i;\n\n        delta = typeof delta !== 'undefined' ? delta : Common._baseDelta;\n        delta *= timing.timeScale;\n\n        // increment timestamp\n        timing.timestamp += delta;\n        timing.lastDelta = delta;\n\n        // create an event object\n        var event = {\n            timestamp: timing.timestamp,\n            delta: delta\n        };\n\n        Events.trigger(engine, 'beforeUpdate', event);\n\n        // get all bodies and all constraints in the world\n        var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world);\n\n        // if the world has changed\n        if (world.isModified) {\n            // update the detector bodies\n            Detector.setBodies(detector, allBodies);\n\n            // reset all composite modified flags\n            Composite.setModified(world, false, false, true);\n        }\n\n        // update sleeping if enabled\n        if (engine.enableSleeping)\n            Sleeping.update(allBodies, delta);\n\n        // apply gravity to all bodies\n        Engine._bodiesApplyGravity(allBodies, engine.gravity);\n\n        // update all body position and rotation by integration\n        if (delta > 0) {\n            Engine._bodiesUpdate(allBodies, delta);\n        }\n\n        // update all constraints (first pass)\n        Constraint.preSolveAll(allBodies);\n        for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, delta);\n        }\n        Constraint.postSolveAll(allBodies);\n\n        // find all collisions\n        detector.pairs = engine.pairs;\n        var collisions = Detector.collisions(detector);\n\n        // update collision pairs\n        Pairs.update(pairs, collisions, timestamp);\n\n        // wake up bodies involved in collisions\n        if (engine.enableSleeping)\n            Sleeping.afterCollisions(pairs.list);\n\n        // trigger collision events\n        if (pairs.collisionStart.length > 0)\n            Events.trigger(engine, 'collisionStart', { pairs: pairs.collisionStart });\n\n        // iteratively resolve position between collisions\n        var positionDamping = Common.clamp(20 / engine.positionIterations, 0, 1);\n        \n        Resolver.preSolvePosition(pairs.list);\n        for (i = 0; i < engine.positionIterations; i++) {\n            Resolver.solvePosition(pairs.list, delta, positionDamping);\n        }\n        Resolver.postSolvePosition(allBodies);\n\n        // update all constraints (second pass)\n        Constraint.preSolveAll(allBodies);\n        for (i = 0; i < engine.constraintIterations; i++) {\n            Constraint.solveAll(allConstraints, delta);\n        }\n        Constraint.postSolveAll(allBodies);\n\n        // iteratively resolve velocity between collisions\n        Resolver.preSolveVelocity(pairs.list);\n        for (i = 0; i < engine.velocityIterations; i++) {\n            Resolver.solveVelocity(pairs.list, delta);\n        }\n\n        // update body speed and velocity properties\n        Engine._bodiesUpdateVelocities(allBodies);\n\n        // trigger collision events\n        if (pairs.collisionActive.length > 0)\n            Events.trigger(engine, 'collisionActive', { pairs: pairs.collisionActive });\n\n        if (pairs.collisionEnd.length > 0)\n            Events.trigger(engine, 'collisionEnd', { pairs: pairs.collisionEnd });\n\n        // clear force buffers\n        Engine._bodiesClearForces(allBodies);\n\n        Events.trigger(engine, 'afterUpdate', event);\n\n        // log the time elapsed computing this update\n        engine.timing.lastElapsed = Common.now() - startTime;\n\n        return engine;\n    };\n    \n    /**\n     * Merges two engines by keeping the configuration of `engineA` but replacing the world with the one from `engineB`.\n     * @method merge\n     * @param {engine} engineA\n     * @param {engine} engineB\n     */\n    Engine.merge = function(engineA, engineB) {\n        Common.extend(engineA, engineB);\n        \n        if (engineB.world) {\n            engineA.world = engineB.world;\n\n            Engine.clear(engineA);\n\n            var bodies = Composite.allBodies(engineA.world);\n\n            for (var i = 0; i < bodies.length; i++) {\n                var body = bodies[i];\n                Sleeping.set(body, false);\n                body.id = Common.nextId();\n            }\n        }\n    };\n\n    /**\n     * Clears the engine pairs and detector.\n     * @method clear\n     * @param {engine} engine\n     */\n    Engine.clear = function(engine) {\n        Pairs.clear(engine.pairs);\n        Detector.clear(engine.detector);\n    };\n\n    /**\n     * Zeroes the `body.force` and `body.torque` force buffers.\n     * @method _bodiesClearForces\n     * @private\n     * @param {body[]} bodies\n     */\n    Engine._bodiesClearForces = function(bodies) {\n        var bodiesLength = bodies.length;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i];\n\n            // reset force buffers\n            body.force.x = 0;\n            body.force.y = 0;\n            body.torque = 0;\n        }\n    };\n\n    /**\n     * Applies gravitational acceleration to all `bodies`.\n     * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet.\n     * \n     * @method _bodiesApplyGravity\n     * @private\n     * @param {body[]} bodies\n     * @param {vector} gravity\n     */\n    Engine._bodiesApplyGravity = function(bodies, gravity) {\n        var gravityScale = typeof gravity.scale !== 'undefined' ? gravity.scale : 0.001,\n            bodiesLength = bodies.length;\n\n        if ((gravity.x === 0 && gravity.y === 0) || gravityScale === 0) {\n            return;\n        }\n        \n        for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            // add the resultant force of gravity\n            body.force.y += body.mass * gravity.y * gravityScale;\n            body.force.x += body.mass * gravity.x * gravityScale;\n        }\n    };\n\n    /**\n     * Applies `Body.update` to all given `bodies`.\n     * @method _bodiesUpdate\n     * @private\n     * @param {body[]} bodies\n     * @param {number} delta The amount of time elapsed between updates\n     */\n    Engine._bodiesUpdate = function(bodies, delta) {\n        var bodiesLength = bodies.length;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i];\n\n            if (body.isStatic || body.isSleeping)\n                continue;\n\n            Body.update(body, delta);\n        }\n    };\n\n    /**\n     * Applies `Body.updateVelocities` to all given `bodies`.\n     * @method _bodiesUpdateVelocities\n     * @private\n     * @param {body[]} bodies\n     */\n    Engine._bodiesUpdateVelocities = function(bodies) {\n        var bodiesLength = bodies.length;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            Body.updateVelocities(bodies[i]);\n        }\n    };\n\n    /**\n     * A deprecated alias for `Runner.run`, use `Matter.Runner.run(engine)` instead and see `Matter.Runner` for more information.\n     * @deprecated use Matter.Runner.run(engine) instead\n     * @method run\n     * @param {engine} engine\n     */\n\n    /**\n    * Fired just before an update\n    *\n    * @event beforeUpdate\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update and all collision events\n    *\n    * @event afterUpdate\n    * @param {object} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have started to collide in the current tick (if any)\n    *\n    * @event collisionStart\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that are colliding in the current tick (if any)\n    *\n    * @event collisionActive\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine update, provides a list of all pairs that have ended collision in the current tick (if any)\n    *\n    * @event collisionEnd\n    * @param {object} event An event object\n    * @param {pair[]} event.pairs List of affected pairs\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {number} event.delta The delta time in milliseconds value used in the update\n    * @param {engine} event.source The source object of the event\n    * @param {string} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * An integer `Number` that specifies the number of position iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property positionIterations\n     * @type number\n     * @default 6\n     */\n\n    /**\n     * An integer `Number` that specifies the number of velocity iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     *\n     * @property velocityIterations\n     * @type number\n     * @default 4\n     */\n\n    /**\n     * An integer `Number` that specifies the number of constraint iterations to perform each update.\n     * The higher the value, the higher quality the simulation will be at the expense of performance.\n     * The default value of `2` is usually very adequate.\n     *\n     * @property constraintIterations\n     * @type number\n     * @default 2\n     */\n\n    /**\n     * A flag that specifies whether the engine should allow sleeping via the `Matter.Sleeping` module.\n     * Sleeping can improve stability and performance, but often at the expense of accuracy.\n     *\n     * @property enableSleeping\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * An `Object` containing properties regarding the timing systems of the engine. \n     *\n     * @property timing\n     * @type object\n     */\n\n    /**\n     * A `Number` that specifies the global scaling factor of time for all bodies.\n     * A value of `0` freezes the simulation.\n     * A value of `0.1` gives a slow-motion effect.\n     * A value of `1.2` gives a speed-up effect.\n     *\n     * @property timing.timeScale\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A `Number` that specifies the current simulation-time in milliseconds starting from `0`. \n     * It is incremented on every `Engine.update` by the given `delta` argument. \n     * \n     * @property timing.timestamp\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that represents the total execution time elapsed during the last `Engine.update` in milliseconds.\n     * It is updated by timing from the start of the last `Engine.update` call until it ends.\n     *\n     * This value will also include the total execution time of all event handlers directly or indirectly triggered by the engine update.\n     * \n     * @property timing.lastElapsed\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Number` that represents the `delta` value used in the last engine update.\n     * \n     * @property timing.lastDelta\n     * @type number\n     * @default 0\n     */\n\n    /**\n     * A `Matter.Detector` instance.\n     *\n     * @property detector\n     * @type detector\n     * @default a Matter.Detector instance\n     */\n\n    /**\n     * A `Matter.Grid` instance.\n     *\n     * @deprecated replaced by `engine.detector`\n     * @property grid\n     * @type grid\n     * @default a Matter.Grid instance\n     */\n\n    /**\n     * Replaced by and now alias for `engine.grid`.\n     *\n     * @deprecated replaced by `engine.detector`\n     * @property broadphase\n     * @type grid\n     * @default a Matter.Grid instance\n     */\n\n    /**\n     * The root `Matter.Composite` instance that will contain all bodies, constraints and other composites to be simulated by this engine.\n     *\n     * @property world\n     * @type composite\n     * @default a Matter.Composite instance\n     */\n\n    /**\n     * An object reserved for storing plugin-specific properties.\n     *\n     * @property plugin\n     * @type {}\n     */\n\n    /**\n     * An optional gravitational acceleration applied to all bodies in `engine.world` on every update.\n     * \n     * This models a [uniform gravitational field](https://en.wikipedia.org/wiki/Gravity_of_Earth), similar to near the surface of a planet. For gravity in other contexts, disable this and apply forces as needed.\n     * \n     * To disable set the `scale` component to `0`.\n     * \n     * This is split into three components for ease of use:  \n     * a normalised direction (`x` and `y`) and magnitude (`scale`).\n     *\n     * @property gravity\n     * @type object\n     */\n\n    /**\n     * The gravitational direction normal `x` component, to be multiplied by `gravity.scale`.\n     * \n     * @property gravity.x\n     * @type object\n     * @default 0\n     */\n\n    /**\n     * The gravitational direction normal `y` component, to be multiplied by `gravity.scale`.\n     *\n     * @property gravity.y\n     * @type object\n     * @default 1\n     */\n\n    /**\n     * The magnitude of the gravitational acceleration.\n     * \n     * @property gravity.scale\n     * @type object\n     * @default 0.001\n     */\n\n})();\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __nested_webpack_require_222656__) {\n\n/**\n* The `Matter.Resolver` module contains methods for resolving collision pairs.\n*\n* @class Resolver\n*/\n\nvar Resolver = {};\n\nmodule.exports = Resolver;\n\nvar Vertices = __nested_webpack_require_222656__(3);\nvar Common = __nested_webpack_require_222656__(0);\nvar Bounds = __nested_webpack_require_222656__(1);\n\n(function() {\n\n    Resolver._restingThresh = 2;\n    Resolver._restingThreshTangent = Math.sqrt(6);\n    Resolver._positionDampen = 0.9;\n    Resolver._positionWarming = 0.8;\n    Resolver._frictionNormalMultiplier = 5;\n    Resolver._frictionMaxStatic = Number.MAX_VALUE;\n\n    /**\n     * Prepare pairs for position solving.\n     * @method preSolvePosition\n     * @param {pair[]} pairs\n     */\n    Resolver.preSolvePosition = function(pairs) {\n        var i,\n            pair,\n            activeCount,\n            pairsLength = pairs.length;\n\n        // find total contacts on each body\n        for (i = 0; i < pairsLength; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive)\n                continue;\n            \n            activeCount = pair.activeContacts.length;\n            pair.collision.parentA.totalContacts += activeCount;\n            pair.collision.parentB.totalContacts += activeCount;\n        }\n    };\n\n    /**\n     * Find a solution for pair positions.\n     * @method solvePosition\n     * @param {pair[]} pairs\n     * @param {number} delta\n     * @param {number} [damping=1]\n     */\n    Resolver.solvePosition = function(pairs, delta, damping) {\n        var i,\n            pair,\n            collision,\n            bodyA,\n            bodyB,\n            normal,\n            contactShare,\n            positionImpulse,\n            positionDampen = Resolver._positionDampen * (damping || 1),\n            slopDampen = Common.clamp(delta / Common._baseDelta, 0, 1),\n            pairsLength = pairs.length;\n\n        // find impulses required to resolve penetration\n        for (i = 0; i < pairsLength; i++) {\n            pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n\n            // get current separation between body edges involved in collision\n            pair.separation = \n                normal.x * (bodyB.positionImpulse.x + collision.penetration.x - bodyA.positionImpulse.x)\n                + normal.y * (bodyB.positionImpulse.y + collision.penetration.y - bodyA.positionImpulse.y);\n        }\n        \n        for (i = 0; i < pairsLength; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            collision = pair.collision;\n            bodyA = collision.parentA;\n            bodyB = collision.parentB;\n            normal = collision.normal;\n            positionImpulse = pair.separation - pair.slop * slopDampen;\n\n            if (bodyA.isStatic || bodyB.isStatic)\n                positionImpulse *= 2;\n            \n            if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                contactShare = positionDampen / bodyA.totalContacts;\n                bodyA.positionImpulse.x += normal.x * positionImpulse * contactShare;\n                bodyA.positionImpulse.y += normal.y * positionImpulse * contactShare;\n            }\n\n            if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                contactShare = positionDampen / bodyB.totalContacts;\n                bodyB.positionImpulse.x -= normal.x * positionImpulse * contactShare;\n                bodyB.positionImpulse.y -= normal.y * positionImpulse * contactShare;\n            }\n        }\n    };\n\n    /**\n     * Apply position resolution.\n     * @method postSolvePosition\n     * @param {body[]} bodies\n     */\n    Resolver.postSolvePosition = function(bodies) {\n        var positionWarming = Resolver._positionWarming,\n            bodiesLength = bodies.length,\n            verticesTranslate = Vertices.translate,\n            boundsUpdate = Bounds.update;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            var body = bodies[i],\n                positionImpulse = body.positionImpulse,\n                positionImpulseX = positionImpulse.x,\n                positionImpulseY = positionImpulse.y,\n                velocity = body.velocity;\n\n            // reset contact count\n            body.totalContacts = 0;\n\n            if (positionImpulseX !== 0 || positionImpulseY !== 0) {\n                // update body geometry\n                for (var j = 0; j < body.parts.length; j++) {\n                    var part = body.parts[j];\n                    verticesTranslate(part.vertices, positionImpulse);\n                    boundsUpdate(part.bounds, part.vertices, velocity);\n                    part.position.x += positionImpulseX;\n                    part.position.y += positionImpulseY;\n                }\n\n                // move the body without changing velocity\n                body.positionPrev.x += positionImpulseX;\n                body.positionPrev.y += positionImpulseY;\n\n                if (positionImpulseX * velocity.x + positionImpulseY * velocity.y < 0) {\n                    // reset cached impulse if the body has velocity along it\n                    positionImpulse.x = 0;\n                    positionImpulse.y = 0;\n                } else {\n                    // warm the next iteration\n                    positionImpulse.x *= positionWarming;\n                    positionImpulse.y *= positionWarming;\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepare pairs for velocity solving.\n     * @method preSolveVelocity\n     * @param {pair[]} pairs\n     */\n    Resolver.preSolveVelocity = function(pairs) {\n        var pairsLength = pairs.length,\n            i,\n            j;\n        \n        for (i = 0; i < pairsLength; i++) {\n            var pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            var contacts = pair.activeContacts,\n                contactsLength = contacts.length,\n                collision = pair.collision,\n                bodyA = collision.parentA,\n                bodyB = collision.parentB,\n                normal = collision.normal,\n                tangent = collision.tangent;\n    \n            // resolve each contact\n            for (j = 0; j < contactsLength; j++) {\n                var contact = contacts[j],\n                    contactVertex = contact.vertex,\n                    normalImpulse = contact.normalImpulse,\n                    tangentImpulse = contact.tangentImpulse;\n    \n                if (normalImpulse !== 0 || tangentImpulse !== 0) {\n                    // total impulse from contact\n                    var impulseX = normal.x * normalImpulse + tangent.x * tangentImpulse,\n                        impulseY = normal.y * normalImpulse + tangent.y * tangentImpulse;\n                    \n                    // apply impulse from contact\n                    if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                        bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                        bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                        bodyA.anglePrev += bodyA.inverseInertia * (\n                            (contactVertex.x - bodyA.position.x) * impulseY\n                            - (contactVertex.y - bodyA.position.y) * impulseX\n                        );\n                    }\n    \n                    if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                        bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                        bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                        bodyB.anglePrev -= bodyB.inverseInertia * (\n                            (contactVertex.x - bodyB.position.x) * impulseY \n                            - (contactVertex.y - bodyB.position.y) * impulseX\n                        );\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Find a solution for pair velocities.\n     * @method solveVelocity\n     * @param {pair[]} pairs\n     * @param {number} delta\n     */\n    Resolver.solveVelocity = function(pairs, delta) {\n        var timeScale = delta / Common._baseDelta,\n            timeScaleSquared = timeScale * timeScale,\n            timeScaleCubed = timeScaleSquared * timeScale,\n            restingThresh = -Resolver._restingThresh * timeScale,\n            restingThreshTangent = Resolver._restingThreshTangent,\n            frictionNormalMultiplier = Resolver._frictionNormalMultiplier * timeScale,\n            frictionMaxStatic = Resolver._frictionMaxStatic,\n            pairsLength = pairs.length,\n            tangentImpulse,\n            maxFriction,\n            i,\n            j;\n\n        for (i = 0; i < pairsLength; i++) {\n            var pair = pairs[i];\n            \n            if (!pair.isActive || pair.isSensor)\n                continue;\n            \n            var collision = pair.collision,\n                bodyA = collision.parentA,\n                bodyB = collision.parentB,\n                bodyAVelocity = bodyA.velocity,\n                bodyBVelocity = bodyB.velocity,\n                normalX = collision.normal.x,\n                normalY = collision.normal.y,\n                tangentX = collision.tangent.x,\n                tangentY = collision.tangent.y,\n                contacts = pair.activeContacts,\n                contactsLength = contacts.length,\n                contactShare = 1 / contactsLength,\n                inverseMassTotal = bodyA.inverseMass + bodyB.inverseMass,\n                friction = pair.friction * pair.frictionStatic * frictionNormalMultiplier;\n\n            // update body velocities\n            bodyAVelocity.x = bodyA.position.x - bodyA.positionPrev.x;\n            bodyAVelocity.y = bodyA.position.y - bodyA.positionPrev.y;\n            bodyBVelocity.x = bodyB.position.x - bodyB.positionPrev.x;\n            bodyBVelocity.y = bodyB.position.y - bodyB.positionPrev.y;\n            bodyA.angularVelocity = bodyA.angle - bodyA.anglePrev;\n            bodyB.angularVelocity = bodyB.angle - bodyB.anglePrev;\n\n            // resolve each contact\n            for (j = 0; j < contactsLength; j++) {\n                var contact = contacts[j],\n                    contactVertex = contact.vertex;\n\n                var offsetAX = contactVertex.x - bodyA.position.x,\n                    offsetAY = contactVertex.y - bodyA.position.y,\n                    offsetBX = contactVertex.x - bodyB.position.x,\n                    offsetBY = contactVertex.y - bodyB.position.y;\n \n                var velocityPointAX = bodyAVelocity.x - offsetAY * bodyA.angularVelocity,\n                    velocityPointAY = bodyAVelocity.y + offsetAX * bodyA.angularVelocity,\n                    velocityPointBX = bodyBVelocity.x - offsetBY * bodyB.angularVelocity,\n                    velocityPointBY = bodyBVelocity.y + offsetBX * bodyB.angularVelocity;\n\n                var relativeVelocityX = velocityPointAX - velocityPointBX,\n                    relativeVelocityY = velocityPointAY - velocityPointBY;\n\n                var normalVelocity = normalX * relativeVelocityX + normalY * relativeVelocityY,\n                    tangentVelocity = tangentX * relativeVelocityX + tangentY * relativeVelocityY;\n\n                // coulomb friction\n                var normalOverlap = pair.separation + normalVelocity;\n                var normalForce = Math.min(normalOverlap, 1);\n                normalForce = normalOverlap < 0 ? 0 : normalForce;\n\n                var frictionLimit = normalForce * friction;\n\n                if (tangentVelocity < -frictionLimit || tangentVelocity > frictionLimit) {\n                    maxFriction = (tangentVelocity > 0 ? tangentVelocity : -tangentVelocity);\n                    tangentImpulse = pair.friction * (tangentVelocity > 0 ? 1 : -1) * timeScaleCubed;\n                    \n                    if (tangentImpulse < -maxFriction) {\n                        tangentImpulse = -maxFriction;\n                    } else if (tangentImpulse > maxFriction) {\n                        tangentImpulse = maxFriction;\n                    }\n                } else {\n                    tangentImpulse = tangentVelocity;\n                    maxFriction = frictionMaxStatic;\n                }\n\n                // account for mass, inertia and contact offset\n                var oAcN = offsetAX * normalY - offsetAY * normalX,\n                    oBcN = offsetBX * normalY - offsetBY * normalX,\n                    share = contactShare / (inverseMassTotal + bodyA.inverseInertia * oAcN * oAcN + bodyB.inverseInertia * oBcN * oBcN);\n\n                // raw impulses\n                var normalImpulse = (1 + pair.restitution) * normalVelocity * share;\n                tangentImpulse *= share;\n\n                // handle high velocity and resting collisions separately\n                if (normalVelocity < restingThresh) {\n                    // high normal velocity so clear cached contact normal impulse\n                    contact.normalImpulse = 0;\n                } else {\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\n                    // impulse constraint tends to 0\n                    var contactNormalImpulse = contact.normalImpulse;\n                    contact.normalImpulse += normalImpulse;\n                    if (contact.normalImpulse > 0) contact.normalImpulse = 0;\n                    normalImpulse = contact.normalImpulse - contactNormalImpulse;\n                }\n\n                // handle high velocity and resting collisions separately\n                if (tangentVelocity < -restingThreshTangent || tangentVelocity > restingThreshTangent) {\n                    // high tangent velocity so clear cached contact tangent impulse\n                    contact.tangentImpulse = 0;\n                } else {\n                    // solve resting collision constraints using Erin Catto's method (GDC08)\n                    // tangent impulse tends to -tangentSpeed or +tangentSpeed\n                    var contactTangentImpulse = contact.tangentImpulse;\n                    contact.tangentImpulse += tangentImpulse;\n                    if (contact.tangentImpulse < -maxFriction) contact.tangentImpulse = -maxFriction;\n                    if (contact.tangentImpulse > maxFriction) contact.tangentImpulse = maxFriction;\n                    tangentImpulse = contact.tangentImpulse - contactTangentImpulse;\n                }\n\n                // total impulse from contact\n                var impulseX = normalX * normalImpulse + tangentX * tangentImpulse,\n                    impulseY = normalY * normalImpulse + tangentY * tangentImpulse;\n                \n                // apply impulse from contact\n                if (!(bodyA.isStatic || bodyA.isSleeping)) {\n                    bodyA.positionPrev.x += impulseX * bodyA.inverseMass;\n                    bodyA.positionPrev.y += impulseY * bodyA.inverseMass;\n                    bodyA.anglePrev += (offsetAX * impulseY - offsetAY * impulseX) * bodyA.inverseInertia;\n                }\n\n                if (!(bodyB.isStatic || bodyB.isSleeping)) {\n                    bodyB.positionPrev.x -= impulseX * bodyB.inverseMass;\n                    bodyB.positionPrev.y -= impulseY * bodyB.inverseMass;\n                    bodyB.anglePrev -= (offsetBX * impulseY - offsetBY * impulseX) * bodyB.inverseInertia;\n                }\n            }\n        }\n    };\n\n})();\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_238208__) {\n\n/**\n* The `Matter.Pairs` module contains methods for creating and manipulating collision pair sets.\n*\n* @class Pairs\n*/\n\nvar Pairs = {};\n\nmodule.exports = Pairs;\n\nvar Pair = __nested_webpack_require_238208__(9);\nvar Common = __nested_webpack_require_238208__(0);\n\n(function() {\n\n    /**\n     * Creates a new pairs structure.\n     * @method create\n     * @param {object} options\n     * @return {pairs} A new pairs structure\n     */\n    Pairs.create = function(options) {\n        return Common.extend({ \n            table: {},\n            list: [],\n            collisionStart: [],\n            collisionActive: [],\n            collisionEnd: []\n        }, options);\n    };\n\n    /**\n     * Updates pairs given a list of collisions.\n     * @method update\n     * @param {object} pairs\n     * @param {collision[]} collisions\n     * @param {number} timestamp\n     */\n    Pairs.update = function(pairs, collisions, timestamp) {\n        var pairsList = pairs.list,\n            pairsListLength = pairsList.length,\n            pairsTable = pairs.table,\n            collisionsLength = collisions.length,\n            collisionStart = pairs.collisionStart,\n            collisionEnd = pairs.collisionEnd,\n            collisionActive = pairs.collisionActive,\n            collision,\n            pairIndex,\n            pair,\n            i;\n\n        // clear collision state arrays, but maintain old reference\n        collisionStart.length = 0;\n        collisionEnd.length = 0;\n        collisionActive.length = 0;\n\n        for (i = 0; i < pairsListLength; i++) {\n            pairsList[i].confirmedActive = false;\n        }\n\n        for (i = 0; i < collisionsLength; i++) {\n            collision = collisions[i];\n            pair = collision.pair;\n\n            if (pair) {\n                // pair already exists (but may or may not be active)\n                if (pair.isActive) {\n                    // pair exists and is active\n                    collisionActive.push(pair);\n                } else {\n                    // pair exists but was inactive, so a collision has just started again\n                    collisionStart.push(pair);\n                }\n\n                // update the pair\n                Pair.update(pair, collision, timestamp);\n                pair.confirmedActive = true;\n            } else {\n                // pair did not exist, create a new pair\n                pair = Pair.create(collision, timestamp);\n                pairsTable[pair.id] = pair;\n\n                // push the new pair\n                collisionStart.push(pair);\n                pairsList.push(pair);\n            }\n        }\n\n        // find pairs that are no longer active\n        var removePairIndex = [];\n        pairsListLength = pairsList.length;\n\n        for (i = 0; i < pairsListLength; i++) {\n            pair = pairsList[i];\n            \n            if (!pair.confirmedActive) {\n                Pair.setActive(pair, false, timestamp);\n                collisionEnd.push(pair);\n\n                if (!pair.collision.bodyA.isSleeping && !pair.collision.bodyB.isSleeping) {\n                    removePairIndex.push(i);\n                }\n            }\n        }\n\n        // remove inactive pairs\n        for (i = 0; i < removePairIndex.length; i++) {\n            pairIndex = removePairIndex[i] - i;\n            pair = pairsList[pairIndex];\n            pairsList.splice(pairIndex, 1);\n            delete pairsTable[pair.id];\n        }\n    };\n\n    /**\n     * Clears the given pairs structure.\n     * @method clear\n     * @param {pairs} pairs\n     * @return {pairs} pairs\n     */\n    Pairs.clear = function(pairs) {\n        pairs.table = {};\n        pairs.list.length = 0;\n        pairs.collisionStart.length = 0;\n        pairs.collisionActive.length = 0;\n        pairs.collisionEnd.length = 0;\n        return pairs;\n    };\n\n})();\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_242061__) {\n\nvar Matter = module.exports = __nested_webpack_require_242061__(21);\r\n\r\nMatter.Axes = __nested_webpack_require_242061__(11);\r\nMatter.Bodies = __nested_webpack_require_242061__(12);\r\nMatter.Body = __nested_webpack_require_242061__(4);\r\nMatter.Bounds = __nested_webpack_require_242061__(1);\r\nMatter.Collision = __nested_webpack_require_242061__(8);\r\nMatter.Common = __nested_webpack_require_242061__(0);\r\nMatter.Composite = __nested_webpack_require_242061__(6);\r\nMatter.Composites = __nested_webpack_require_242061__(22);\r\nMatter.Constraint = __nested_webpack_require_242061__(10);\r\nMatter.Contact = __nested_webpack_require_242061__(16);\r\nMatter.Detector = __nested_webpack_require_242061__(13);\r\nMatter.Engine = __nested_webpack_require_242061__(17);\r\nMatter.Events = __nested_webpack_require_242061__(5);\r\nMatter.Grid = __nested_webpack_require_242061__(23);\r\nMatter.Mouse = __nested_webpack_require_242061__(14);\r\nMatter.MouseConstraint = __nested_webpack_require_242061__(24);\r\nMatter.Pair = __nested_webpack_require_242061__(9);\r\nMatter.Pairs = __nested_webpack_require_242061__(19);\r\nMatter.Plugin = __nested_webpack_require_242061__(15);\r\nMatter.Query = __nested_webpack_require_242061__(25);\r\nMatter.Render = __nested_webpack_require_242061__(26);\r\nMatter.Resolver = __nested_webpack_require_242061__(18);\r\nMatter.Runner = __nested_webpack_require_242061__(27);\r\nMatter.SAT = __nested_webpack_require_242061__(28);\r\nMatter.Sleeping = __nested_webpack_require_242061__(7);\r\nMatter.Svg = __nested_webpack_require_242061__(29);\r\nMatter.Vector = __nested_webpack_require_242061__(2);\r\nMatter.Vertices = __nested_webpack_require_242061__(3);\r\nMatter.World = __nested_webpack_require_242061__(30);\r\n\r\n// temporary back compatibility\r\nMatter.Engine.run = Matter.Runner.run;\r\nMatter.Common.deprecated(Matter.Engine, 'run', 'Engine.run âž¤ use Matter.Runner.run(engine) instead');\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __nested_webpack_require_243597__) {\n\n/**\r\n* The `Matter` module is the top level namespace. It also includes a function for installing plugins on top of the library.\r\n*\r\n* @class Matter\r\n*/\r\n\r\nvar Matter = {};\r\n\r\nmodule.exports = Matter;\r\n\r\nvar Plugin = __nested_webpack_require_243597__(15);\r\nvar Common = __nested_webpack_require_243597__(0);\r\n\r\n(function() {\r\n\r\n    /**\r\n     * The library name.\r\n     * @property name\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.name = 'matter-js';\r\n\r\n    /**\r\n     * The library version.\r\n     * @property version\r\n     * @readOnly\r\n     * @type {String}\r\n     */\r\n    Matter.version =   true ? \"0.19.0\" : 0;\r\n\r\n    /**\r\n     * A list of plugin dependencies to be installed. These are normally set and installed through `Matter.use`.\r\n     * Alternatively you may set `Matter.uses` manually and install them by calling `Plugin.use(Matter)`.\r\n     * @property uses\r\n     * @type {Array}\r\n     */\r\n    Matter.uses = [];\r\n\r\n    /**\r\n     * The plugins that have been installed through `Matter.Plugin.install`. Read only.\r\n     * @property used\r\n     * @readOnly\r\n     * @type {Array}\r\n     */\r\n    Matter.used = [];\r\n\r\n    /**\r\n     * Installs the given plugins on the `Matter` namespace.\r\n     * This is a short-hand for `Plugin.use`, see it for more information.\r\n     * Call this function once at the start of your code, with all of the plugins you wish to install as arguments.\r\n     * Avoid calling this function multiple times unless you intend to manually control installation order.\r\n     * @method use\r\n     * @param ...plugin {Function} The plugin(s) to install on `base` (multi-argument).\r\n     */\r\n    Matter.use = function() {\r\n        Plugin.use(Matter, Array.prototype.slice.call(arguments));\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute before the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method before\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain before the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.before = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathBefore(Matter, path, func);\r\n    };\r\n\r\n    /**\r\n     * Chains a function to excute after the original function on the given `path` relative to `Matter`.\r\n     * See also docs for `Common.chain`.\r\n     * @method after\r\n     * @param {string} path The path relative to `Matter`\r\n     * @param {function} func The function to chain after the original\r\n     * @return {function} The chained function that replaced the original\r\n     */\r\n    Matter.after = function(path, func) {\r\n        path = path.replace(/^Matter./, '');\r\n        return Common.chainPathAfter(Matter, path, func);\r\n    };\r\n\r\n})();\r\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __nested_webpack_require_246505__) {\n\n/**\n* The `Matter.Composites` module contains factory methods for creating composite bodies\n* with commonly used configurations (such as stacks and chains).\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Composites\n*/\n\nvar Composites = {};\n\nmodule.exports = Composites;\n\nvar Composite = __nested_webpack_require_246505__(6);\nvar Constraint = __nested_webpack_require_246505__(10);\nvar Common = __nested_webpack_require_246505__(0);\nvar Body = __nested_webpack_require_246505__(4);\nvar Bodies = __nested_webpack_require_246505__(12);\nvar deprecated = Common.deprecated;\n\n(function() {\n\n    /**\n     * Create a new composite containing bodies created in the callback in a grid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method stack\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.stack = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n        var stack = Composite.create({ label: 'Stack' }),\n            x = xx,\n            y = yy,\n            lastBody,\n            i = 0;\n\n        for (var row = 0; row < rows; row++) {\n            var maxHeight = 0;\n            \n            for (var column = 0; column < columns; column++) {\n                var body = callback(x, y, column, row, lastBody, i);\n                    \n                if (body) {\n                    var bodyHeight = body.bounds.max.y - body.bounds.min.y,\n                        bodyWidth = body.bounds.max.x - body.bounds.min.x; \n\n                    if (bodyHeight > maxHeight)\n                        maxHeight = bodyHeight;\n                    \n                    Body.translate(body, { x: bodyWidth * 0.5, y: bodyHeight * 0.5 });\n\n                    x = body.bounds.max.x + columnGap;\n\n                    Composite.addBody(stack, body);\n                    \n                    lastBody = body;\n                    i += 1;\n                } else {\n                    x += columnGap;\n                }\n            }\n            \n            y += maxHeight + rowGap;\n            x = xx;\n        }\n\n        return stack;\n    };\n    \n    /**\n     * Chains all bodies in the given composite together using constraints.\n     * @method chain\n     * @param {composite} composite\n     * @param {number} xOffsetA\n     * @param {number} yOffsetA\n     * @param {number} xOffsetB\n     * @param {number} yOffsetB\n     * @param {object} options\n     * @return {composite} A new composite containing objects chained together with constraints\n     */\n    Composites.chain = function(composite, xOffsetA, yOffsetA, xOffsetB, yOffsetB, options) {\n        var bodies = composite.bodies;\n        \n        for (var i = 1; i < bodies.length; i++) {\n            var bodyA = bodies[i - 1],\n                bodyB = bodies[i],\n                bodyAHeight = bodyA.bounds.max.y - bodyA.bounds.min.y,\n                bodyAWidth = bodyA.bounds.max.x - bodyA.bounds.min.x, \n                bodyBHeight = bodyB.bounds.max.y - bodyB.bounds.min.y,\n                bodyBWidth = bodyB.bounds.max.x - bodyB.bounds.min.x;\n        \n            var defaults = {\n                bodyA: bodyA,\n                pointA: { x: bodyAWidth * xOffsetA, y: bodyAHeight * yOffsetA },\n                bodyB: bodyB,\n                pointB: { x: bodyBWidth * xOffsetB, y: bodyBHeight * yOffsetB }\n            };\n            \n            var constraint = Common.extend(defaults, options);\n        \n            Composite.addConstraint(composite, Constraint.create(constraint));\n        }\n\n        composite.label += ' Chain';\n        \n        return composite;\n    };\n\n    /**\n     * Connects bodies in the composite with constraints in a grid pattern, with optional cross braces.\n     * @method mesh\n     * @param {composite} composite\n     * @param {number} columns\n     * @param {number} rows\n     * @param {boolean} crossBrace\n     * @param {object} options\n     * @return {composite} The composite containing objects meshed together with constraints\n     */\n    Composites.mesh = function(composite, columns, rows, crossBrace, options) {\n        var bodies = composite.bodies,\n            row,\n            col,\n            bodyA,\n            bodyB,\n            bodyC;\n        \n        for (row = 0; row < rows; row++) {\n            for (col = 1; col < columns; col++) {\n                bodyA = bodies[(col - 1) + (row * columns)];\n                bodyB = bodies[col + (row * columns)];\n                Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n            }\n\n            if (row > 0) {\n                for (col = 0; col < columns; col++) {\n                    bodyA = bodies[col + ((row - 1) * columns)];\n                    bodyB = bodies[col + (row * columns)];\n                    Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyA, bodyB: bodyB }, options)));\n\n                    if (crossBrace && col > 0) {\n                        bodyC = bodies[(col - 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n\n                    if (crossBrace && col < columns - 1) {\n                        bodyC = bodies[(col + 1) + ((row - 1) * columns)];\n                        Composite.addConstraint(composite, Constraint.create(Common.extend({ bodyA: bodyC, bodyB: bodyB }, options)));\n                    }\n                }\n            }\n        }\n\n        composite.label += ' Mesh';\n        \n        return composite;\n    };\n    \n    /**\n     * Create a new composite containing bodies created in the callback in a pyramid arrangement.\n     * This function uses the body's bounds to prevent overlaps.\n     * @method pyramid\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {function} callback\n     * @return {composite} A new composite containing objects created in the callback\n     */\n    Composites.pyramid = function(xx, yy, columns, rows, columnGap, rowGap, callback) {\n        return Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y, column, row, lastBody, i) {\n            var actualRows = Math.min(rows, Math.ceil(columns / 2)),\n                lastBodyWidth = lastBody ? lastBody.bounds.max.x - lastBody.bounds.min.x : 0;\n            \n            if (row > actualRows)\n                return;\n            \n            // reverse row order\n            row = actualRows - row;\n            \n            var start = row,\n                end = columns - 1 - row;\n\n            if (column < start || column > end)\n                return;\n            \n            // retroactively fix the first body's position, since width was unknown\n            if (i === 1) {\n                Body.translate(lastBody, { x: (column + (columns % 2 === 1 ? 1 : -1)) * lastBodyWidth, y: 0 });\n            }\n\n            var xOffset = lastBody ? column * lastBodyWidth : 0;\n            \n            return callback(xx + xOffset + column * columnGap, y, column, row, lastBody, i);\n        });\n    };\n\n    /**\n     * This has now moved to the [newtonsCradle example](https://github.com/liabru/matter-js/blob/master/examples/newtonsCradle.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to newtonsCradle example\n     * @method newtonsCradle\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} number\n     * @param {number} size\n     * @param {number} length\n     * @return {composite} A new composite newtonsCradle body\n     */\n    Composites.newtonsCradle = function(xx, yy, number, size, length) {\n        var newtonsCradle = Composite.create({ label: 'Newtons Cradle' });\n\n        for (var i = 0; i < number; i++) {\n            var separation = 1.9,\n                circle = Bodies.circle(xx + i * (size * separation), yy + length, size, \n                    { inertia: Infinity, restitution: 1, friction: 0, frictionAir: 0.0001, slop: 1 }),\n                constraint = Constraint.create({ pointA: { x: xx + i * (size * separation), y: yy }, bodyB: circle });\n\n            Composite.addBody(newtonsCradle, circle);\n            Composite.addConstraint(newtonsCradle, constraint);\n        }\n\n        return newtonsCradle;\n    };\n\n    deprecated(Composites, 'newtonsCradle', 'Composites.newtonsCradle âž¤ moved to newtonsCradle example');\n    \n    /**\n     * This has now moved to the [car example](https://github.com/liabru/matter-js/blob/master/examples/car.js), follow that instead as this function is deprecated here.\n     * @deprecated moved to car example\n     * @method car\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} width\n     * @param {number} height\n     * @param {number} wheelSize\n     * @return {composite} A new composite car body\n     */\n    Composites.car = function(xx, yy, width, height, wheelSize) {\n        var group = Body.nextGroup(true),\n            wheelBase = 20,\n            wheelAOffset = -width * 0.5 + wheelBase,\n            wheelBOffset = width * 0.5 - wheelBase,\n            wheelYOffset = 0;\n    \n        var car = Composite.create({ label: 'Car' }),\n            body = Bodies.rectangle(xx, yy, width, height, { \n                collisionFilter: {\n                    group: group\n                },\n                chamfer: {\n                    radius: height * 0.5\n                },\n                density: 0.0002\n            });\n    \n        var wheelA = Bodies.circle(xx + wheelAOffset, yy + wheelYOffset, wheelSize, { \n            collisionFilter: {\n                group: group\n            },\n            friction: 0.8\n        });\n                    \n        var wheelB = Bodies.circle(xx + wheelBOffset, yy + wheelYOffset, wheelSize, { \n            collisionFilter: {\n                group: group\n            },\n            friction: 0.8\n        });\n                    \n        var axelA = Constraint.create({\n            bodyB: body,\n            pointB: { x: wheelAOffset, y: wheelYOffset },\n            bodyA: wheelA,\n            stiffness: 1,\n            length: 0\n        });\n                        \n        var axelB = Constraint.create({\n            bodyB: body,\n            pointB: { x: wheelBOffset, y: wheelYOffset },\n            bodyA: wheelB,\n            stiffness: 1,\n            length: 0\n        });\n        \n        Composite.addBody(car, body);\n        Composite.addBody(car, wheelA);\n        Composite.addBody(car, wheelB);\n        Composite.addConstraint(car, axelA);\n        Composite.addConstraint(car, axelB);\n\n        return car;\n    };\n\n    deprecated(Composites, 'car', 'Composites.car âž¤ moved to car example');\n\n    /**\n     * This has now moved to the [softBody example](https://github.com/liabru/matter-js/blob/master/examples/softBody.js)\n     * and the [cloth example](https://github.com/liabru/matter-js/blob/master/examples/cloth.js), follow those instead as this function is deprecated here.\n     * @deprecated moved to softBody and cloth examples\n     * @method softBody\n     * @param {number} xx\n     * @param {number} yy\n     * @param {number} columns\n     * @param {number} rows\n     * @param {number} columnGap\n     * @param {number} rowGap\n     * @param {boolean} crossBrace\n     * @param {number} particleRadius\n     * @param {} particleOptions\n     * @param {} constraintOptions\n     * @return {composite} A new composite softBody\n     */\n    Composites.softBody = function(xx, yy, columns, rows, columnGap, rowGap, crossBrace, particleRadius, particleOptions, constraintOptions) {\n        particleOptions = Common.extend({ inertia: Infinity }, particleOptions);\n        constraintOptions = Common.extend({ stiffness: 0.2, render: { type: 'line', anchors: false } }, constraintOptions);\n\n        var softBody = Composites.stack(xx, yy, columns, rows, columnGap, rowGap, function(x, y) {\n            return Bodies.circle(x, y, particleRadius, particleOptions);\n        });\n\n        Composites.mesh(softBody, columns, rows, crossBrace, constraintOptions);\n\n        softBody.label = 'Soft Body';\n\n        return softBody;\n    };\n\n    deprecated(Composites, 'softBody', 'Composites.softBody âž¤ moved to softBody and cloth examples');\n})();\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __nested_webpack_require_259115__) {\n\n/**\n* This module has now been replaced by `Matter.Detector`.\n*\n* All usage should be migrated to `Matter.Detector` or another alternative.\n* For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n*\n* The `Matter.Grid` module contains methods for creating and manipulating collision broadphase grid structures.\n*\n* @class Grid\n* @deprecated\n*/\n\nvar Grid = {};\n\nmodule.exports = Grid;\n\nvar Pair = __nested_webpack_require_259115__(9);\nvar Common = __nested_webpack_require_259115__(0);\nvar deprecated = Common.deprecated;\n\n(function() {\n\n    /**\n     * Creates a new grid.\n     * @deprecated replaced by Matter.Detector\n     * @method create\n     * @param {} options\n     * @return {grid} A new grid\n     */\n    Grid.create = function(options) {\n        var defaults = {\n            buckets: {},\n            pairs: {},\n            pairsList: [],\n            bucketWidth: 48,\n            bucketHeight: 48\n        };\n\n        return Common.extend(defaults, options);\n    };\n\n    /**\n     * The width of a single grid bucket.\n     *\n     * @property bucketWidth\n     * @type number\n     * @default 48\n     */\n\n    /**\n     * The height of a single grid bucket.\n     *\n     * @property bucketHeight\n     * @type number\n     * @default 48\n     */\n\n    /**\n     * Updates the grid.\n     * @deprecated replaced by Matter.Detector\n     * @method update\n     * @param {grid} grid\n     * @param {body[]} bodies\n     * @param {engine} engine\n     * @param {boolean} forceUpdate\n     */\n    Grid.update = function(grid, bodies, engine, forceUpdate) {\n        var i, col, row,\n            world = engine.world,\n            buckets = grid.buckets,\n            bucket,\n            bucketId,\n            gridChanged = false;\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.isSleeping && !forceUpdate)\n                continue;\n\n            // temporary back compatibility bounds check\n            if (world.bounds && (body.bounds.max.x < world.bounds.min.x || body.bounds.min.x > world.bounds.max.x\n                || body.bounds.max.y < world.bounds.min.y || body.bounds.min.y > world.bounds.max.y))\n                continue;\n\n            var newRegion = Grid._getRegion(grid, body);\n\n            // if the body has changed grid region\n            if (!body.region || newRegion.id !== body.region.id || forceUpdate) {\n\n                if (!body.region || forceUpdate)\n                    body.region = newRegion;\n\n                var union = Grid._regionUnion(newRegion, body.region);\n\n                // update grid buckets affected by region change\n                // iterate over the union of both regions\n                for (col = union.startCol; col <= union.endCol; col++) {\n                    for (row = union.startRow; row <= union.endRow; row++) {\n                        bucketId = Grid._getBucketId(col, row);\n                        bucket = buckets[bucketId];\n\n                        var isInsideNewRegion = (col >= newRegion.startCol && col <= newRegion.endCol\n                                                && row >= newRegion.startRow && row <= newRegion.endRow);\n\n                        var isInsideOldRegion = (col >= body.region.startCol && col <= body.region.endCol\n                                                && row >= body.region.startRow && row <= body.region.endRow);\n\n                        // remove from old region buckets\n                        if (!isInsideNewRegion && isInsideOldRegion) {\n                            if (isInsideOldRegion) {\n                                if (bucket)\n                                    Grid._bucketRemoveBody(grid, bucket, body);\n                            }\n                        }\n\n                        // add to new region buckets\n                        if (body.region === newRegion || (isInsideNewRegion && !isInsideOldRegion) || forceUpdate) {\n                            if (!bucket)\n                                bucket = Grid._createBucket(buckets, bucketId);\n                            Grid._bucketAddBody(grid, bucket, body);\n                        }\n                    }\n                }\n\n                // set the new region\n                body.region = newRegion;\n\n                // flag changes so we can update pairs\n                gridChanged = true;\n            }\n        }\n\n        // update pairs list only if pairs changed (i.e. a body changed region)\n        if (gridChanged)\n            grid.pairsList = Grid._createActivePairsList(grid);\n    };\n\n    deprecated(Grid, 'update', 'Grid.update âž¤ replaced by Matter.Detector');\n\n    /**\n     * Clears the grid.\n     * @deprecated replaced by Matter.Detector\n     * @method clear\n     * @param {grid} grid\n     */\n    Grid.clear = function(grid) {\n        grid.buckets = {};\n        grid.pairs = {};\n        grid.pairsList = [];\n    };\n\n    deprecated(Grid, 'clear', 'Grid.clear âž¤ replaced by Matter.Detector');\n\n    /**\n     * Finds the union of two regions.\n     * @method _regionUnion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} regionA\n     * @param {} regionB\n     * @return {} region\n     */\n    Grid._regionUnion = function(regionA, regionB) {\n        var startCol = Math.min(regionA.startCol, regionB.startCol),\n            endCol = Math.max(regionA.endCol, regionB.endCol),\n            startRow = Math.min(regionA.startRow, regionB.startRow),\n            endRow = Math.max(regionA.endRow, regionB.endRow);\n\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Gets the region a given body falls in for a given grid.\n     * @method _getRegion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} body\n     * @return {} region\n     */\n    Grid._getRegion = function(grid, body) {\n        var bounds = body.bounds,\n            startCol = Math.floor(bounds.min.x / grid.bucketWidth),\n            endCol = Math.floor(bounds.max.x / grid.bucketWidth),\n            startRow = Math.floor(bounds.min.y / grid.bucketHeight),\n            endRow = Math.floor(bounds.max.y / grid.bucketHeight);\n\n        return Grid._createRegion(startCol, endCol, startRow, endRow);\n    };\n\n    /**\n     * Creates a region.\n     * @method _createRegion\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} startCol\n     * @param {} endCol\n     * @param {} startRow\n     * @param {} endRow\n     * @return {} region\n     */\n    Grid._createRegion = function(startCol, endCol, startRow, endRow) {\n        return { \n            id: startCol + ',' + endCol + ',' + startRow + ',' + endRow,\n            startCol: startCol, \n            endCol: endCol, \n            startRow: startRow, \n            endRow: endRow \n        };\n    };\n\n    /**\n     * Gets the bucket id at the given position.\n     * @method _getBucketId\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} column\n     * @param {} row\n     * @return {string} bucket id\n     */\n    Grid._getBucketId = function(column, row) {\n        return 'C' + column + 'R' + row;\n    };\n\n    /**\n     * Creates a bucket.\n     * @method _createBucket\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} buckets\n     * @param {} bucketId\n     * @return {} bucket\n     */\n    Grid._createBucket = function(buckets, bucketId) {\n        var bucket = buckets[bucketId] = [];\n        return bucket;\n    };\n\n    /**\n     * Adds a body to a bucket.\n     * @method _bucketAddBody\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    Grid._bucketAddBody = function(grid, bucket, body) {\n        var gridPairs = grid.pairs,\n            pairId = Pair.id,\n            bucketLength = bucket.length,\n            i;\n\n        // add new pairs\n        for (i = 0; i < bucketLength; i++) {\n            var bodyB = bucket[i];\n\n            if (body.id === bodyB.id || (body.isStatic && bodyB.isStatic))\n                continue;\n\n            // keep track of the number of buckets the pair exists in\n            // important for Grid.update to work\n            var id = pairId(body, bodyB),\n                pair = gridPairs[id];\n\n            if (pair) {\n                pair[2] += 1;\n            } else {\n                gridPairs[id] = [body, bodyB, 1];\n            }\n        }\n\n        // add to bodies (after pairs, otherwise pairs with self)\n        bucket.push(body);\n    };\n\n    /**\n     * Removes a body from a bucket.\n     * @method _bucketRemoveBody\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @param {} bucket\n     * @param {} body\n     */\n    Grid._bucketRemoveBody = function(grid, bucket, body) {\n        var gridPairs = grid.pairs,\n            pairId = Pair.id,\n            i;\n\n        // remove from bucket\n        bucket.splice(Common.indexOf(bucket, body), 1);\n\n        var bucketLength = bucket.length;\n\n        // update pair counts\n        for (i = 0; i < bucketLength; i++) {\n            // keep track of the number of buckets the pair exists in\n            // important for _createActivePairsList to work\n            var pair = gridPairs[pairId(body, bucket[i])];\n\n            if (pair)\n                pair[2] -= 1;\n        }\n    };\n\n    /**\n     * Generates a list of the active pairs in the grid.\n     * @method _createActivePairsList\n     * @deprecated replaced by Matter.Detector\n     * @private\n     * @param {} grid\n     * @return [] pairs\n     */\n    Grid._createActivePairsList = function(grid) {\n        var pair,\n            gridPairs = grid.pairs,\n            pairKeys = Common.keys(gridPairs),\n            pairKeysLength = pairKeys.length,\n            pairs = [],\n            k;\n\n        // iterate over grid.pairs\n        for (k = 0; k < pairKeysLength; k++) {\n            pair = gridPairs[pairKeys[k]];\n\n            // if pair exists in at least one bucket\n            // it is a pair that needs further collision testing so push it\n            if (pair[2] > 0) {\n                pairs.push(pair);\n            } else {\n                delete gridPairs[pairKeys[k]];\n            }\n        }\n\n        return pairs;\n    };\n    \n})();\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __nested_webpack_require_269445__) {\n\n/**\n* The `Matter.MouseConstraint` module contains methods for creating mouse constraints.\n* Mouse constraints are used for allowing user interaction, providing the ability to move bodies via the mouse or touch.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class MouseConstraint\n*/\n\nvar MouseConstraint = {};\n\nmodule.exports = MouseConstraint;\n\nvar Vertices = __nested_webpack_require_269445__(3);\nvar Sleeping = __nested_webpack_require_269445__(7);\nvar Mouse = __nested_webpack_require_269445__(14);\nvar Events = __nested_webpack_require_269445__(5);\nvar Detector = __nested_webpack_require_269445__(13);\nvar Constraint = __nested_webpack_require_269445__(10);\nvar Composite = __nested_webpack_require_269445__(6);\nvar Common = __nested_webpack_require_269445__(0);\nvar Bounds = __nested_webpack_require_269445__(1);\n\n(function() {\n\n    /**\n     * Creates a new mouse constraint.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {engine} engine\n     * @param {} options\n     * @return {MouseConstraint} A new MouseConstraint\n     */\n    MouseConstraint.create = function(engine, options) {\n        var mouse = (engine ? engine.mouse : null) || (options ? options.mouse : null);\n\n        if (!mouse) {\n            if (engine && engine.render && engine.render.canvas) {\n                mouse = Mouse.create(engine.render.canvas);\n            } else if (options && options.element) {\n                mouse = Mouse.create(options.element);\n            } else {\n                mouse = Mouse.create();\n                Common.warn('MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected');\n            }\n        }\n\n        var constraint = Constraint.create({ \n            label: 'Mouse Constraint',\n            pointA: mouse.position,\n            pointB: { x: 0, y: 0 },\n            length: 0.01, \n            stiffness: 0.1,\n            angularStiffness: 1,\n            render: {\n                strokeStyle: '#90EE90',\n                lineWidth: 3\n            }\n        });\n\n        var defaults = {\n            type: 'mouseConstraint',\n            mouse: mouse,\n            element: null,\n            body: null,\n            constraint: constraint,\n            collisionFilter: {\n                category: 0x0001,\n                mask: 0xFFFFFFFF,\n                group: 0\n            }\n        };\n\n        var mouseConstraint = Common.extend(defaults, options);\n\n        Events.on(engine, 'beforeUpdate', function() {\n            var allBodies = Composite.allBodies(engine.world);\n            MouseConstraint.update(mouseConstraint, allBodies);\n            MouseConstraint._triggerEvents(mouseConstraint);\n        });\n\n        return mouseConstraint;\n    };\n\n    /**\n     * Updates the given mouse constraint.\n     * @private\n     * @method update\n     * @param {MouseConstraint} mouseConstraint\n     * @param {body[]} bodies\n     */\n    MouseConstraint.update = function(mouseConstraint, bodies) {\n        var mouse = mouseConstraint.mouse,\n            constraint = mouseConstraint.constraint,\n            body = mouseConstraint.body;\n\n        if (mouse.button === 0) {\n            if (!constraint.bodyB) {\n                for (var i = 0; i < bodies.length; i++) {\n                    body = bodies[i];\n                    if (Bounds.contains(body.bounds, mouse.position) \n                            && Detector.canCollide(body.collisionFilter, mouseConstraint.collisionFilter)) {\n                        for (var j = body.parts.length > 1 ? 1 : 0; j < body.parts.length; j++) {\n                            var part = body.parts[j];\n                            if (Vertices.contains(part.vertices, mouse.position)) {\n                                constraint.pointA = mouse.position;\n                                constraint.bodyB = mouseConstraint.body = body;\n                                constraint.pointB = { x: mouse.position.x - body.position.x, y: mouse.position.y - body.position.y };\n                                constraint.angleB = body.angle;\n\n                                Sleeping.set(body, false);\n                                Events.trigger(mouseConstraint, 'startdrag', { mouse: mouse, body: body });\n\n                                break;\n                            }\n                        }\n                    }\n                }\n            } else {\n                Sleeping.set(constraint.bodyB, false);\n                constraint.pointA = mouse.position;\n            }\n        } else {\n            constraint.bodyB = mouseConstraint.body = null;\n            constraint.pointB = null;\n\n            if (body)\n                Events.trigger(mouseConstraint, 'enddrag', { mouse: mouse, body: body });\n        }\n    };\n\n    /**\n     * Triggers mouse constraint events.\n     * @method _triggerEvents\n     * @private\n     * @param {mouse} mouseConstraint\n     */\n    MouseConstraint._triggerEvents = function(mouseConstraint) {\n        var mouse = mouseConstraint.mouse,\n            mouseEvents = mouse.sourceEvents;\n\n        if (mouseEvents.mousemove)\n            Events.trigger(mouseConstraint, 'mousemove', { mouse: mouse });\n\n        if (mouseEvents.mousedown)\n            Events.trigger(mouseConstraint, 'mousedown', { mouse: mouse });\n\n        if (mouseEvents.mouseup)\n            Events.trigger(mouseConstraint, 'mouseup', { mouse: mouse });\n\n        // reset the mouse state ready for the next step\n        Mouse.clearSourceEvents(mouse);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired when the mouse has moved (or a touch moves) during the last step\n    *\n    * @event mousemove\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is down (or a touch has started) during the last step\n    *\n    * @event mousedown\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the mouse is up (or a touch has ended) during the last step\n    *\n    * @event mouseup\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user starts dragging a body\n    *\n    * @event startdrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired when the user ends dragging a body\n    *\n    * @event enddrag\n    * @param {} event An event object\n    * @param {mouse} event.mouse The engine's mouse instance\n    * @param {body} event.body The body that has stopped being dragged\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A `String` denoting the type of object.\n     *\n     * @property type\n     * @type string\n     * @default \"constraint\"\n     * @readOnly\n     */\n\n    /**\n     * The `Mouse` instance in use. If not supplied in `MouseConstraint.create`, one will be created.\n     *\n     * @property mouse\n     * @type mouse\n     * @default mouse\n     */\n\n    /**\n     * The `Body` that is currently being moved by the user, or `null` if no body.\n     *\n     * @property body\n     * @type body\n     * @default null\n     */\n\n    /**\n     * The `Constraint` object that is used to move the body during interaction.\n     *\n     * @property constraint\n     * @type constraint\n     */\n\n    /**\n     * An `Object` that specifies the collision filter properties.\n     * The collision filter allows the user to define which types of body this mouse constraint can interact with.\n     * See `body.collisionFilter` for more information.\n     *\n     * @property collisionFilter\n     * @type object\n     */\n\n})();\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __nested_webpack_require_277940__) {\n\n/**\n* The `Matter.Query` module contains methods for performing collision queries.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Query\n*/\n\nvar Query = {};\n\nmodule.exports = Query;\n\nvar Vector = __nested_webpack_require_277940__(2);\nvar Collision = __nested_webpack_require_277940__(8);\nvar Bounds = __nested_webpack_require_277940__(1);\nvar Bodies = __nested_webpack_require_277940__(12);\nvar Vertices = __nested_webpack_require_277940__(3);\n\n(function() {\n\n    /**\n     * Returns a list of collisions between `body` and `bodies`.\n     * @method collides\n     * @param {body} body\n     * @param {body[]} bodies\n     * @return {collision[]} Collisions\n     */\n    Query.collides = function(body, bodies) {\n        var collisions = [],\n            bodiesLength = bodies.length,\n            bounds = body.bounds,\n            collides = Collision.collides,\n            overlaps = Bounds.overlaps;\n\n        for (var i = 0; i < bodiesLength; i++) {\n            var bodyA = bodies[i],\n                partsALength = bodyA.parts.length,\n                partsAStart = partsALength === 1 ? 0 : 1;\n            \n            if (overlaps(bodyA.bounds, bounds)) {\n                for (var j = partsAStart; j < partsALength; j++) {\n                    var part = bodyA.parts[j];\n\n                    if (overlaps(part.bounds, bounds)) {\n                        var collision = collides(part, body);\n\n                        if (collision) {\n                            collisions.push(collision);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return collisions;\n    };\n\n    /**\n     * Casts a ray segment against a set of bodies and returns all collisions, ray width is optional. Intersection points are not provided.\n     * @method ray\n     * @param {body[]} bodies\n     * @param {vector} startPoint\n     * @param {vector} endPoint\n     * @param {number} [rayWidth]\n     * @return {collision[]} Collisions\n     */\n    Query.ray = function(bodies, startPoint, endPoint, rayWidth) {\n        rayWidth = rayWidth || 1e-100;\n\n        var rayAngle = Vector.angle(startPoint, endPoint),\n            rayLength = Vector.magnitude(Vector.sub(startPoint, endPoint)),\n            rayX = (endPoint.x + startPoint.x) * 0.5,\n            rayY = (endPoint.y + startPoint.y) * 0.5,\n            ray = Bodies.rectangle(rayX, rayY, rayLength, rayWidth, { angle: rayAngle }),\n            collisions = Query.collides(ray, bodies);\n\n        for (var i = 0; i < collisions.length; i += 1) {\n            var collision = collisions[i];\n            collision.body = collision.bodyB = collision.bodyA;            \n        }\n\n        return collisions;\n    };\n\n    /**\n     * Returns all bodies whose bounds are inside (or outside if set) the given set of bounds, from the given set of bodies.\n     * @method region\n     * @param {body[]} bodies\n     * @param {bounds} bounds\n     * @param {bool} [outside=false]\n     * @return {body[]} The bodies matching the query\n     */\n    Query.region = function(bodies, bounds, outside) {\n        var result = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                overlaps = Bounds.overlaps(body.bounds, bounds);\n            if ((overlaps && !outside) || (!overlaps && outside))\n                result.push(body);\n        }\n\n        return result;\n    };\n\n    /**\n     * Returns all bodies whose vertices contain the given point, from the given set of bodies.\n     * @method point\n     * @param {body[]} bodies\n     * @param {vector} point\n     * @return {body[]} The bodies matching the query\n     */\n    Query.point = function(bodies, point) {\n        var result = [];\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n            \n            if (Bounds.contains(body.bounds, point)) {\n                for (var j = body.parts.length === 1 ? 0 : 1; j < body.parts.length; j++) {\n                    var part = body.parts[j];\n\n                    if (Bounds.contains(part.bounds, point)\n                        && Vertices.contains(part.vertices, point)) {\n                        result.push(body);\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n})();\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __nested_webpack_require_282315__) {\n\n/**\n* The `Matter.Render` module is a simple canvas based renderer for visualising instances of `Matter.Engine`.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* It includes a number of drawing options including wireframe, vector with support for sprites and viewports.\n*\n* @class Render\n*/\n\nvar Render = {};\n\nmodule.exports = Render;\n\nvar Body = __nested_webpack_require_282315__(4);\nvar Common = __nested_webpack_require_282315__(0);\nvar Composite = __nested_webpack_require_282315__(6);\nvar Bounds = __nested_webpack_require_282315__(1);\nvar Events = __nested_webpack_require_282315__(5);\nvar Vector = __nested_webpack_require_282315__(2);\nvar Mouse = __nested_webpack_require_282315__(14);\n\n(function() {\n\n    var _requestAnimationFrame,\n        _cancelAnimationFrame;\n\n    if (typeof window !== 'undefined') {\n        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame\n                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame\n                                      || function(callback){ window.setTimeout(function() { callback(Common.now()); }, 1000 / 60); };\n\n        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame\n                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n    }\n\n    Render._goodFps = 30;\n    Render._goodDelta = 1000 / 60;\n\n    /**\n     * Creates a new renderer. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * All properties have default values, and many are pre-calculated automatically based on other properties.\n     * See the properties section below for detailed information on what you can pass via the `options` object.\n     * @method create\n     * @param {object} [options]\n     * @return {render} A new renderer\n     */\n    Render.create = function(options) {\n        var defaults = {\n            engine: null,\n            element: null,\n            canvas: null,\n            mouse: null,\n            frameRequestId: null,\n            timing: {\n                historySize: 60,\n                delta: 0,\n                deltaHistory: [],\n                lastTime: 0,\n                lastTimestamp: 0,\n                lastElapsed: 0,\n                timestampElapsed: 0,\n                timestampElapsedHistory: [],\n                engineDeltaHistory: [],\n                engineElapsedHistory: [],\n                elapsedHistory: []\n            },\n            options: {\n                width: 800,\n                height: 600,\n                pixelRatio: 1,\n                background: '#14151f',\n                wireframeBackground: '#14151f',\n                hasBounds: !!options.bounds,\n                enabled: true,\n                wireframes: true,\n                showSleeping: true,\n                showDebug: false,\n                showStats: false,\n                showPerformance: false,\n                showBounds: false,\n                showVelocity: false,\n                showCollisions: false,\n                showSeparations: false,\n                showAxes: false,\n                showPositions: false,\n                showAngleIndicator: false,\n                showIds: false,\n                showVertexNumbers: false,\n                showConvexHulls: false,\n                showInternalEdges: false,\n                showMousePosition: false\n            }\n        };\n\n        var render = Common.extend(defaults, options);\n\n        if (render.canvas) {\n            render.canvas.width = render.options.width || render.canvas.width;\n            render.canvas.height = render.options.height || render.canvas.height;\n        }\n\n        render.mouse = options.mouse;\n        render.engine = options.engine;\n        render.canvas = render.canvas || _createCanvas(render.options.width, render.options.height);\n        render.context = render.canvas.getContext('2d');\n        render.textures = {};\n\n        render.bounds = render.bounds || {\n            min: {\n                x: 0,\n                y: 0\n            },\n            max: {\n                x: render.canvas.width,\n                y: render.canvas.height\n            }\n        };\n\n        // for temporary back compatibility only\n        render.controller = Render;\n        render.options.showBroadphase = false;\n\n        if (render.options.pixelRatio !== 1) {\n            Render.setPixelRatio(render, render.options.pixelRatio);\n        }\n\n        if (Common.isElement(render.element)) {\n            render.element.appendChild(render.canvas);\n        }\n\n        return render;\n    };\n\n    /**\n     * Continuously updates the render canvas on the `requestAnimationFrame` event.\n     * @method run\n     * @param {render} render\n     */\n    Render.run = function(render) {\n        (function loop(time){\n            render.frameRequestId = _requestAnimationFrame(loop);\n            \n            _updateTiming(render, time);\n\n            Render.world(render, time);\n\n            if (render.options.showStats || render.options.showDebug) {\n                Render.stats(render, render.context, time);\n            }\n\n            if (render.options.showPerformance || render.options.showDebug) {\n                Render.performance(render, render.context, time);\n            }\n        })();\n    };\n\n    /**\n     * Ends execution of `Render.run` on the given `render`, by canceling the animation frame request event loop.\n     * @method stop\n     * @param {render} render\n     */\n    Render.stop = function(render) {\n        _cancelAnimationFrame(render.frameRequestId);\n    };\n\n    /**\n     * Sets the pixel ratio of the renderer and updates the canvas.\n     * To automatically detect the correct ratio, pass the string `'auto'` for `pixelRatio`.\n     * @method setPixelRatio\n     * @param {render} render\n     * @param {number} pixelRatio\n     */\n    Render.setPixelRatio = function(render, pixelRatio) {\n        var options = render.options,\n            canvas = render.canvas;\n\n        if (pixelRatio === 'auto') {\n            pixelRatio = _getPixelRatio(canvas);\n        }\n\n        options.pixelRatio = pixelRatio;\n        canvas.setAttribute('data-pixel-ratio', pixelRatio);\n        canvas.width = options.width * pixelRatio;\n        canvas.height = options.height * pixelRatio;\n        canvas.style.width = options.width + 'px';\n        canvas.style.height = options.height + 'px';\n    };\n\n    /**\n     * Positions and sizes the viewport around the given object bounds.\n     * Objects must have at least one of the following properties:\n     * - `object.bounds`\n     * - `object.position`\n     * - `object.min` and `object.max`\n     * - `object.x` and `object.y`\n     * @method lookAt\n     * @param {render} render\n     * @param {object[]} objects\n     * @param {vector} [padding]\n     * @param {bool} [center=true]\n     */\n    Render.lookAt = function(render, objects, padding, center) {\n        center = typeof center !== 'undefined' ? center : true;\n        objects = Common.isArray(objects) ? objects : [objects];\n        padding = padding || {\n            x: 0,\n            y: 0\n        };\n\n        // find bounds of all objects\n        var bounds = {\n            min: { x: Infinity, y: Infinity },\n            max: { x: -Infinity, y: -Infinity }\n        };\n\n        for (var i = 0; i < objects.length; i += 1) {\n            var object = objects[i],\n                min = object.bounds ? object.bounds.min : (object.min || object.position || object),\n                max = object.bounds ? object.bounds.max : (object.max || object.position || object);\n\n            if (min && max) {\n                if (min.x < bounds.min.x)\n                    bounds.min.x = min.x;\n\n                if (max.x > bounds.max.x)\n                    bounds.max.x = max.x;\n\n                if (min.y < bounds.min.y)\n                    bounds.min.y = min.y;\n\n                if (max.y > bounds.max.y)\n                    bounds.max.y = max.y;\n            }\n        }\n\n        // find ratios\n        var width = (bounds.max.x - bounds.min.x) + 2 * padding.x,\n            height = (bounds.max.y - bounds.min.y) + 2 * padding.y,\n            viewHeight = render.canvas.height,\n            viewWidth = render.canvas.width,\n            outerRatio = viewWidth / viewHeight,\n            innerRatio = width / height,\n            scaleX = 1,\n            scaleY = 1;\n\n        // find scale factor\n        if (innerRatio > outerRatio) {\n            scaleY = innerRatio / outerRatio;\n        } else {\n            scaleX = outerRatio / innerRatio;\n        }\n\n        // enable bounds\n        render.options.hasBounds = true;\n\n        // position and size\n        render.bounds.min.x = bounds.min.x;\n        render.bounds.max.x = bounds.min.x + width * scaleX;\n        render.bounds.min.y = bounds.min.y;\n        render.bounds.max.y = bounds.min.y + height * scaleY;\n\n        // center\n        if (center) {\n            render.bounds.min.x += width * 0.5 - (width * scaleX) * 0.5;\n            render.bounds.max.x += width * 0.5 - (width * scaleX) * 0.5;\n            render.bounds.min.y += height * 0.5 - (height * scaleY) * 0.5;\n            render.bounds.max.y += height * 0.5 - (height * scaleY) * 0.5;\n        }\n\n        // padding\n        render.bounds.min.x -= padding.x;\n        render.bounds.max.x -= padding.x;\n        render.bounds.min.y -= padding.y;\n        render.bounds.max.y -= padding.y;\n\n        // update mouse\n        if (render.mouse) {\n            Mouse.setScale(render.mouse, {\n                x: (render.bounds.max.x - render.bounds.min.x) / render.canvas.width,\n                y: (render.bounds.max.y - render.bounds.min.y) / render.canvas.height\n            });\n\n            Mouse.setOffset(render.mouse, render.bounds.min);\n        }\n    };\n\n    /**\n     * Applies viewport transforms based on `render.bounds` to a render context.\n     * @method startViewTransform\n     * @param {render} render\n     */\n    Render.startViewTransform = function(render) {\n        var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n            boundsHeight = render.bounds.max.y - render.bounds.min.y,\n            boundsScaleX = boundsWidth / render.options.width,\n            boundsScaleY = boundsHeight / render.options.height;\n\n        render.context.setTransform(\n            render.options.pixelRatio / boundsScaleX, 0, 0, \n            render.options.pixelRatio / boundsScaleY, 0, 0\n        );\n        \n        render.context.translate(-render.bounds.min.x, -render.bounds.min.y);\n    };\n\n    /**\n     * Resets all transforms on the render context.\n     * @method endViewTransform\n     * @param {render} render\n     */\n    Render.endViewTransform = function(render) {\n        render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n    };\n\n    /**\n     * Renders the given `engine`'s `Matter.World` object.\n     * This is the entry point for all rendering and should be called every time the scene changes.\n     * @method world\n     * @param {render} render\n     */\n    Render.world = function(render, time) {\n        var startTime = Common.now(),\n            engine = render.engine,\n            world = engine.world,\n            canvas = render.canvas,\n            context = render.context,\n            options = render.options,\n            timing = render.timing;\n\n        var allBodies = Composite.allBodies(world),\n            allConstraints = Composite.allConstraints(world),\n            background = options.wireframes ? options.wireframeBackground : options.background,\n            bodies = [],\n            constraints = [],\n            i;\n\n        var event = {\n            timestamp: engine.timing.timestamp\n        };\n\n        Events.trigger(render, 'beforeRender', event);\n\n        // apply background if it has changed\n        if (render.currentBackground !== background)\n            _applyBackground(render, background);\n\n        // clear the canvas with a transparent fill, to allow the canvas background to show\n        context.globalCompositeOperation = 'source-in';\n        context.fillStyle = \"transparent\";\n        context.fillRect(0, 0, canvas.width, canvas.height);\n        context.globalCompositeOperation = 'source-over';\n\n        // handle bounds\n        if (options.hasBounds) {\n            // filter out bodies that are not in view\n            for (i = 0; i < allBodies.length; i++) {\n                var body = allBodies[i];\n                if (Bounds.overlaps(body.bounds, render.bounds))\n                    bodies.push(body);\n            }\n\n            // filter out constraints that are not in view\n            for (i = 0; i < allConstraints.length; i++) {\n                var constraint = allConstraints[i],\n                    bodyA = constraint.bodyA,\n                    bodyB = constraint.bodyB,\n                    pointAWorld = constraint.pointA,\n                    pointBWorld = constraint.pointB;\n\n                if (bodyA) pointAWorld = Vector.add(bodyA.position, constraint.pointA);\n                if (bodyB) pointBWorld = Vector.add(bodyB.position, constraint.pointB);\n\n                if (!pointAWorld || !pointBWorld)\n                    continue;\n\n                if (Bounds.contains(render.bounds, pointAWorld) || Bounds.contains(render.bounds, pointBWorld))\n                    constraints.push(constraint);\n            }\n\n            // transform the view\n            Render.startViewTransform(render);\n\n            // update mouse\n            if (render.mouse) {\n                Mouse.setScale(render.mouse, {\n                    x: (render.bounds.max.x - render.bounds.min.x) / render.options.width,\n                    y: (render.bounds.max.y - render.bounds.min.y) / render.options.height\n                });\n\n                Mouse.setOffset(render.mouse, render.bounds.min);\n            }\n        } else {\n            constraints = allConstraints;\n            bodies = allBodies;\n\n            if (render.options.pixelRatio !== 1) {\n                render.context.setTransform(render.options.pixelRatio, 0, 0, render.options.pixelRatio, 0, 0);\n            }\n        }\n\n        if (!options.wireframes || (engine.enableSleeping && options.showSleeping)) {\n            // fully featured rendering of bodies\n            Render.bodies(render, bodies, context);\n        } else {\n            if (options.showConvexHulls)\n                Render.bodyConvexHulls(render, bodies, context);\n\n            // optimised method for wireframes only\n            Render.bodyWireframes(render, bodies, context);\n        }\n\n        if (options.showBounds)\n            Render.bodyBounds(render, bodies, context);\n\n        if (options.showAxes || options.showAngleIndicator)\n            Render.bodyAxes(render, bodies, context);\n\n        if (options.showPositions)\n            Render.bodyPositions(render, bodies, context);\n\n        if (options.showVelocity)\n            Render.bodyVelocity(render, bodies, context);\n\n        if (options.showIds)\n            Render.bodyIds(render, bodies, context);\n\n        if (options.showSeparations)\n            Render.separations(render, engine.pairs.list, context);\n\n        if (options.showCollisions)\n            Render.collisions(render, engine.pairs.list, context);\n\n        if (options.showVertexNumbers)\n            Render.vertexNumbers(render, bodies, context);\n\n        if (options.showMousePosition)\n            Render.mousePosition(render, render.mouse, context);\n\n        Render.constraints(constraints, context);\n\n        if (options.hasBounds) {\n            // revert view transforms\n            Render.endViewTransform(render);\n        }\n\n        Events.trigger(render, 'afterRender', event);\n\n        // log the time elapsed computing this update\n        timing.lastElapsed = Common.now() - startTime;\n    };\n\n    /**\n     * Renders statistics about the engine and world useful for debugging.\n     * @private\n     * @method stats\n     * @param {render} render\n     * @param {RenderingContext} context\n     * @param {Number} time\n     */\n    Render.stats = function(render, context, time) {\n        var engine = render.engine,\n            world = engine.world,\n            bodies = Composite.allBodies(world),\n            parts = 0,\n            width = 55,\n            height = 44,\n            x = 0,\n            y = 0;\n        \n        // count parts\n        for (var i = 0; i < bodies.length; i += 1) {\n            parts += bodies[i].parts.length;\n        }\n\n        // sections\n        var sections = {\n            'Part': parts,\n            'Body': bodies.length,\n            'Cons': Composite.allConstraints(world).length,\n            'Comp': Composite.allComposites(world).length,\n            'Pair': engine.pairs.list.length\n        };\n\n        // background\n        context.fillStyle = '#0e0f19';\n        context.fillRect(x, y, width * 5.5, height);\n\n        context.font = '12px Arial';\n        context.textBaseline = 'top';\n        context.textAlign = 'right';\n\n        // sections\n        for (var key in sections) {\n            var section = sections[key];\n            // label\n            context.fillStyle = '#aaa';\n            context.fillText(key, x + width, y + 8);\n\n            // value\n            context.fillStyle = '#eee';\n            context.fillText(section, x + width, y + 26);\n\n            x += width;\n        }\n    };\n\n    /**\n     * Renders engine and render performance information.\n     * @private\n     * @method performance\n     * @param {render} render\n     * @param {RenderingContext} context\n     */\n    Render.performance = function(render, context) {\n        var engine = render.engine,\n            timing = render.timing,\n            deltaHistory = timing.deltaHistory,\n            elapsedHistory = timing.elapsedHistory,\n            timestampElapsedHistory = timing.timestampElapsedHistory,\n            engineDeltaHistory = timing.engineDeltaHistory,\n            engineElapsedHistory = timing.engineElapsedHistory,\n            lastEngineDelta = engine.timing.lastDelta;\n        \n        var deltaMean = _mean(deltaHistory),\n            elapsedMean = _mean(elapsedHistory),\n            engineDeltaMean = _mean(engineDeltaHistory),\n            engineElapsedMean = _mean(engineElapsedHistory),\n            timestampElapsedMean = _mean(timestampElapsedHistory),\n            rateMean = (timestampElapsedMean / deltaMean) || 0,\n            fps = (1000 / deltaMean) || 0;\n\n        var graphHeight = 4,\n            gap = 12,\n            width = 60,\n            height = 34,\n            x = 10,\n            y = 69;\n\n        // background\n        context.fillStyle = '#0e0f19';\n        context.fillRect(0, 50, gap * 4 + width * 5 + 22, height);\n\n        // show FPS\n        Render.status(\n            context, x, y, width, graphHeight, deltaHistory.length, \n            Math.round(fps) + ' fps', \n            fps / Render._goodFps,\n            function(i) { return (deltaHistory[i] / deltaMean) - 1; }\n        );\n\n        // show engine delta\n        Render.status(\n            context, x + gap + width, y, width, graphHeight, engineDeltaHistory.length,\n            lastEngineDelta.toFixed(2) + ' dt', \n            Render._goodDelta / lastEngineDelta,\n            function(i) { return (engineDeltaHistory[i] / engineDeltaMean) - 1; }\n        );\n\n        // show engine update time\n        Render.status(\n            context, x + (gap + width) * 2, y, width, graphHeight, engineElapsedHistory.length,\n            engineElapsedMean.toFixed(2) + ' ut', \n            1 - (engineElapsedMean / Render._goodFps),\n            function(i) { return (engineElapsedHistory[i] / engineElapsedMean) - 1; }\n        );\n\n        // show render time\n        Render.status(\n            context, x + (gap + width) * 3, y, width, graphHeight, elapsedHistory.length,\n            elapsedMean.toFixed(2) + ' rt', \n            1 - (elapsedMean / Render._goodFps),\n            function(i) { return (elapsedHistory[i] / elapsedMean) - 1; }\n        );\n\n        // show effective speed\n        Render.status(\n            context, x + (gap + width) * 4, y, width, graphHeight, timestampElapsedHistory.length, \n            rateMean.toFixed(2) + ' x', \n            rateMean * rateMean * rateMean,\n            function(i) { return (((timestampElapsedHistory[i] / deltaHistory[i]) / rateMean) || 0) - 1; }\n        );\n    };\n\n    /**\n     * Renders a label, indicator and a chart.\n     * @private\n     * @method status\n     * @param {RenderingContext} context\n     * @param {number} x\n     * @param {number} y\n     * @param {number} width\n     * @param {number} height\n     * @param {number} count\n     * @param {string} label\n     * @param {string} indicator\n     * @param {function} plotY\n     */\n    Render.status = function(context, x, y, width, height, count, label, indicator, plotY) {\n        // background\n        context.strokeStyle = '#888';\n        context.fillStyle = '#444';\n        context.lineWidth = 1;\n        context.fillRect(x, y + 7, width, 1);\n\n        // chart\n        context.beginPath();\n        context.moveTo(x, y + 7 - height * Common.clamp(0.4 * plotY(0), -2, 2));\n        for (var i = 0; i < width; i += 1) {\n            context.lineTo(x + i, y + 7 - (i < count ? height * Common.clamp(0.4 * plotY(i), -2, 2) : 0));\n        }\n        context.stroke();\n\n        // indicator\n        context.fillStyle = 'hsl(' + Common.clamp(25 + 95 * indicator, 0, 120) + ',100%,60%)';\n        context.fillRect(x, y - 7, 4, 4);\n\n        // label\n        context.font = '12px Arial';\n        context.textBaseline = 'middle';\n        context.textAlign = 'right';\n        context.fillStyle = '#eee';\n        context.fillText(label, x + width, y - 5);\n    };\n\n    /**\n     * Description\n     * @private\n     * @method constraints\n     * @param {constraint[]} constraints\n     * @param {RenderingContext} context\n     */\n    Render.constraints = function(constraints, context) {\n        var c = context;\n\n        for (var i = 0; i < constraints.length; i++) {\n            var constraint = constraints[i];\n\n            if (!constraint.render.visible || !constraint.pointA || !constraint.pointB)\n                continue;\n\n            var bodyA = constraint.bodyA,\n                bodyB = constraint.bodyB,\n                start,\n                end;\n\n            if (bodyA) {\n                start = Vector.add(bodyA.position, constraint.pointA);\n            } else {\n                start = constraint.pointA;\n            }\n\n            if (constraint.render.type === 'pin') {\n                c.beginPath();\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                c.closePath();\n            } else {\n                if (bodyB) {\n                    end = Vector.add(bodyB.position, constraint.pointB);\n                } else {\n                    end = constraint.pointB;\n                }\n\n                c.beginPath();\n                c.moveTo(start.x, start.y);\n\n                if (constraint.render.type === 'spring') {\n                    var delta = Vector.sub(end, start),\n                        normal = Vector.perp(Vector.normalise(delta)),\n                        coils = Math.ceil(Common.clamp(constraint.length / 5, 12, 20)),\n                        offset;\n\n                    for (var j = 1; j < coils; j += 1) {\n                        offset = j % 2 === 0 ? 1 : -1;\n\n                        c.lineTo(\n                            start.x + delta.x * (j / coils) + normal.x * offset * 4,\n                            start.y + delta.y * (j / coils) + normal.y * offset * 4\n                        );\n                    }\n                }\n\n                c.lineTo(end.x, end.y);\n            }\n\n            if (constraint.render.lineWidth) {\n                c.lineWidth = constraint.render.lineWidth;\n                c.strokeStyle = constraint.render.strokeStyle;\n                c.stroke();\n            }\n\n            if (constraint.render.anchors) {\n                c.fillStyle = constraint.render.strokeStyle;\n                c.beginPath();\n                c.arc(start.x, start.y, 3, 0, 2 * Math.PI);\n                c.arc(end.x, end.y, 3, 0, 2 * Math.PI);\n                c.closePath();\n                c.fill();\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method bodies\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodies = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            showInternalEdges = options.showInternalEdges || !options.wireframes,\n            body,\n            part,\n            i,\n            k;\n\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n\n                if (!part.render.visible)\n                    continue;\n\n                if (options.showSleeping && body.isSleeping) {\n                    c.globalAlpha = 0.5 * part.render.opacity;\n                } else if (part.render.opacity !== 1) {\n                    c.globalAlpha = part.render.opacity;\n                }\n\n                if (part.render.sprite && part.render.sprite.texture && !options.wireframes) {\n                    // part sprite\n                    var sprite = part.render.sprite,\n                        texture = _getTexture(render, sprite.texture);\n\n                    c.translate(part.position.x, part.position.y);\n                    c.rotate(part.angle);\n\n                    c.drawImage(\n                        texture,\n                        texture.width * -sprite.xOffset * sprite.xScale,\n                        texture.height * -sprite.yOffset * sprite.yScale,\n                        texture.width * sprite.xScale,\n                        texture.height * sprite.yScale\n                    );\n\n                    // revert translation, hopefully faster than save / restore\n                    c.rotate(-part.angle);\n                    c.translate(-part.position.x, -part.position.y);\n                } else {\n                    // part polygon\n                    if (part.circleRadius) {\n                        c.beginPath();\n                        c.arc(part.position.x, part.position.y, part.circleRadius, 0, 2 * Math.PI);\n                    } else {\n                        c.beginPath();\n                        c.moveTo(part.vertices[0].x, part.vertices[0].y);\n\n                        for (var j = 1; j < part.vertices.length; j++) {\n                            if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                                c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                            } else {\n                                c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                            }\n\n                            if (part.vertices[j].isInternal && !showInternalEdges) {\n                                c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                            }\n                        }\n\n                        c.lineTo(part.vertices[0].x, part.vertices[0].y);\n                        c.closePath();\n                    }\n\n                    if (!options.wireframes) {\n                        c.fillStyle = part.render.fillStyle;\n\n                        if (part.render.lineWidth) {\n                            c.lineWidth = part.render.lineWidth;\n                            c.strokeStyle = part.render.strokeStyle;\n                            c.stroke();\n                        }\n\n                        c.fill();\n                    } else {\n                        c.lineWidth = 1;\n                        c.strokeStyle = '#bbb';\n                        c.stroke();\n                    }\n                }\n\n                c.globalAlpha = 1;\n            }\n        }\n    };\n\n    /**\n     * Optimised method for drawing body wireframes in one pass\n     * @private\n     * @method bodyWireframes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyWireframes = function(render, bodies, context) {\n        var c = context,\n            showInternalEdges = render.options.showInternalEdges,\n            body,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        // render all bodies\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = body.parts.length > 1 ? 1 : 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n\n                c.moveTo(part.vertices[0].x, part.vertices[0].y);\n\n                for (j = 1; j < part.vertices.length; j++) {\n                    if (!part.vertices[j - 1].isInternal || showInternalEdges) {\n                        c.lineTo(part.vertices[j].x, part.vertices[j].y);\n                    } else {\n                        c.moveTo(part.vertices[j].x, part.vertices[j].y);\n                    }\n\n                    if (part.vertices[j].isInternal && !showInternalEdges) {\n                        c.moveTo(part.vertices[(j + 1) % part.vertices.length].x, part.vertices[(j + 1) % part.vertices.length].y);\n                    }\n                }\n\n                c.lineTo(part.vertices[0].x, part.vertices[0].y);\n            }\n        }\n\n        c.lineWidth = 1;\n        c.strokeStyle = '#bbb';\n        c.stroke();\n    };\n\n    /**\n     * Optimised method for drawing body convex hull wireframes in one pass\n     * @private\n     * @method bodyConvexHulls\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyConvexHulls = function(render, bodies, context) {\n        var c = context,\n            body,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        // render convex hulls\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible || body.parts.length === 1)\n                continue;\n\n            c.moveTo(body.vertices[0].x, body.vertices[0].y);\n\n            for (j = 1; j < body.vertices.length; j++) {\n                c.lineTo(body.vertices[j].x, body.vertices[j].y);\n            }\n\n            c.lineTo(body.vertices[0].x, body.vertices[0].y);\n        }\n\n        c.lineWidth = 1;\n        c.strokeStyle = 'rgba(255,255,255,0.2)';\n        c.stroke();\n    };\n\n    /**\n     * Renders body vertex numbers.\n     * @private\n     * @method vertexNumbers\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.vertexNumbers = function(render, bodies, context) {\n        var c = context,\n            i,\n            j,\n            k;\n\n        for (i = 0; i < bodies.length; i++) {\n            var parts = bodies[i].parts;\n            for (k = parts.length > 1 ? 1 : 0; k < parts.length; k++) {\n                var part = parts[k];\n                for (j = 0; j < part.vertices.length; j++) {\n                    c.fillStyle = 'rgba(255,255,255,0.2)';\n                    c.fillText(i + '_' + j, part.position.x + (part.vertices[j].x - part.position.x) * 0.8, part.position.y + (part.vertices[j].y - part.position.y) * 0.8);\n                }\n            }\n        }\n    };\n\n    /**\n     * Renders mouse position.\n     * @private\n     * @method mousePosition\n     * @param {render} render\n     * @param {mouse} mouse\n     * @param {RenderingContext} context\n     */\n    Render.mousePosition = function(render, mouse, context) {\n        var c = context;\n        c.fillStyle = 'rgba(255,255,255,0.8)';\n        c.fillText(mouse.position.x + '  ' + mouse.position.y, mouse.position.x + 5, mouse.position.y - 5);\n    };\n\n    /**\n     * Draws body bounds\n     * @private\n     * @method bodyBounds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyBounds = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (body.render.visible) {\n                var parts = bodies[i].parts;\n                for (var j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    var part = parts[j];\n                    c.rect(part.bounds.min.x, part.bounds.min.y, part.bounds.max.x - part.bounds.min.x, part.bounds.max.y - part.bounds.min.y);\n                }\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,255,255,0.08)';\n        } else {\n            c.strokeStyle = 'rgba(0,0,0,0.1)';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Draws body angle indicators and axes\n     * @private\n     * @method bodyAxes\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyAxes = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            part,\n            i,\n            j,\n            k;\n\n        c.beginPath();\n\n        for (i = 0; i < bodies.length; i++) {\n            var body = bodies[i],\n                parts = body.parts;\n\n            if (!body.render.visible)\n                continue;\n\n            if (options.showAxes) {\n                // render all axes\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    part = parts[j];\n                    for (k = 0; k < part.axes.length; k++) {\n                        var axis = part.axes[k];\n                        c.moveTo(part.position.x, part.position.y);\n                        c.lineTo(part.position.x + axis.x * 20, part.position.y + axis.y * 20);\n                    }\n                }\n            } else {\n                for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                    part = parts[j];\n                    for (k = 0; k < part.axes.length; k++) {\n                        // render a single axis indicator\n                        c.moveTo(part.position.x, part.position.y);\n                        c.lineTo((part.vertices[0].x + part.vertices[part.vertices.length-1].x) / 2,\n                            (part.vertices[0].y + part.vertices[part.vertices.length-1].y) / 2);\n                    }\n                }\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'indianred';\n            c.lineWidth = 1;\n        } else {\n            c.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n            c.globalCompositeOperation = 'overlay';\n            c.lineWidth = 2;\n        }\n\n        c.stroke();\n        c.globalCompositeOperation = 'source-over';\n    };\n\n    /**\n     * Draws body positions\n     * @private\n     * @method bodyPositions\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyPositions = function(render, bodies, context) {\n        var c = context,\n            engine = render.engine,\n            options = render.options,\n            body,\n            part,\n            i,\n            k;\n\n        c.beginPath();\n\n        // render current positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            // handle compound parts\n            for (k = 0; k < body.parts.length; k++) {\n                part = body.parts[k];\n                c.arc(part.position.x, part.position.y, 3, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'indianred';\n        } else {\n            c.fillStyle = 'rgba(0,0,0,0.5)';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render previous positions\n        for (i = 0; i < bodies.length; i++) {\n            body = bodies[i];\n            if (body.render.visible) {\n                c.arc(body.positionPrev.x, body.positionPrev.y, 2, 0, 2 * Math.PI, false);\n                c.closePath();\n            }\n        }\n\n        c.fillStyle = 'rgba(255,165,0,0.8)';\n        c.fill();\n    };\n\n    /**\n     * Draws body velocity\n     * @private\n     * @method bodyVelocity\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyVelocity = function(render, bodies, context) {\n        var c = context;\n\n        c.beginPath();\n\n        for (var i = 0; i < bodies.length; i++) {\n            var body = bodies[i];\n\n            if (!body.render.visible)\n                continue;\n\n            var velocity = Body.getVelocity(body);\n\n            c.moveTo(body.position.x, body.position.y);\n            c.lineTo(body.position.x + velocity.x, body.position.y + velocity.y);\n        }\n\n        c.lineWidth = 3;\n        c.strokeStyle = 'cornflowerblue';\n        c.stroke();\n    };\n\n    /**\n     * Draws body ids\n     * @private\n     * @method bodyIds\n     * @param {render} render\n     * @param {body[]} bodies\n     * @param {RenderingContext} context\n     */\n    Render.bodyIds = function(render, bodies, context) {\n        var c = context,\n            i,\n            j;\n\n        for (i = 0; i < bodies.length; i++) {\n            if (!bodies[i].render.visible)\n                continue;\n\n            var parts = bodies[i].parts;\n            for (j = parts.length > 1 ? 1 : 0; j < parts.length; j++) {\n                var part = parts[j];\n                c.font = \"12px Arial\";\n                c.fillStyle = 'rgba(255,255,255,0.5)';\n                c.fillText(part.id, part.position.x + 10, part.position.y - 10);\n            }\n        }\n    };\n\n    /**\n     * Description\n     * @private\n     * @method collisions\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */\n    Render.collisions = function(render, pairs, context) {\n        var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n\n        c.beginPath();\n\n        // render collision positions\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            for (j = 0; j < pair.activeContacts.length; j++) {\n                var contact = pair.activeContacts[j],\n                    vertex = contact.vertex;\n                c.rect(vertex.x - 1.5, vertex.y - 1.5, 3.5, 3.5);\n            }\n        }\n\n        if (options.wireframes) {\n            c.fillStyle = 'rgba(255,255,255,0.7)';\n        } else {\n            c.fillStyle = 'orange';\n        }\n        c.fill();\n\n        c.beginPath();\n\n        // render collision normals\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n\n            if (pair.activeContacts.length > 0) {\n                var normalPosX = pair.activeContacts[0].vertex.x,\n                    normalPosY = pair.activeContacts[0].vertex.y;\n\n                if (pair.activeContacts.length === 2) {\n                    normalPosX = (pair.activeContacts[0].vertex.x + pair.activeContacts[1].vertex.x) / 2;\n                    normalPosY = (pair.activeContacts[0].vertex.y + pair.activeContacts[1].vertex.y) / 2;\n                }\n\n                if (collision.bodyB === collision.supports[0].body || collision.bodyA.isStatic === true) {\n                    c.moveTo(normalPosX - collision.normal.x * 8, normalPosY - collision.normal.y * 8);\n                } else {\n                    c.moveTo(normalPosX + collision.normal.x * 8, normalPosY + collision.normal.y * 8);\n                }\n\n                c.lineTo(normalPosX, normalPosY);\n            }\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.7)';\n        } else {\n            c.strokeStyle = 'orange';\n        }\n\n        c.lineWidth = 1;\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method separations\n     * @param {render} render\n     * @param {pair[]} pairs\n     * @param {RenderingContext} context\n     */\n    Render.separations = function(render, pairs, context) {\n        var c = context,\n            options = render.options,\n            pair,\n            collision,\n            corrected,\n            bodyA,\n            bodyB,\n            i,\n            j;\n\n        c.beginPath();\n\n        // render separations\n        for (i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n\n            if (!pair.isActive)\n                continue;\n\n            collision = pair.collision;\n            bodyA = collision.bodyA;\n            bodyB = collision.bodyB;\n\n            var k = 1;\n\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyB.isStatic) k = 0;\n\n            c.moveTo(bodyB.position.x, bodyB.position.y);\n            c.lineTo(bodyB.position.x - collision.penetration.x * k, bodyB.position.y - collision.penetration.y * k);\n\n            k = 1;\n\n            if (!bodyB.isStatic && !bodyA.isStatic) k = 0.5;\n            if (bodyA.isStatic) k = 0;\n\n            c.moveTo(bodyA.position.x, bodyA.position.y);\n            c.lineTo(bodyA.position.x + collision.penetration.x * k, bodyA.position.y + collision.penetration.y * k);\n        }\n\n        if (options.wireframes) {\n            c.strokeStyle = 'rgba(255,165,0,0.5)';\n        } else {\n            c.strokeStyle = 'orange';\n        }\n        c.stroke();\n    };\n\n    /**\n     * Description\n     * @private\n     * @method inspector\n     * @param {inspector} inspector\n     * @param {RenderingContext} context\n     */\n    Render.inspector = function(inspector, context) {\n        var engine = inspector.engine,\n            selected = inspector.selected,\n            render = inspector.render,\n            options = render.options,\n            bounds;\n\n        if (options.hasBounds) {\n            var boundsWidth = render.bounds.max.x - render.bounds.min.x,\n                boundsHeight = render.bounds.max.y - render.bounds.min.y,\n                boundsScaleX = boundsWidth / render.options.width,\n                boundsScaleY = boundsHeight / render.options.height;\n\n            context.scale(1 / boundsScaleX, 1 / boundsScaleY);\n            context.translate(-render.bounds.min.x, -render.bounds.min.y);\n        }\n\n        for (var i = 0; i < selected.length; i++) {\n            var item = selected[i].data;\n\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.9)';\n            context.setLineDash([1,2]);\n\n            switch (item.type) {\n\n            case 'body':\n\n                // render body selections\n                bounds = item.bounds;\n                context.beginPath();\n                context.rect(Math.floor(bounds.min.x - 3), Math.floor(bounds.min.y - 3),\n                    Math.floor(bounds.max.x - bounds.min.x + 6), Math.floor(bounds.max.y - bounds.min.y + 6));\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            case 'constraint':\n\n                // render constraint selections\n                var point = item.pointA;\n                if (item.bodyA)\n                    point = item.pointB;\n                context.beginPath();\n                context.arc(point.x, point.y, 10, 0, 2 * Math.PI);\n                context.closePath();\n                context.stroke();\n\n                break;\n\n            }\n\n            context.setLineDash([]);\n            context.translate(-0.5, -0.5);\n        }\n\n        // render selection region\n        if (inspector.selectStart !== null) {\n            context.translate(0.5, 0.5);\n            context.lineWidth = 1;\n            context.strokeStyle = 'rgba(255,165,0,0.6)';\n            context.fillStyle = 'rgba(255,165,0,0.1)';\n            bounds = inspector.selectBounds;\n            context.beginPath();\n            context.rect(Math.floor(bounds.min.x), Math.floor(bounds.min.y),\n                Math.floor(bounds.max.x - bounds.min.x), Math.floor(bounds.max.y - bounds.min.y));\n            context.closePath();\n            context.stroke();\n            context.fill();\n            context.translate(-0.5, -0.5);\n        }\n\n        if (options.hasBounds)\n            context.setTransform(1, 0, 0, 1, 0, 0);\n    };\n\n    /**\n     * Updates render timing.\n     * @method _updateTiming\n     * @private\n     * @param {render} render\n     * @param {number} time\n     */\n    var _updateTiming = function(render, time) {\n        var engine = render.engine,\n            timing = render.timing,\n            historySize = timing.historySize,\n            timestamp = engine.timing.timestamp;\n\n        timing.delta = time - timing.lastTime || Render._goodDelta;\n        timing.lastTime = time;\n\n        timing.timestampElapsed = timestamp - timing.lastTimestamp || 0;\n        timing.lastTimestamp = timestamp;\n\n        timing.deltaHistory.unshift(timing.delta);\n        timing.deltaHistory.length = Math.min(timing.deltaHistory.length, historySize);\n\n        timing.engineDeltaHistory.unshift(engine.timing.lastDelta);\n        timing.engineDeltaHistory.length = Math.min(timing.engineDeltaHistory.length, historySize);\n\n        timing.timestampElapsedHistory.unshift(timing.timestampElapsed);\n        timing.timestampElapsedHistory.length = Math.min(timing.timestampElapsedHistory.length, historySize);\n\n        timing.engineElapsedHistory.unshift(engine.timing.lastElapsed);\n        timing.engineElapsedHistory.length = Math.min(timing.engineElapsedHistory.length, historySize);\n\n        timing.elapsedHistory.unshift(timing.lastElapsed);\n        timing.elapsedHistory.length = Math.min(timing.elapsedHistory.length, historySize);\n    };\n\n    /**\n     * Returns the mean value of the given numbers.\n     * @method _mean\n     * @private\n     * @param {Number[]} values\n     * @return {Number} the mean of given values\n     */\n    var _mean = function(values) {\n        var result = 0;\n        for (var i = 0; i < values.length; i += 1) {\n            result += values[i];\n        }\n        return (result / values.length) || 0;\n    };\n\n    /**\n     * @method _createCanvas\n     * @private\n     * @param {} width\n     * @param {} height\n     * @return canvas\n     */\n    var _createCanvas = function(width, height) {\n        var canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        canvas.oncontextmenu = function() { return false; };\n        canvas.onselectstart = function() { return false; };\n        return canvas;\n    };\n\n    /**\n     * Gets the pixel ratio of the canvas.\n     * @method _getPixelRatio\n     * @private\n     * @param {HTMLElement} canvas\n     * @return {Number} pixel ratio\n     */\n    var _getPixelRatio = function(canvas) {\n        var context = canvas.getContext('2d'),\n            devicePixelRatio = window.devicePixelRatio || 1,\n            backingStorePixelRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio\n                                      || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio\n                                      || context.backingStorePixelRatio || 1;\n\n        return devicePixelRatio / backingStorePixelRatio;\n    };\n\n    /**\n     * Gets the requested texture (an Image) via its path\n     * @method _getTexture\n     * @private\n     * @param {render} render\n     * @param {string} imagePath\n     * @return {Image} texture\n     */\n    var _getTexture = function(render, imagePath) {\n        var image = render.textures[imagePath];\n\n        if (image)\n            return image;\n\n        image = render.textures[imagePath] = new Image();\n        image.src = imagePath;\n\n        return image;\n    };\n\n    /**\n     * Applies the background to the canvas using CSS.\n     * @method applyBackground\n     * @private\n     * @param {render} render\n     * @param {string} background\n     */\n    var _applyBackground = function(render, background) {\n        var cssBackground = background;\n\n        if (/(jpg|gif|png)$/.test(background))\n            cssBackground = 'url(' + background + ')';\n\n        render.canvas.style.background = cssBackground;\n        render.canvas.style.backgroundSize = \"contain\";\n        render.currentBackground = background;\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired before rendering\n    *\n    * @event beforeRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after rendering\n    *\n    * @event afterRender\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A back-reference to the `Matter.Render` module.\n     *\n     * @deprecated\n     * @property controller\n     * @type render\n     */\n\n    /**\n     * A reference to the `Matter.Engine` instance to be used.\n     *\n     * @property engine\n     * @type engine\n     */\n\n    /**\n     * A reference to the element where the canvas is to be inserted (if `render.canvas` has not been specified)\n     *\n     * @property element\n     * @type HTMLElement\n     * @default null\n     */\n\n    /**\n     * The canvas element to render to. If not specified, one will be created if `render.element` has been specified.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     * @default null\n     */\n\n    /**\n     * A `Bounds` object that specifies the drawing view region.\n     * Rendering will be automatically transformed and scaled to fit within the canvas size (`render.options.width` and `render.options.height`).\n     * This allows for creating views that can pan or zoom around the scene.\n     * You must also set `render.options.hasBounds` to `true` to enable bounded rendering.\n     *\n     * @property bounds\n     * @type bounds\n     */\n\n    /**\n     * The 2d rendering context from the `render.canvas` element.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n\n    /**\n     * The sprite texture cache.\n     *\n     * @property textures\n     * @type {}\n     */\n\n    /**\n     * The mouse to render if `render.options.showMousePosition` is enabled.\n     *\n     * @property mouse\n     * @type mouse\n     * @default null\n     */\n\n    /**\n     * The configuration options of the renderer.\n     *\n     * @property options\n     * @type {}\n     */\n\n    /**\n     * The target width in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.width\n     * @type number\n     * @default 800\n     */\n\n    /**\n     * The target height in pixels of the `render.canvas` to be created.\n     * See also the `options.pixelRatio` property to change render quality.\n     *\n     * @property options.height\n     * @type number\n     * @default 600\n     */\n\n    /**\n     * The [pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio) to use when rendering.\n     *\n     * @property options.pixelRatio\n     * @type number\n     * @default 1\n     */\n\n    /**\n     * A CSS background color string to use when `render.options.wireframes` is disabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.background\n     * @type string\n     * @default '#14151f'\n     */\n\n    /**\n     * A CSS background color string to use when `render.options.wireframes` is enabled.\n     * This may be also set to `'transparent'` or equivalent.\n     *\n     * @property options.wireframeBackground\n     * @type string\n     * @default '#14151f'\n     */\n\n    /**\n     * A flag that specifies if `render.bounds` should be used when rendering.\n     *\n     * @property options.hasBounds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable all debug information overlays together.  \n     * This includes and has priority over the values of:\n     *\n     * - `render.options.showStats`\n     * - `render.options.showPerformance`\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the engine stats info overlay.  \n     * From left to right, the values shown are:\n     *\n     * - body parts total\n     * - body total\n     * - constraints total\n     * - composites total\n     * - collision pairs total\n     *\n     * @property options.showStats\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable performance charts.  \n     * From left to right, the values shown are:\n     *\n     * - average render frequency (e.g. 60 fps)\n     * - exact engine delta time used for last update (e.g. 16.66ms)\n     * - average engine execution duration (e.g. 5.00ms)\n     * - average render execution duration (e.g. 0.40ms)\n     * - average effective play speed (e.g. '1.00x' is 'real-time')\n     *\n     * Each value is recorded over a fixed sample of past frames (60 frames).\n     *\n     * A chart shown below each value indicates the variance from the average over the sample.\n     * The more stable or fixed the value is the flatter the chart will appear.\n     *\n     * @property options.showPerformance\n     * @type boolean\n     * @default false\n     */\n    \n    /**\n     * A flag to enable or disable rendering entirely.\n     *\n     * @property options.enabled\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to toggle wireframe rendering otherwise solid fill rendering is used.\n     *\n     * @property options.wireframes\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A flag to enable or disable sleeping bodies indicators.\n     *\n     * @property options.showSleeping\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A flag to enable or disable the debug information overlay.\n     *\n     * @property options.showDebug\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the collision broadphase debug overlay.\n     *\n     * @deprecated no longer implemented\n     * @property options.showBroadphase\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body bounds debug overlay.\n     *\n     * @property options.showBounds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body velocity debug overlay.\n     *\n     * @property options.showVelocity\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body collisions debug overlay.\n     *\n     * @property options.showCollisions\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the collision resolver separations debug overlay.\n     *\n     * @property options.showSeparations\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body axes debug overlay.\n     *\n     * @property options.showAxes\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body positions debug overlay.\n     *\n     * @property options.showPositions\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body angle debug overlay.\n     *\n     * @property options.showAngleIndicator\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body and part ids debug overlay.\n     *\n     * @property options.showIds\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body vertex numbers debug overlay.\n     *\n     * @property options.showVertexNumbers\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body convex hulls debug overlay.\n     *\n     * @property options.showConvexHulls\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the body internal edges debug overlay.\n     *\n     * @property options.showInternalEdges\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A flag to enable or disable the mouse position debug overlay.\n     *\n     * @property options.showMousePosition\n     * @type boolean\n     * @default false\n     */\n\n})();\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __nested_webpack_require_339525__) {\n\n/**\n* The `Matter.Runner` module is an optional utility which provides a game loop, \n* that handles continuously updating a `Matter.Engine` for you within a browser.\n* It is intended for development and debugging purposes, but may also be suitable for simple games.\n* If you are using your own game loop instead, then you do not need the `Matter.Runner` module.\n* Instead just call `Engine.update(engine, delta)` in your own loop.\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Runner\n*/\n\nvar Runner = {};\n\nmodule.exports = Runner;\n\nvar Events = __nested_webpack_require_339525__(5);\nvar Engine = __nested_webpack_require_339525__(17);\nvar Common = __nested_webpack_require_339525__(0);\n\n(function() {\n\n    var _requestAnimationFrame,\n        _cancelAnimationFrame;\n\n    if (typeof window !== 'undefined') {\n        _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame\n                                      || window.mozRequestAnimationFrame || window.msRequestAnimationFrame;\n   \n        _cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame \n                                      || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame;\n    }\n\n    if (!_requestAnimationFrame) {\n        var _frameTimeout;\n\n        _requestAnimationFrame = function(callback){ \n            _frameTimeout = setTimeout(function() { \n                callback(Common.now()); \n            }, 1000 / 60);\n        };\n\n        _cancelAnimationFrame = function() {\n            clearTimeout(_frameTimeout);\n        };\n    }\n\n    /**\n     * Creates a new Runner. The options parameter is an object that specifies any properties you wish to override the defaults.\n     * @method create\n     * @param {} options\n     */\n    Runner.create = function(options) {\n        var defaults = {\n            fps: 60,\n            deltaSampleSize: 60,\n            counterTimestamp: 0,\n            frameCounter: 0,\n            deltaHistory: [],\n            timePrev: null,\n            frameRequestId: null,\n            isFixed: false,\n            enabled: true\n        };\n\n        var runner = Common.extend(defaults, options);\n\n        runner.delta = runner.delta || 1000 / runner.fps;\n        runner.deltaMin = runner.deltaMin || 1000 / runner.fps;\n        runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);\n        runner.fps = 1000 / runner.delta;\n\n        return runner;\n    };\n\n    /**\n     * Continuously ticks a `Matter.Engine` by calling `Runner.tick` on the `requestAnimationFrame` event.\n     * @method run\n     * @param {engine} engine\n     */\n    Runner.run = function(runner, engine) {\n        // create runner if engine is first argument\n        if (typeof runner.positionIterations !== 'undefined') {\n            engine = runner;\n            runner = Runner.create();\n        }\n\n        (function run(time){\n            runner.frameRequestId = _requestAnimationFrame(run);\n\n            if (time && runner.enabled) {\n                Runner.tick(runner, engine, time);\n            }\n        })();\n\n        return runner;\n    };\n\n    /**\n     * A game loop utility that updates the engine and renderer by one step (a 'tick').\n     * Features delta smoothing, time correction and fixed or dynamic timing.\n     * Consider just `Engine.update(engine, delta)` if you're using your own loop.\n     * @method tick\n     * @param {runner} runner\n     * @param {engine} engine\n     * @param {number} time\n     */\n    Runner.tick = function(runner, engine, time) {\n        var timing = engine.timing,\n            delta;\n\n        if (runner.isFixed) {\n            // fixed timestep\n            delta = runner.delta;\n        } else {\n            // dynamic timestep based on wall clock between calls\n            delta = (time - runner.timePrev) || runner.delta;\n            runner.timePrev = time;\n\n            // optimistically filter delta over a few frames, to improve stability\n            runner.deltaHistory.push(delta);\n            runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);\n            delta = Math.min.apply(null, runner.deltaHistory);\n\n            // limit delta\n            delta = delta < runner.deltaMin ? runner.deltaMin : delta;\n            delta = delta > runner.deltaMax ? runner.deltaMax : delta;\n\n            // update engine timing object\n            runner.delta = delta;\n        }\n\n        // create an event object\n        var event = {\n            timestamp: timing.timestamp\n        };\n\n        Events.trigger(runner, 'beforeTick', event);\n\n        // fps counter\n        runner.frameCounter += 1;\n        if (time - runner.counterTimestamp >= 1000) {\n            runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);\n            runner.counterTimestamp = time;\n            runner.frameCounter = 0;\n        }\n\n        Events.trigger(runner, 'tick', event);\n\n        // update\n        Events.trigger(runner, 'beforeUpdate', event);\n\n        Engine.update(engine, delta);\n\n        Events.trigger(runner, 'afterUpdate', event);\n\n        Events.trigger(runner, 'afterTick', event);\n    };\n\n    /**\n     * Ends execution of `Runner.run` on the given `runner`, by canceling the animation frame request event loop.\n     * If you wish to only temporarily pause the engine, see `engine.enabled` instead.\n     * @method stop\n     * @param {runner} runner\n     */\n    Runner.stop = function(runner) {\n        _cancelAnimationFrame(runner.frameRequestId);\n    };\n\n    /**\n     * Alias for `Runner.run`.\n     * @method start\n     * @param {runner} runner\n     * @param {engine} engine\n     */\n    Runner.start = function(runner, engine) {\n        Runner.run(runner, engine);\n    };\n\n    /*\n    *\n    *  Events Documentation\n    *\n    */\n\n    /**\n    * Fired at the start of a tick, before any updates to the engine or timing\n    *\n    * @event beforeTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after engine timing updated, but just before update\n    *\n    * @event tick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired at the end of a tick, after engine update and after rendering\n    *\n    * @event afterTick\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired before update\n    *\n    * @event beforeUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /**\n    * Fired after update\n    *\n    * @event afterUpdate\n    * @param {} event An event object\n    * @param {number} event.timestamp The engine.timing.timestamp of the event\n    * @param {} event.source The source object of the event\n    * @param {} event.name The name of the event\n    */\n\n    /*\n    *\n    *  Properties Documentation\n    *\n    */\n\n    /**\n     * A flag that specifies whether the runner is running or not.\n     *\n     * @property enabled\n     * @type boolean\n     * @default true\n     */\n\n    /**\n     * A `Boolean` that specifies if the runner should use a fixed timestep (otherwise it is variable).\n     * If timing is fixed, then the apparent simulation speed will change depending on the frame rate (but behaviour will be deterministic).\n     * If the timing is variable, then the apparent simulation speed will be constant (approximately, but at the cost of determininism).\n     *\n     * @property isFixed\n     * @type boolean\n     * @default false\n     */\n\n    /**\n     * A `Number` that specifies the time step between updates in milliseconds.\n     * If `engine.timing.isFixed` is set to `true`, then `delta` is fixed.\n     * If it is `false`, then `delta` can dynamically change to maintain the correct apparent simulation speed.\n     *\n     * @property delta\n     * @type number\n     * @default 1000 / 60\n     */\n\n})();\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __nested_webpack_require_348064__) {\n\n/**\n* This module has now been replaced by `Matter.Collision`.\n*\n* All usage should be migrated to `Matter.Collision`.\n* For back-compatibility purposes this module will remain for a short term and then later removed in a future release.\n*\n* The `Matter.SAT` module contains methods for detecting collisions using the Separating Axis Theorem.\n*\n* @class SAT\n* @deprecated\n*/\n\nvar SAT = {};\n\nmodule.exports = SAT;\n\nvar Collision = __nested_webpack_require_348064__(8);\nvar Common = __nested_webpack_require_348064__(0);\nvar deprecated = Common.deprecated;\n\n(function() {\n\n    /**\n     * Detect collision between two bodies using the Separating Axis Theorem.\n     * @deprecated replaced by Collision.collides\n     * @method collides\n     * @param {body} bodyA\n     * @param {body} bodyB\n     * @return {collision} collision\n     */\n    SAT.collides = function(bodyA, bodyB) {\n        return Collision.collides(bodyA, bodyB);\n    };\n\n    deprecated(SAT, 'collides', 'SAT.collides âž¤ replaced by Collision.collides');\n\n})();\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __nested_webpack_require_349134__) {\n\n/**\n* The `Matter.Svg` module contains methods for converting SVG images into an array of vector points.\n*\n* To use this module you also need the SVGPathSeg polyfill: https://github.com/progers/pathseg\n*\n* See the included usage [examples](https://github.com/liabru/matter-js/tree/master/examples).\n*\n* @class Svg\n*/\n\nvar Svg = {};\n\nmodule.exports = Svg;\n\nvar Bounds = __nested_webpack_require_349134__(1);\nvar Common = __nested_webpack_require_349134__(0);\n\n(function() {\n\n    /**\n     * Converts an SVG path into an array of vector points.\n     * If the input path forms a concave shape, you must decompose the result into convex parts before use.\n     * See `Bodies.fromVertices` which provides support for this.\n     * Note that this function is not guaranteed to support complex paths (such as those with holes).\n     * You must load the `pathseg.js` polyfill on newer browsers.\n     * @method pathToVertices\n     * @param {SVGPathElement} path\n     * @param {Number} [sampleLength=15]\n     * @return {Vector[]} points\n     */\n    Svg.pathToVertices = function(path, sampleLength) {\n        if (typeof window !== 'undefined' && !('SVGPathSeg' in window)) {\n            Common.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.');\n        }\n\n        // https://github.com/wout/svg.topoly.js/blob/master/svg.topoly.js\n        var i, il, total, point, segment, segments, \n            segmentsQueue, lastSegment, \n            lastPoint, segmentIndex, points = [],\n            lx, ly, length = 0, x = 0, y = 0;\n\n        sampleLength = sampleLength || 15;\n\n        var addPoint = function(px, py, pathSegType) {\n            // all odd-numbered path types are relative except PATHSEG_CLOSEPATH (1)\n            var isRelative = pathSegType % 2 === 1 && pathSegType > 1;\n\n            // when the last point doesn't equal the current point add the current point\n            if (!lastPoint || px != lastPoint.x || py != lastPoint.y) {\n                if (lastPoint && isRelative) {\n                    lx = lastPoint.x;\n                    ly = lastPoint.y;\n                } else {\n                    lx = 0;\n                    ly = 0;\n                }\n\n                var point = {\n                    x: lx + px,\n                    y: ly + py\n                };\n\n                // set last point\n                if (isRelative || !lastPoint) {\n                    lastPoint = point;\n                }\n\n                points.push(point);\n\n                x = lx + px;\n                y = ly + py;\n            }\n        };\n\n        var addSegmentPoint = function(segment) {\n            var segType = segment.pathSegTypeAsLetter.toUpperCase();\n\n            // skip path ends\n            if (segType === 'Z') \n                return;\n\n            // map segment to x and y\n            switch (segType) {\n\n            case 'M':\n            case 'L':\n            case 'T':\n            case 'C':\n            case 'S':\n            case 'Q':\n                x = segment.x;\n                y = segment.y;\n                break;\n            case 'H':\n                x = segment.x;\n                break;\n            case 'V':\n                y = segment.y;\n                break;\n            }\n\n            addPoint(x, y, segment.pathSegType);\n        };\n\n        // ensure path is absolute\n        Svg._svgPathToAbsolute(path);\n\n        // get total length\n        total = path.getTotalLength();\n\n        // queue segments\n        segments = [];\n        for (i = 0; i < path.pathSegList.numberOfItems; i += 1)\n            segments.push(path.pathSegList.getItem(i));\n\n        segmentsQueue = segments.concat();\n\n        // sample through path\n        while (length < total) {\n            // get segment at position\n            segmentIndex = path.getPathSegAtLength(length);\n            segment = segments[segmentIndex];\n\n            // new segment\n            if (segment != lastSegment) {\n                while (segmentsQueue.length && segmentsQueue[0] != segment)\n                    addSegmentPoint(segmentsQueue.shift());\n\n                lastSegment = segment;\n            }\n\n            // add points in between when curving\n            // TODO: adaptive sampling\n            switch (segment.pathSegTypeAsLetter.toUpperCase()) {\n\n            case 'C':\n            case 'T':\n            case 'S':\n            case 'Q':\n            case 'A':\n                point = path.getPointAtLength(length);\n                addPoint(point.x, point.y, 0);\n                break;\n\n            }\n\n            // increment by sample value\n            length += sampleLength;\n        }\n\n        // add remaining segments not passed by sampling\n        for (i = 0, il = segmentsQueue.length; i < il; ++i)\n            addSegmentPoint(segmentsQueue[i]);\n\n        return points;\n    };\n\n    Svg._svgPathToAbsolute = function(path) {\n        // http://phrogz.net/convert-svg-path-to-all-absolute-commands\n        // Copyright (c) Gavin Kistner\n        // http://phrogz.net/js/_ReuseLicense.txt\n        // Modifications: tidy formatting and naming\n        var x0, y0, x1, y1, x2, y2, segs = path.pathSegList,\n            x = 0, y = 0, len = segs.numberOfItems;\n\n        for (var i = 0; i < len; ++i) {\n            var seg = segs.getItem(i),\n                segType = seg.pathSegTypeAsLetter;\n\n            if (/[MLHVCSQTA]/.test(segType)) {\n                if ('x' in seg) x = seg.x;\n                if ('y' in seg) y = seg.y;\n            } else {\n                if ('x1' in seg) x1 = x + seg.x1;\n                if ('x2' in seg) x2 = x + seg.x2;\n                if ('y1' in seg) y1 = y + seg.y1;\n                if ('y2' in seg) y2 = y + seg.y2;\n                if ('x' in seg) x += seg.x;\n                if ('y' in seg) y += seg.y;\n\n                switch (segType) {\n\n                case 'm':\n                    segs.replaceItem(path.createSVGPathSegMovetoAbs(x, y), i);\n                    break;\n                case 'l':\n                    segs.replaceItem(path.createSVGPathSegLinetoAbs(x, y), i);\n                    break;\n                case 'h':\n                    segs.replaceItem(path.createSVGPathSegLinetoHorizontalAbs(x), i);\n                    break;\n                case 'v':\n                    segs.replaceItem(path.createSVGPathSegLinetoVerticalAbs(y), i);\n                    break;\n                case 'c':\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicAbs(x, y, x1, y1, x2, y2), i);\n                    break;\n                case 's':\n                    segs.replaceItem(path.createSVGPathSegCurvetoCubicSmoothAbs(x, y, x2, y2), i);\n                    break;\n                case 'q':\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticAbs(x, y, x1, y1), i);\n                    break;\n                case 't':\n                    segs.replaceItem(path.createSVGPathSegCurvetoQuadraticSmoothAbs(x, y), i);\n                    break;\n                case 'a':\n                    segs.replaceItem(path.createSVGPathSegArcAbs(x, y, seg.r1, seg.r2, seg.angle, seg.largeArcFlag, seg.sweepFlag), i);\n                    break;\n                case 'z':\n                case 'Z':\n                    x = x0;\n                    y = y0;\n                    break;\n\n                }\n            }\n\n            if (segType == 'M' || segType == 'm') {\n                x0 = x;\n                y0 = y;\n            }\n        }\n    };\n\n})();\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __nested_webpack_require_356595__) {\n\n/**\n* This module has now been replaced by `Matter.Composite`.\n*\n* All usage should be migrated to the equivalent functions found on `Matter.Composite`.\n* For example `World.add(world, body)` now becomes `Composite.add(world, body)`.\n*\n* The property `world.gravity` has been moved to `engine.gravity`.\n*\n* For back-compatibility purposes this module will remain as a direct alias to `Matter.Composite` in the short term during migration.\n* Eventually this alias module will be marked as deprecated and then later removed in a future release.\n*\n* @class World\n*/\n\nvar World = {};\n\nmodule.exports = World;\n\nvar Composite = __nested_webpack_require_356595__(6);\nvar Common = __nested_webpack_require_356595__(0);\n\n(function() {\n\n    /**\n     * See above, aliases for back compatibility only\n     */\n    World.create = Composite.create;\n    World.add = Composite.add;\n    World.remove = Composite.remove;\n    World.clear = Composite.clear;\n    World.addComposite = Composite.addComposite;\n    World.addBody = Composite.addBody;\n    World.addConstraint = Composite.addConstraint;\n\n})();\n\n\n/***/ })\n/******/ ]);\n});\n\n//# sourceURL=webpack://@maissaninc/kidjs/./node_modules/matter-js/build/matter.js?");

/***/ }),

/***/ "./src/animation/color.js":
/*!********************************!*\
  !*** ./src/animation/color.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Color)\n/* harmony export */ });\nclass Color {\n  constructor(color) {\n    let rgb = this.toRGB(color);\n    this.r = rgb.r;\n    this.g = rgb.g;\n    this.b = rgb.b;\n  }\n\n  toRGB(color) {\n    let context = document.createElement('canvas').getContext('2d');\n    context.fillStyle = color;\n    let hex = context.fillStyle;\n    let result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    } : {\n      r: 0,\n      g: 0,\n      b: 0\n    };\n  }\n}\n\n\n//# sourceURL=webpack://@maissaninc/kidjs/./src/animation/color.js?");

/***/ }),

/***/ "./src/animation/index.js":
/*!********************************!*\
  !*** ./src/animation/index.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Animation)\n/* harmony export */ });\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ \"./src/animation/color.js\");\n/* harmony import */ var _tween__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tween */ \"./src/animation/tween.js\");\n\n\n\nclass Animation {\n  constructor(actor, properties, duration, tween = false, queue = false) {\n    this.actor = actor;\n    this.status = queue ? 'queued' : 'ready';\n    this.queue = queue;\n    this.duration = duration * 1000;\n    this.to = properties;\n    this.tween = tween ? tween : window.easing;\n    this.from = {}\n  }\n\n  /**\n   * Advance animation a single frame\n   */\n  update() {\n    if (this.status == 'ready') {\n\n      // Capture initial property values\n      this.from = {};\n      for (const property in this.to) {\n\n        // Property is numeric\n        if (typeof this.actor[property] == 'number') {\n          if (this.actor[property] != this.to[property]) {\n            this.from[property] = this.actor[property];\n          }\n        }\n\n        // Property is a color\n        if (property == 'fill' || property == 'stroke') {\n          this.from[property] = new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.actor[property]);\n          this.to[property] = new _color__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.to[property]);\n        }\n      }\n\n      // Start animation\n      this.status = 'running';\n      this.start = Date.now();\n    }\n\n    if (this.status == 'running') {\n      let t = Date.now() - this.start;\n      for (const property in this.from) {\n        let value;\n\n        // Numeric tween\n        if (typeof this.from[property] == 'number') {\n\n          if (t >= this.duration) {\n            value = this.to[property];\n          } else {\n            switch (this.tween.toLowerCase()) {\n              case 'linear':\n                value = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].linear(t, this.from[property], this.to[property], this.duration);\n                break;\n\n              case 'easein':\n                value = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInQuad(t, this.from[property], this.to[property], this.duration);\n                break;\n\n              case 'easeout':\n                value = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeOutQuad(t, this.from[property], this.to[property], this.duration);\n                break;\n\n              case 'easeinout':\n                value = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInOutQuad(t, this.from[property], this.to[property], this.duration);\n                break;\n\n              case 'easeinelastic':\n                value = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInElastic(t, this.from[property], this.to[property], this.duration);\n                break;\n\n              case 'easeoutelastic':\n                value = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeOutElastic(t, this.from[property], this.to[property], this.duration);\n                break;\n\n              case 'easeinoutelastic':\n              default:\n                value = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInOutElastic(t, this.from[property], this.to[property], this.duration);\n            }\n          }\n\n          // Use direct setter if it exists\n          if (typeof this.actor['_set' + property] == 'function') {\n            this.actor['_set' + property](value);\n\n          // Otherwise use default setter\n          } else {\n            this.actor[property] = value;\n          }\n\n        // Color tween\n        } else {\n          let r, g, b;\n          if (t >= this.duration) {\n            r = this.to[property].r;\n            g = this.to[property].g;\n            b = this.to[property].b;\n          } else {\n            switch (this.tween.toLowerCase()) {\n              case 'linear':\n                r = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].linear(t, this.from[property].r, this.to[property].r, this.duration);\n                g = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].linear(t, this.from[property].g, this.to[property].g, this.duration);\n                b = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].linear(t, this.from[property].b, this.to[property].b, this.duration);\n                break;\n\n              case 'easein':\n                r = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInQuad(t, this.from[property].r, this.to[property].r, this.duration);\n                g = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInQuad(t, this.from[property].g, this.to[property].g, this.duration);\n                b = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInQuad(t, this.from[property].b, this.to[property].b, this.duration);\n                break;\n\n              case 'easeout':\n                r = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeOutQuad(t, this.from[property].r, this.to[property].r, this.duration);\n                g = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeOutQuad(t, this.from[property].g, this.to[property].g, this.duration);\n                b = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeOutQuad(t, this.from[property].b, this.to[property].b, this.duration);\n                break;\n\n              case 'easeinout':\n                r = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInOutQuad(t, this.from[property].r, this.to[property].r, this.duration);\n                g = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInOutQuad(t, this.from[property].g, this.to[property].g, this.duration);\n                b = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInOutQuad(t, this.from[property].b, this.to[property].b, this.duration);\n                break;\n\n              case 'easeinelastic':\n                r = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInElastic(t, this.from[property].r, this.to[property].r, this.duration);\n                g = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInElastic(t, this.from[property].g, this.to[property].g, this.duration);\n                b = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInElastic(t, this.from[property].b, this.to[property].b, this.duration);\n                break;\n\n              case 'easeoutelastic':\n                r = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeOutElastic(t, this.from[property].r, this.to[property].r, this.duration);\n                g = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeOutElastic(t, this.from[property].g, this.to[property].g, this.duration);\n                b = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeOutElastic(t, this.from[property].b, this.to[property].b, this.duration);\n                break;\n\n              case 'easeinoutelastic':\n              default:\n                r = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInOutElastic(t, this.from[property].r, this.to[property].r, this.duration);\n                g = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInOutElastic(t, this.from[property].g, this.to[property].g, this.duration);\n                b = _tween__WEBPACK_IMPORTED_MODULE_1__[\"default\"].easeInOutElastic(t, this.from[property].b, this.to[property].b, this.duration);\n            }\n          }\n          if (Number.isNaN(r)) r = 0;\n          if (Number.isNaN(g)) g = 0;\n          if (Number.isNaN(b)) b = 0;\n          this.actor[property] = `rgb(${r}, ${g}, ${b})`;\n        }\n      }\n      if (t >= this.duration) {\n        this.status = 'complete';\n      }\n    }\n  }\n\n  animate(properties, duration = 1, tween = false) {\n    return this.actor.animate(properties, duration, tween, true);\n  }\n\n  grow(amount, duration = 1, tween = false) {\n    return this.actor.grow(amount, duration, tween, true);\n  }\n\n  shrink(amount, duration = 1, tween = false) {\n    return this.actor.shrink(amount, duration, tween, true);\n  }\n\n  moveTo(x, y, duration = 1, tween = false) {\n    return this.actor.moveTo(x, y, duration, tween, true);\n  }\n\n  move(x, y, duration = 1, tween = false) {\n    return this.actor.move(x, y, duration, tween, true);\n  }\n\n  fade(opacity, duration = 1, tween = 'easeinout') {\n    return this.actor.fade(opacity, duration, tween, true);\n  }\n\n  fadeIn(duration = 1, tween = 'easeinout') {\n    return this.actor.fadeIn(duration, tween, true);\n  }\n\n  fadeOut(duration = 1, tween = 'easeinout') {\n    return this.actor.fadeOut(duration, tween, true);\n  }\n\n  repeat(count = -1) {\n    this.actor.animationRepeat = count;\n  }\n\n  async wait() {\n    await new Promise((resolve) => {\n      this.actor.onAnimationsComplete = resolve;\n    })\n  }\n}\n\n\n//# sourceURL=webpack://@maissaninc/kidjs/./src/animation/index.js?");

/***/ }),

/***/ "./src/animation/tween.js":
/*!********************************!*\
  !*** ./src/animation/tween.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Tween)\n/* harmony export */ });\nclass Tween {\n\n  static linear(t, b, _c, d) {\n    let c = _c - b;\n    return c * t / d + b;\n  }\n\n  static easeInQuad(t, b, _c, d) {\n    let c = _c - b;\n    return c * (t /= d) * t + b;\n  }\n\n  static easeOutQuad(t, b, _c, d) {\n    let c = _c - b;\n    return -c * (t /= d) * (t - 2) + b;\n  }\n\n  static easeInOutQuad(t, b, _c, d) {\n    let c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return c / 2 * t * t + b;\n    } else {\n      return -c / 2 * ((--t) * (t - 2) - 1) + b;\n    }\n  }\n\n  static easeInCubic(t, b, _c, d) {\n    let c = _c - b;\n    return c * (t /= d) * t * t + b;\n  }\n\n  static easeOutCubic(t, b, _c, d) {\n    let c = _c - b;\n    return c * ((t = t / d - 1) * t * t + 1) + b;\n  }\n\n  static easeInOutCubic(t, b, _c, d) {\n    let c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return c / 2 * t * t * t + b;\n    } else {\n      return c / 2 * ((t -= 2) * t * t + 2) + b;\n    }\n  }\n\n  static easeInQuart(t, b, _c, d) {\n    let c = _c - b;\n    return c * (t /= d) * t * t * t + b;\n  }\n\n  static easeOutQuart(t, b, _c, d) {\n    let c = _c - b;\n    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\n  }\n\n  static easeInOutQuart(t, b, _c, d) {\n    let c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return c / 2 * t * t * t * t + b;\n    } else {\n      return -c / 2 * ((t -= 2) * t * t * t - 2) + b;\n    }\n  }\n\n  static easeInQuint(t, b, _c, d) {\n    let c = _c - b;\n    return c * (t /= d) * t * t * t * t + b;\n  }\n\n  static easeOutQuint(t, b, _c, d) {\n    let c = _c - b;\n    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\n  }\n\n  static easeInOutQuint(t, b, _c, d) {\n    let c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return c / 2 * t * t * t * t * t + b;\n    } else {\n      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\n    }\n  }\n\n  static easeInSine(t, b, _c, d) {\n    let c = _c - b;\n    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;\n  }\n\n  static easeOutSine(t, b, _c, d) {\n    let c = _c - b;\n    return c * Math.sin(t / d * (Math.PI / 2)) + b;\n  }\n\n  static easeInOutSine(t, b, _c, d) {\n    let c = _c - b;\n    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;\n  }\n\n  static easeInExpo(t, b, _c, d) {\n    let c = _c - b;\n    return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;\n  }\n\n  static easeOutExpo(t, b, _c, d) {\n    let c = _c - b;\n    return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;\n  }\n\n  static easeInOutExpo(t, b, _c, d) {\n    let c = _c - b;\n    if (t === 0) {\n      return b;\n    }\n    if (t === d) {\n      return b + c;\n    }\n    if ((t /= d / 2) < 1) {\n      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;\n    } else {\n      return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;\n    }\n  }\n\n  static easeInCirc(t, b, _c, d) {\n    let c = _c - b;\n    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;\n  }\n\n  static easeOutCirc(t, b, _c, d) {\n    let c = _c - b;\n    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;\n  }\n\n  static easeInOutCirc(t, b, _c, d) {\n    let c = _c - b;\n    if ((t /= d / 2) < 1) {\n      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;\n    } else {\n      return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;\n    }\n  }\n\n  static easeInElastic(t, b, _c, d) {\n    let c = _c - b;\n    let a, p, s;\n    s = 1.70158;\n    p = 0;\n    a = c;\n    if (t === 0) {\n      return b;\n    } else if ((t /= d) === 1) {\n      return b + c;\n    }\n    if (!p) {\n      p = d * 0.3;\n    }\n    if (a < Math.abs(c)) {\n      a = c;\n      s = p / 4;\n    } else {\n      s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n  }\n\n  static easeOutElastic(t, b, _c, d) {\n    let c = _c - b;\n    let a, p, s;\n    s = 1.70158;\n    p = 0;\n    a = c;\n    if (t === 0) {\n      return b;\n    } else if ((t /= d) === 1) {\n      return b + c;\n    }\n    if (!p) {\n      p = d * 0.3;\n    }\n    if (a < Math.abs(c)) {\n      a = c;\n      s = p / 4;\n    } else {\n      s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;\n  }\n\n  static easeInOutElastic(t, b, _c, d) {\n    let c = _c - b;\n    let a, p, s;\n    s = 1.70158;\n    p = 0;\n    a = c;\n    if (t === 0) {\n      return b;\n    } else if ((t /= d / 2) === 2) {\n      return b + c;\n    }\n    if (!p) {\n      p = d * (0.3 * 1.5);\n    }\n    if (a < Math.abs(c)) {\n      a = c;\n      s = p / 4;\n    } else {\n      s = p / (2 * Math.PI) * Math.asin(c / a);\n    }\n    if (t < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;\n    } else {\n      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;\n    }\n  }\n\n  static easeInBack(t, b, _c, d, s) {\n    let c = _c - b;\n    if (s === void 0) {\n      s = 1.70158;\n    }\n    return c * (t /= d) * t * ((s + 1) * t - s) + b;\n  }\n  static easeOutBack(t, b, _c, d, s) {\n    let c = _c - b;\n    if (s === void 0) {\n      s = 1.70158;\n    }\n    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\n  }\n\n  static easeInOutBack(t, b, _c, d, s) {\n    let c = _c - b;\n    if (s === void 0) {\n      s = 1.70158;\n    }\n    if ((t /= d / 2) < 1) {\n      return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;\n    } else {\n      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;\n    }\n  }\n\n  static easeInBounce(t, b, _c, d) {\n    let c = _c - b;\n    let v;\n    v = tweenFunctions.easeOutBounce(d - t, 0, c, d);\n    return c - v + b;\n  }\n\n  static easeOutBounce(t, b, _c, d) {\n    let c = _c - b;\n    if ((t /= d) < 1 / 2.75) {\n      return c * (7.5625 * t * t) + b;\n    } else if (t < 2 / 2.75) {\n      return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;\n    } else if (t < 2.5 / 2.75) {\n      return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;\n    } else {\n      return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;\n    }\n  }\n\n  static easeInOutBounce(t, b, _c, d) {\n    let c = _c - b;\n    let v;\n    if (t < d / 2) {\n      v = tweenFunctions.easeInBounce(t * 2, 0, c, d);\n      return v * 0.5 + b;\n    } else {\n      v = tweenFunctions.easeOutBounce(t * 2 - d, 0, c, d);\n      return v * 0.5 + c * 0.5 + b;\n    }\n  }\n}\n\n\n//# sourceURL=webpack://@maissaninc/kidjs/./src/animation/tween.js?");

/***/ }),

/***/ "./src/core/math.js":
/*!**************************!*\
  !*** ./src/core/math.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   degreesToRadians: () => (/* binding */ degreesToRadians),\n/* harmony export */   radiansToDegrees: () => (/* binding */ radiansToDegrees),\n/* harmony export */   random: () => (/* binding */ random)\n/* harmony export */ });\n/**\n * Return a random number.\n *\n * @constructor\n * @param {int} a - Minimum value\n * @param {int} b - Maximum value\n */\nfunction random(a, b) {\n\n  // Return random decimal between 0 and 1\n  if (typeof a == 'undefined' && typeof b == 'undefined') {\n    return Math.random();\n  }\n\n  // Return random integer between 0 and first parameter\n  if (typeof b == 'undefined') {\n    return Math.round(Math.random() * a);\n  }\n\n  // Return random integer between first and second parameters\n  return Math.round(Math.random() * (b - a) + a);\n}\n\n/**\n * Convert degrees to radians\n *\n * @param {Number} deg - Angle in degrees\n * @return {Number} Angle in radians\n */\nfunction degreesToRadians(deg) {\n  return deg * (Math.PI / 180);\n}\n\n/**\n * Convert degrees to radians\n *\n * @param {Number} rad - Angle in radians\n * @return {Number} Angle in degrees\n */\nfunction radiansToDegrees(rad) {\n  return rad * (180 / Math.PI);\n}\n\n\n//# sourceURL=webpack://@maissaninc/kidjs/./src/core/math.js?");

/***/ }),

/***/ "./src/core/vector.js":
/*!****************************!*\
  !*** ./src/core/vector.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Vector)\n/* harmony export */ });\nclass Vector {\n  constructor(x, y) {\n    this._x = x;\n    this._y = y;\n  }\n\n  get x() {\n    return this._x;\n  }\n\n  get y() {\n    return this._y;\n  }\n\n  set x(value) {\n    this._x = value;\n    if (typeof this.onchange == 'function') {\n      this.onchange();\n    }\n  }\n\n  set y(value) {\n    this._y = value;\n    if (typeof this.onchange == 'function') {\n      this.onchange();\n    }\n  }\n\n  get length() {\n    return Math.sqrt(\n      Math.pow(this.x, 2) + Math.pow(this.y, 2)\n    );\n  }\n\n  set length(value) {\n    let u = this.normalize().scale(value);\n    this.x = u.x;\n    this.y = u.y;\n  }\n\n  add(v) {\n    return new Vector(this.x + v.x, this.y + v.y);\n  }\n\n  subtract(v) {\n    return new Vector(this.x - v.x, this.y - v.y);\n  }\n\n  scale(s) {\n    return new Vector(this.x * s, this.y * s);\n  }\n\n  normalize() {\n    let l = this.length;\n    return l > 0 ? new Vector(this.x / l, this.y / l) : new Vector(0, 0);\n  }\n\n  dot(v) {\n    return (this.x * v.x + this.y * v.y);\n  }\n\n  cross(v) {\n    return (this.x * v.y - this.y * v.x);\n  }\n\n  rotate(deg) {\n    let angle = deg * (Math.PI / 180);\n    return new Vector(\n      this.x * Math.cos(angle) - this.y * Math.sin(angle),\n      this.x * Math.sin(angle) + this.y * Math.cos(angle)\n    );\n  }\n\n  distance(v) {\n    return Math.sqrt(\n      Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2)\n    );\n  }\n\n  static average(set) {\n    let v = new Vector(0, 0);\n    for (let i = 0; i < set.length; i = i + 1) {\n      v.x = v.x + set[i].x;\n      v.y = v.y + set[i].y;\n    }\n    v.x = v.x / set.length;\n    v.y = v.y / set.length;\n    return v;\n  }\n}\n\n\n//# sourceURL=webpack://@maissaninc/kidjs/./src/core/vector.js?");

/***/ }),

/***/ "./src/libraries/hand-tracker/index.js":
/*!*********************************************!*\
  !*** ./src/libraries/hand-tracker/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HandTracker: () => (/* binding */ HandTracker)\n/* harmony export */ });\n/* harmony import */ var _mediapipe_tasks_vision__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mediapipe/tasks-vision */ \"./node_modules/@mediapipe/tasks-vision/vision_bundle.mjs\");\n/* harmony import */ var _palm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./palm */ \"./src/libraries/hand-tracker/palm.js\");\n/* harmony import */ var _phalange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./phalange */ \"./src/libraries/hand-tracker/phalange.js\");\n\n\n\n\nclass HandTracker {\n\n  /**\n   * Create hand tracker.\n   *\n   * @constructor\n   */\n  constructor() {\n    this.active = false;\n  }\n\n  /**\n   * Initialize hand tracker.\n   *\n   * @constructor\n   */\n  async init() {\n    const vision = await _mediapipe_tasks_vision__WEBPACK_IMPORTED_MODULE_0__.FilesetResolver.forVisionTasks(\n      'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm'\n    );\n    this.handLandmarker = await _mediapipe_tasks_vision__WEBPACK_IMPORTED_MODULE_0__.HandLandmarker.createFromOptions(vision, {\n      baseOptions: {\n        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',\n        delegate: 'GPU'\n      },\n      runningMode: 'VIDEO',\n      numHands: 2\n    });\n    this.videoElement = document.createElement('video');\n    this.videoElement.setAttribute('autoplay', '');\n  }\n\n  async start() {\n    await this.init();\n\n    navigator.mediaDevices.getUserMedia({\n      video: true\n    }).then((stream) => {\n      this.videoElement.srcObject = stream;\n      this.videoElement.addEventListener('loadeddata', () => {\n        this.active = true;\n        this.onAnimationFrame();\n      });\n    });\n\n    this.palm = new _palm__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.phalanges = [];\n    for (let i = 0; i < 20; i = i + 1) {\n      this.phalanges.push(new _phalange__WEBPACK_IMPORTED_MODULE_2__[\"default\"]());\n    }\n  }\n\n  stop() {\n    this.active = false;\n  }\n\n  onAnimationFrame() {\n    let results = this.handLandmarker.detectForVideo(\n      this.videoElement, performance.now()\n    );\n    \n    if (results.landmarks.length > 0) {\n      this.palm.show(\n        window.stage.canvas.width / 2 - results.landmarks[0][0].x * window.stage.canvas.width / 2,\n        results.landmarks[0][0].y * window.stage.canvas.height / 2,\n        window.stage.canvas.width / 2 - results.landmarks[0][1].x * window.stage.canvas.width / 2,\n        results.landmarks[0][1].y * window.stage.canvas.height / 2,\n        window.stage.canvas.width / 2 - results.landmarks[0][5].x * window.stage.canvas.width / 2,\n        results.landmarks[0][5].y * window.stage.canvas.height / 2,\n        window.stage.canvas.width / 2 - results.landmarks[0][9].x * window.stage.canvas.width / 2,\n        results.landmarks[0][9].y * window.stage.canvas.height / 2,\n        window.stage.canvas.width / 2 - results.landmarks[0][13].x * window.stage.canvas.width / 2,\n        results.landmarks[0][13].y * window.stage.canvas.height / 2,\n        window.stage.canvas.width / 2 - results.landmarks[0][17].x * window.stage.canvas.width / 2,\n        results.landmarks[0][17].y * window.stage.canvas.height / 2\n      );\n      for (let i = 0; i < this.phalanges.length; i = i + 1) {\n        let x1 = window.stage.canvas.width / 2 - results.landmarks[0][(i % 4 == 0) ? 0 : i].x * window.stage.canvas.width / 2;\n        let y1 = results.landmarks[0][(i % 4 == 0) ? 0 : i].y * window.stage.canvas.height / 2;\n        let x2 = window.stage.canvas.width / 2 - results.landmarks[0][i + 1].x * window.stage.canvas.width / 2;\n        let y2 = results.landmarks[0][i + 1].y * window.stage.canvas.height / 2;\n        this.phalanges[i].show(x1, y1, x2, y2);\n      }\n    } else {\n      this.palm.hide();\n      for (let i = 0; i < this.phalanges.length; i = i + 1) {\n        this.phalanges[i].hide();\n      }\n    }\n\n    if (this.active) {\n      requestAnimationFrame(this.onAnimationFrame.bind(this));\n    }\n  }\n}\n\nwindow.HandTracker = new HandTracker();\n\n//# sourceURL=webpack://@maissaninc/kidjs/./src/libraries/hand-tracker/index.js?");

/***/ }),

/***/ "./src/libraries/hand-tracker/palm.js":
/*!********************************************!*\
  !*** ./src/libraries/hand-tracker/palm.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Palm)\n/* harmony export */ });\n/* harmony import */ var _stage_actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stage/actor */ \"./src/stage/actor.js\");\n/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ \"./src/core/vector.js\");\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! matter-js */ \"./node_modules/matter-js/build/matter.js\");\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(matter_js__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nclass Palm extends _stage_actor__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n\n  /**\n   * Create a finger segment (aka phalange)\n   *\n   * @constructor\n   */\n  constructor() {\n    super();\n    this.a = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.b = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.c = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.d = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.e = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.f = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.body = false;\n    this.width = 60;\n  }\n\n  /**\n   * Update bounding polygin.\n   */\n  updateBoundingPolygon() {\n    this.boundingPolygon = [\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.a.x, this.a.y),\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.b.x, this.b.y),\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.c.x, this.c.y),\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.d.x, this.d.y),\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.e.x, this.e.y),\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.f.x, this.f.y)\n    ];\n\n    // Determine center point\n    let sumX = 0;\n    let sumY = 0;\n    for (let i = 0; i < this.boundingPolygon.length; i = i + 1) {\n      sumX = sumX + this.boundingPolygon[i].x;\n      sumY = sumY + this.boundingPolygon[i].y;\n    }\n    this.x = sumX / this.boundingPolygon.length;\n    this.y = sumY / this.boundingPolygon.length;\n\n    // Reposition vectors around center point\n    for (let i = 0; i < this.boundingPolygon.length; i = i + 1) {\n      this.boundingPolygon[i].x = this.boundingPolygon[i].x - this.x;\n      this.boundingPolygon[i].y = this.boundingPolygon[i].y - this.y;\n    }\n  }\n\n  /**\n   * Update position if landmarks.\n   * \n   * @param {number} a x coordinate\n   * @param {number} a y coordinate\n   * @param {number} b x coordinate\n   * @param {number} b y coordinate\n   * @param {number} c x coordinate\n   * @param {number} c y coordinate\n   * @param {number} d x coordinate\n   * @param {number} d y coordinate\n   * @param {number} e x coordinate\n   * @param {number} e y coordinate\n   * @param {number} f x coordinate\n   * @param {number} f y coordinate\n   */\n  show(ax, ay, bx, by, cx, cy, dx, dy, ex, ey, fx, fy) {\n\n    // Update landmarks\n    this.a.x = ax;\n    this.a.y = ay;\n    this.b.x = bx;\n    this.b.y = by;\n    this.c.x = cx;\n    this.c.y = cy;\n    this.d.x = dx;\n    this.d.y = dy;\n    this.e.x = ex;\n    this.e.y = ey;\n    this.f.x = fx;\n    this.f.y = fy;\n    this.updateBoundingPolygon();\n\n    // Create body\n    if (!this.body) {\n      this.body = matter_js__WEBPACK_IMPORTED_MODULE_2___default().Bodies.fromVertices(0, 0, this.boundingPolygon);\n      matter_js__WEBPACK_IMPORTED_MODULE_2___default().Body.setStatic(this.body, true);\n      this.body.collisionFilter.group = -999;\n      window.stage.addChild(this);\n\n    // Update body\n    } else {\n      matter_js__WEBPACK_IMPORTED_MODULE_2___default().Body.setPosition(this.body, {x: this.x, y: this.y});\n      matter_js__WEBPACK_IMPORTED_MODULE_2___default().Body.setVertices(this.body, this.boundingPolygon);\n    }\n  }\n\n  /**\n   * Remove phalange.\n   */\n  hide() {\n    this.body = false;\n    window.stage.removeChild(this);\n  }\n\n  /**\n   * Render phalange.\n   * \n   * @param {CanvasRenderingContext2D} context \n   */\n  render(context) {\n    if (this.body) {\n      context.beginPath();\n      context.moveTo(this.a.x, this.a.y);\n      context.lineTo(this.b.x, this.b.y);\n      context.lineTo(this.c.x, this.c.y);\n      context.lineTo(this.d.x, this.d.y);\n      context.lineTo(this.e.x, this.e.y);\n      context.lineTo(this.f.x, this.f.y);\n      context.closePath();\n      context.lineWidth = this.width;\n      context.lineCap = 'round';\n      context.lineJoin = 'round';\n      context.strokeStyle = '#ffbc41';\n      context.stroke();\n      context.fillStyle = '#ffbc41';\n      context.fill();\n    }\n  }\n}\n\n//# sourceURL=webpack://@maissaninc/kidjs/./src/libraries/hand-tracker/palm.js?");

/***/ }),

/***/ "./src/libraries/hand-tracker/phalange.js":
/*!************************************************!*\
  !*** ./src/libraries/hand-tracker/phalange.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Phalange)\n/* harmony export */ });\n/* harmony import */ var _stage_actor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stage/actor */ \"./src/stage/actor.js\");\n/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/vector */ \"./src/core/vector.js\");\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! matter-js */ \"./node_modules/matter-js/build/matter.js\");\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(matter_js__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nclass Phalange extends _stage_actor__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n\n  /**\n   * Create a finger segment (aka phalange)\n   *\n   * @constructor\n   */\n  constructor() {\n    super();\n    this.a = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.b = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    this.body = false;\n    this.width = 60;\n  }\n\n  /**\n   * Update bounding polygin.\n   */\n  updateBoundingPolygon() {\n    this.boundingPolygon = [\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n        this.a.x + Math.cos(this.angle + Math.PI / 2) * this.width / 2,\n        this.a.y - Math.sin(this.angle + Math.PI / 2) * this.width / 2\n      ),\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n        this.a.x + Math.cos(this.angle - Math.PI / 2) * this.width / 2,\n        this.a.y - Math.sin(this.angle - Math.PI / 2) * this.width / 2\n      ),\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n        this.b.x + Math.cos(this.angle - Math.PI / 2) * this.width / 2,\n        this.b.y - Math.sin(this.angle - Math.PI / 2) * this.width / 2\n      ),\n      new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n        this.b.x + Math.cos(this.angle + Math.PI / 2) * this.width / 2,\n        this.b.y - Math.sin(this.angle + Math.PI / 2) * this.width / 2\n      )\n    ];\n\n    // Determine center point\n    let sumX = 0;\n    let sumY = 0;\n    for (let i = 0; i < this.boundingPolygon.length; i = i + 1) {\n      sumX = sumX + this.boundingPolygon[i].x;\n      sumY = sumY + this.boundingPolygon[i].y;\n    }\n    this.x = sumX / this.boundingPolygon.length;\n    this.y = sumY / this.boundingPolygon.length;\n\n    // Reposition vectors around center point\n    for (let i = 0; i < this.boundingPolygon.length; i = i + 1) {\n      this.boundingPolygon[i].x = this.boundingPolygon[i].x - this.x;\n      this.boundingPolygon[i].y = this.boundingPolygon[i].y - this.y;\n    }\n  }\n\n  /**\n   * Update position if landmarks.\n   * \n   * @param {number} x1 coordinate\n   * @param {number} y1 coordinate\n   * @param {number} x2 coordinate\n   * @param {number} y2 coordinate\n   */\n  show(x1, y1, x2, y2) {\n\n    // Update landmarks\n    this.a.x = x1;\n    this.a.y = y1;\n    this.b.x = x2;\n    this.b.y = y2;\n\n    // Update angle\n    let u = this.b.subtract(this.a);\n    let v = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1, 0);\n    this.angle = Math.acos(u.dot(v) / (u.length * v.length));\n    this.updateBoundingPolygon();\n\n    // Create body\n    if (!this.body) {\n      this.body = matter_js__WEBPACK_IMPORTED_MODULE_2___default().Bodies.fromVertices(0, 0, this.boundingPolygon);\n      matter_js__WEBPACK_IMPORTED_MODULE_2___default().Body.setStatic(this.body, true);\n      this.body.collisionFilter.group = -999;\n      window.stage.addChild(this);\n\n    // Update body\n    } else {\n      matter_js__WEBPACK_IMPORTED_MODULE_2___default().Body.setPosition(this.body, {x: this.x, y: this.y});\n      matter_js__WEBPACK_IMPORTED_MODULE_2___default().Body.setVertices(this.body, this.boundingPolygon);\n    }\n  }\n\n  /**\n   * Remove phalange.\n   */\n  hide() {\n    this.body = false;\n    window.stage.removeChild(this);\n  }\n\n  /**\n   * Render phalange.\n   * \n   * @param {CanvasRenderingContext2D} context \n   */\n  render(context) {\n    if (this.body) {\n      context.beginPath();\n      context.moveTo(this.a.x, this.a.y);\n      context.lineTo(this.b.x, this.b.y);\n      context.lineWidth = this.width;\n      context.lineCap = 'round';\n      context.strokeStyle = '#ffbc41';\n      context.stroke();\n\n      // Debug information\n      if (window.debug) {\n\n        // Bounding polygon\n        context.beginPath();\n        context.moveTo(this.x + this.boundingPolygon[0].x, this.y + this.boundingPolygon[0].y);\n        for (let i = 1; i < this.boundingPolygon.length; i = i + 1) {\n          context.lineTo(this.x + this.boundingPolygon[i].x, this.y + this.boundingPolygon[i].y);\n        }\n        context.closePath();\n        context.lineWidth = 1;\n        context.strokeStyle = 'red';\n        context.stroke();\n      \n        // Landmarks\n        context.strokeStyle = 'purple';\n        context.beginPath();\n        context.arc(this.a.x, this.a.y, 20, 0, Math.PI * 2);\n        context.stroke();\n        context.beginPath();\n        context.arc(this.b.x, this.b.y, 20, 0, Math.PI * 2);\n        context.stroke();\n\n        // Bounding box\n        context.beginPath();\n        context.rect(this.bounds.min.x, this.bounds.min.y, this.bounds.max.x - this.bounds.min.x, this.bounds.max.y - this.bounds.min.y);\n        context.strokeStyle = 'black';\n        context.lineWidth = 0.5;\n        context.stroke();\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack://@maissaninc/kidjs/./src/libraries/hand-tracker/phalange.js?");

/***/ }),

/***/ "./src/stage/actor.js":
/*!****************************!*\
  !*** ./src/stage/actor.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Actor)\n/* harmony export */ });\n/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../animation */ \"./src/animation/index.js\");\n/* harmony import */ var _core_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/vector */ \"./src/core/vector.js\");\n/* harmony import */ var _core_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/math */ \"./src/core/math.js\");\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! matter-js */ \"./node_modules/matter-js/build/matter.js\");\n/* harmony import */ var matter_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(matter_js__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\nclass Actor {\n\n  /**\n   * Create a new actor and add it to the stage.\n   *\n   * @constructor\n   * @param {int} x - Initial x coordinate\n   * @param {int} y - Initial y coordinate\n   */\n  constructor(x, y) {\n    this.frame = 0;\n    this.state = 'default';\n\n    // Internal properties\n    this.position = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](x, y);\n    this._angle = 0;\n    this._angularVelocity = 0;\n    this.spinnable = true;\n    this._bounciness = 0.8;\n    this._ghost = false;\n    this._collides = true;\n\n    // External properties\n    this.locked = false;\n\n    // Detect change in velocity\n    this.velocity = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0);\n    this.velocity.onchange = () => {\n      this.anchored = false;\n      if (this.body) {\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setVelocity(this.body, this.velocity);\n      }\n    }\n\n    // Animation queue\n    this.animations = [];\n    this.animationActive = 0;\n    this.animationRepeat = 0;\n\n    // Event listeners\n    this.eventListeners = {};\n  }\n\n  get x() {\n    return this.body ? this.body.position.x : this.position.x;\n  }\n\n  get y() {\n    return this.body ? this.body.position.y : this.position.y;\n  }\n  \n  _setx(value) {\n    if (!this.locked) {\n      this.position.x = value;\n      if (this.body) {\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setPosition(this.body, this.position);\n      }\n    }\n  }\n\n  set x(value) {\n    if (!this.locked) {\n      this.cancelAnimations('x');\n      this._setx(value);\n    }\n  }\n\n  _sety(value) {\n    if (!this.locked) {\n      this.position.y = value;\n      if (this.body) {\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setPosition(this.body, this.position);\n      }\n    }\n  }\n\n  set y(value) {\n    if (!this.locked) {\n      this.cancelAnimations('y');\n      this._sety(value);\n    }\n  }\n\n  get angle() {\n    if (this.body) {\n      if (this.body.parent.id != this.body.id) {\n        return (0,_core_math__WEBPACK_IMPORTED_MODULE_2__.radiansToDegrees)(this.body.parent.angle) + this._angle;\n      } else {\n        return (0,_core_math__WEBPACK_IMPORTED_MODULE_2__.radiansToDegrees)(this.body.angle);\n      }\n    }\n    return this._angle;\n  }\n\n  set angle(value) {\n    if (!this.locked) {\n      this._angle = value;\n      if (this.body) {\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setAngle(this.body, (0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(this._angle));\n      }\n    }\n  }\n\n  get angularVelocity() {\n    if (this.body && !this.body.isStatic) {\n      return (0,_core_math__WEBPACK_IMPORTED_MODULE_2__.radiansToDegrees)(this.body.angularVelocity);\n    }\n    return this._angularVelocity;\n  }\n\n  set angularVelocity(value) {\n    if (!this.locked) {\n      this._angularVelocity = value;\n      if (this.body) {\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setAngularVelocity(this.body, (0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(this._angularVelocity));\n      }\n    }\n  }\n\n  set anchored(value) {\n    if (!this.locked) {\n      if (this.body && value != this.anchored) {\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setStatic(this.body, value);\n        this.body.restitution = this._bounciness;\n      }\n    }\n  }\n\n  get anchored() {\n    if (this.body) {\n      return this.body.isStatic;\n    } else {\n      return true;\n    }\n  }\n\n  set bounciness(value) {\n    if (!this.locked) {\n      this._bounciness = value;\n      if (this.body) {\n        this.body.restitution = value;\n      }\n    }\n  }\n\n  get bounciness() {\n    return this.body ? this.body.restitution : 0;\n  }\n\n  get bounds() {\n    return this.body ? this.body.bounds : undefined;\n  }\n\n  set collides(value) {\n    if (!this.locked) {\n      this._collides = value;\n    }\n  }\n\n  get collides() {\n    return this._collides;\n  }\n\n  set direction(value) {\n    if (!this.locked) {\n      if (this.body) {\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setVelocity(this.body, new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n          Math.cos((0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(value)) * this.speed,\n          Math.sin((0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(value)) * this.speed\n        ));\n      }\n    }\n  }\n\n  get direction() {\n    if (this.body) {\n      let a = Math.atan2(this.body.velocity.y, this.body.velocity.x)\n      if (a < 0) a = a + Math.PI * 2;\n      return (0,_core_math__WEBPACK_IMPORTED_MODULE_2__.radiansToDegrees)(a);\n    }\n  }\n\n  set friction(value) {\n    if (!this.locked) {\n      if (this.body) {\n        this.body.friction = value;\n        this.body.frictionStatic = value;\n      }\n    }\n  }\n\n  get friction() {\n    return this.body ? this.body.friction : 0;\n  }\n\n  set ghost(value) {\n    if (!this.locked) {\n      if (value == this._ghost) return;\n      this._ghost = value;\n      if (this.body) {\n        if (value) {\n          this.body.isSensor = true;\n        } else {\n          this.body.isSensor = false;\n        }\n      }\n    }\n  }\n\n  get ghost() {\n    return this._ghost;\n  }\n\n  set inertia(value) {\n    if (!this.locked) {\n      if (this.body) {\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setInertia(this.body, value);\n      }\n    }\n  }\n\n  get inertia() {\n    return this.body ? this.body.inertia : Infinity;\n  }\n\n  set mass(value) {\n    if (!this.locked) {\n      if (this.body) {\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setMass(this.body, value);\n      }\n    }\n  }\n\n  get mass() {\n    return this.body ? this.body.mass : 0;\n  }\n\n  set speed(value) {\n    if (!this.locked) {\n      if (this.body) {\n        this.anchored = false;\n        matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setVelocity(this.body, new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n          Math.cos((0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(this.direction)) * value,\n          Math.sin((0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(this.direction)) * value\n        ));\n      }\n    }\n  }\n\n  get speed() {\n    if (this.body) {\n      let v = new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.body.velocity.x, this.body.velocity.y);\n      return v.length;\n    }\n    return 0;\n  }\n\n  /**\n   * Update the position of Actor on stage.\n   * This is called each frame.\n   */\n  update() {\n    this.frame++;\n\n    // Apply angular velocity\n    if (!this.spinnable) {\n      this.angularVelocity = 0;\n    } else {\n      if (!this.body || this.body.isStatic) {\n        this.angle = this.angle + this.angularVelocity;\n      }\n    }\n\n    // Update velocity property\n    if (this.body) {\n      this.velocity._x = this.body.velocity.x;\n      this.velocity._y = this.body.velocity.y;\n    }\n\n    // Update animations\n    if (this.animations.length > 0) {\n      if (this.animations[this.animationActive].status == 'queued') {\n        this.animations[this.animationActive].status = 'ready';\n      }\n      for (let i = this.animationActive; i < this.animations.length; i = i + 1) {\n        if (this.animations[i].status == 'queued') break;\n        this.animations[i].update();\n      }\n      if (this.animations[this.animationActive].status == 'complete') {\n        this.animationActive = this.animationActive + 1;\n\n        // Queue complete\n        if (this.animationActive == this.animations.length) {\n\n          // Repeat animations\n          if (this.animationRepeat != 0) {\n            this.animationActive = 0;\n            for (let i = 0; i < this.animations.length; i = i + 1) {\n              this.animations[i].status = this.animations[i].queue ? 'queued' : 'ready';\n            }\n            if (this.animationRepeat > 0) {\n              this.animationRepeat = this.animationRepeat - 1;\n            }\n\n          // Clear queue\n          } else {\n            if (typeof this.onAnimationsComplete == 'function') {\n              this.onAnimationsComplete();\n              this.onAnimationsComplete = null;\n            }\n            this.animations = [];\n            this.animationActive = 0;\n            this.animationRepeat = 0;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Rotate specified number of degrees.\n   *\n   * @param {float} angle - Number of degrees to rotate\n   * @return {Actor} Reference to self\n   */\n  rotate(degrees) {\n    this.angle = this.angle + degrees;\n    if (this.body) {\n      matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setAngle(this.body, (0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(this.angle));\n    }\n    return this;\n  }\n\n  /**\n   * Move forward in the direction of current rotation.\n   *\n   * @param {float} distance - Number of pixels to move\n   * @return {Actor} Reference to self\n   */\n  forward(distance) {\n    this.position.x = this.x + Math.cos((0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(this.angle)) * distance;\n    this.position.y = this.y + Math.sin((0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(this.angle)) * distance;\n    if (this.body) {\n      matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setPosition(this.body, this.position);\n    }\n    return this;\n  }\n\n  /**\n   * Move backward in the direction of current rotation.\n   *\n   * @param {float} distance - Number of pixels to move\n   * @param {float} axis - Angle of axis to move along\n   * @return {Actor} Reference to self\n   */\n  backward(distance) {\n    let x = this.x - Math.cos((0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(this.angle)) * distance;\n    let y = this.y - Math.sin((0,_core_math__WEBPACK_IMPORTED_MODULE_2__.degreesToRadians)(this.angle)) * distance;\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  /**\n   * Add animation.\n   *\n   * @param {object} properties - Properties to animate\n   * @param {int} duration - Duration to animation properties over\n   * @param {string} tween - Easing function\n   * @param {boolean} queue - Delay until active animations complete\n   * @return void\n   */\n  animate(properties, duration, tween = false, queue = false) {\n    let animation = new _animation__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, properties, duration, tween, queue);\n    this.animations.push(animation);\n    return animation;\n  }\n\n  /**\n   * Move to a new position.\n   *\n   * @param {int} x - Destination x coordinate\n   * @param {int} y - Destination y coorindate\n   * @param {int} duration - Length of animation in seconds\n   * @param {string} tween - Easing function\n   * @param {boolean} queue - Delay until active animations complete\n   * @return {Animation} Animation object\n   */\n  moveTo(x, y, duration = 1, tween = false, queue = false) {\n    return this.animate({\n      x: x,\n      y: y\n    }, duration, tween, queue);\n  }\n\n  /**\n   * Move relative to current position.\n   *\n   * @param {int} x - Number of pixels to move along x axis\n   * @param {int} y - Number of pixels to move along y axis\n   * @param {int} duration - Length of animation in seconds\n   * @param {string} tween - Easing function\n   * @param {boolean} queue - Delay until active animations complete\n   * @return {Animation} Animation object\n   */\n  move(x = 0, y = 0, duration = 1, tween = false, queue = false) {\n    return this.moveTo(this.x + x, this.y + y, duration, tween, queue);\n  }\n\n  /**\n   * Shrink size.\n   *\n   * @param {int} amount - Number of pixels to shrink\n   * @param {int} duration - Length of animation in seconds\n   * @param {string} tween - Easing function\n   * @param {boolean} queue - Delay until active animations complete\n   * @return {Animation} Animation object\n   */\n  shrink(amount, duration = 1, tween = false, queue = false) {\n    return this.grow(-amount, duration, tween, queue);\n  }\n\n  /**\n   * Fade opacity.\n   *\n   * @param {number} opacity - Target opacity\n   * @param {int} duration - Length of animation in seconds\n   * @param {string} tween - Easing function\n   * @param {boolean} queue - Delay until active animations complete\n   * @return {Animation} Animation object\n   */\n  fade(opacity, duration = 1, tween = 'easeinout', queue = false) {\n    return this.animate({\n      opacity: opacity\n    }, duration, tween, queue);\n  }\n\n  /**\n   * Fade in.\n   *\n   * @param {number} duration - Length of animation in seconds\n   * @param {string} tween - Easing function\n   * @param {boolean} queue - Delay until active animations complete\n   * @return {Animation} Animation object\n   */\n  fadeIn(duration = 1, tween = 'easeinout', queue = false) {\n    return this.fade(1, duration, tween, queue);\n  }\n\n  /**\n   * Fade out.\n   *\n   * @param {number} duration - Length of animation in seconds\n   * @param {string} tween - Easing function\n   * @param {boolean} queue - Delay until active animations complete\n   * @return {Animation} Animation object\n   */\n  fadeOut(duration = 1, tween = 'easeinout', queue = false) {\n    return this.fade(0, duration, tween, queue);\n  }\n\n\n  /**\n   * Cancel animations\n   * \n   * @param {string} property - Optional, cancel animations containing this property\n   */\n  cancelAnimations(property = false) {\n    for (let i = 0; i < this.animations.length; i = i + 1) {\n      if (property) {\n        if (typeof this.animations[i].to[property] != 'undefined') {\n          this.animations[i].status = 'complete';\n        }\n      } else {\n        this.animations[i].status = 'complete';\n      }\n    }\n  }\n\n  /**\n   * Apply directional force.\n   *\n   * @param {int} x - Horizontal force\n   * @param {int} y - Vertical force\n   * @return {Actor} Reference to self\n   */\n  push(x = 0, y = 0) {\n    if (this.body) {\n      this.anchored = false;\n      this.velocity._x = this.body.velocity.x + x;\n      this.velocity._y = this.body.velocity.y + y;\n      matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setVelocity(this.body, new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n        this.body.velocity.x + x,\n        this.body.velocity.y + y\n      ));\n    }\n    if (this.children) {\n      this.anchored = false;\n      for (let i = 0; i < this.children.length; i = i + 1) {\n        if (this.children[i].body) {\n          this.children[i].velocity._x = this.children[i].body.velocity.x + x;\n          this.children[i].velocity._y = this.children[i].body.velocity.y + y;    \n          matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setVelocity(this.children[i].body, new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n            this.children[i].body.velocity.x + x,\n            this.children[i].body.velocity.y + y\n          ));\n        }\n      }\n    }\n  }\n\n  /**\n   * Start spinning motion.\n   *\n   * @param {float} speed - Angular velocity\n   * @return {Actor} Reference to self\n   */\n  spin(speed = 1) {\n    this.angularVelocity = speed;\n    return this;\n  }\n\n  /**\n   * Explode object.\n   */\n  explode() {\n    // Overridden by derived class\n  }\n\n  /**\n   * Stop all motion.\n   */\n  stop() {\n    if (this.body) {\n      matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setAngularVelocity(this.body, 0);\n      matter_js__WEBPACK_IMPORTED_MODULE_3___default().Body.setVelocity(this.body, new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0));\n    }\n    this.frame = 0;\n    this.state = 'default';\n  }\n\n  /**\n   * Determine if this Actor is a polygon.\n   *\n   * @returns {boolean} True if Actor is a polygon.\n   */\n  isPolygon() {\n    if (this.boundingPolygon && this.boundingPolygon.length > 2) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine if Actor contains point.\n   *\n   * @param {int} x - Point X coordinate\n   * @param {int} y - Point Y coordinate\n   * @return {boolean}\n   */\n  containsPoint(x, y) {\n    if (this.body) {\n      return matter_js__WEBPACK_IMPORTED_MODULE_3___default().Bounds.contains(this.body.bounds, new _core_vector__WEBPACK_IMPORTED_MODULE_1__[\"default\"](x, y));\n    }\n  }\n\n  /**\n   * Add event listener to actor.\n   *\n   * @param {string} [event] - Name of event.\n   * @param {function} [handler] - Event handler to execute when event occurs.\n   * @param {object} [meta] - Additional details about event handler.\n   */\n  addEventListener(event, handler, meta = {}) {\n    if (event == 'doubleclick') {\n      event = 'dblclick';\n    }\n    if (this.eventListeners[event] == undefined) {\n      this.eventListeners[event] = [];\n    }\n    this.eventListeners[event].push({\n      handler: handler,\n      ...meta\n    });\n  }\n\n  /**\n   * Alias for add event listener.\n   *\n   * @param {string} [event] - Name of event.\n   * @param {function} [handler] - Event handler to execute when event occurs.\n   */\n  on(event, handler) {\n    if (typeof event === 'string') {\n      if (typeof handler === 'string') {\n        if (typeof this[handler] == 'function') {\n          handler = this[handler];\n        } else if (typeof window._kidjs_.get(handler) == 'function') {\n          handler = window._kidjs_.get(handler);\n        }\n      }\n      this.addEventListener(event, handler);\n    }\n  }\n\n  /**\n   * Remove event listener from actor.\n   *\n   * @param {string} [event] - Name of event.\n   * @param {function} [handler] - Event handler to remove.\n   */\n  removeEventListener(event, handler) {\n    if (this.eventListeners[event] !== undefined) {\n      this.eventListeners[event] = this.eventListeners[event].filter(\n        item => item.handler !== handler\n      );\n    }\n  }\n\n  /**\n   * Execute event handler.\n   *\n   * @param {Event} [event] - Event object.\n   */\n  dispatchEvent(event, context = this) {\n    if (this.eventListeners[event.type] !== undefined) {\n      for (let listener of this.eventListeners[event.type]) {\n        switch (event.type) {\n          case 'collision':\n            listener.handler.call(context, event.detail);\n            break;\n          default:\n            listener.handler.call(context);\n        }\n      }\n    }\n  }\n\n  /**\n   * Hide actor.\n   */\n  hide() {\n    this.invisible = true;\n    if (this.body) {\n      this.body.isSensor = true\n      this.collides = false\n    } \n  }\n\n  /**\n   * Show actor.\n   */\n  show() {\n    this.invisible = false;\n    if (this.body) {\n      this.body.isSensor = this._ghost;\n      this.collides = true;\n    } \n  }\n\n  /**\n   * Remove actor from stage.\n   */\n  remove() {\n    if (!this.locked) {\n      window.stage.removeChild(this);\n    }\n  }\n\n  /**\n   * Assign properties of another actor to this one.\n   *\n   * @param {Actor} source\n   */\n  assign(source) {\n    this.x = source.x;\n    this.y = source.y;\n    this.angle = source.angle;\n    this.anchored = source.anchored;\n    for (let type in source.eventListeners) {\n      this.eventListeners[type] = source.eventListeners[type].filter(\n        item => !item.group\n      );\n    }\n  }\n}\n\n\n//# sourceURL=webpack://@maissaninc/kidjs/./src/stage/actor.js?");

/***/ }),

/***/ "./node_modules/@mediapipe/tasks-vision/vision_bundle.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@mediapipe/tasks-vision/vision_bundle.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DrawingUtils: () => (/* binding */ Na),\n/* harmony export */   FaceDetector: () => (/* binding */ sh),\n/* harmony export */   FaceLandmarker: () => (/* binding */ yh),\n/* harmony export */   FaceStylizer: () => (/* binding */ _h),\n/* harmony export */   FilesetResolver: () => (/* binding */ Xo),\n/* harmony export */   GestureRecognizer: () => (/* binding */ Ah),\n/* harmony export */   HandLandmarker: () => (/* binding */ kh),\n/* harmony export */   HolisticLandmarker: () => (/* binding */ Rh),\n/* harmony export */   ImageClassifier: () => (/* binding */ Mh),\n/* harmony export */   ImageEmbedder: () => (/* binding */ Ph),\n/* harmony export */   ImageSegmenter: () => (/* binding */ Uh),\n/* harmony export */   ImageSegmenterResult: () => (/* binding */ Ch),\n/* harmony export */   InteractiveSegmenter: () => (/* binding */ rc),\n/* harmony export */   InteractiveSegmenterResult: () => (/* binding */ Dh),\n/* harmony export */   MPImage: () => (/* binding */ Ka),\n/* harmony export */   MPMask: () => (/* binding */ Sa),\n/* harmony export */   ObjectDetector: () => (/* binding */ ic),\n/* harmony export */   PoseLandmarker: () => (/* binding */ hc),\n/* harmony export */   VisionTaskRunner: () => (/* binding */ ih)\n/* harmony export */ });\nvar t=\"undefined\"!=typeof self?self:{};function e(e){t:{for(var n=[\"CLOSURE_FLAGS\"],r=t,i=0;i<n.length;i++)if(null==(r=r[n[i]])){n=null;break t}n=r}return null!=(e=n&&n[e])&&e}function n(){throw Error(\"Invalid UTF8\")}function r(t,e){return e=String.fromCharCode.apply(null,e),null==t?e:t+e}let i,s;const o=\"undefined\"!=typeof TextDecoder;let a;const h=\"undefined\"!=typeof TextEncoder;function c(t){if(h)t=(a||=new TextEncoder).encode(t);else{let n=0;const r=new Uint8Array(3*t.length);for(let i=0;i<t.length;i++){var e=t.charCodeAt(i);if(128>e)r[n++]=e;else{if(2048>e)r[n++]=e>>6|192;else{if(55296<=e&&57343>=e){if(56319>=e&&i<t.length){const s=t.charCodeAt(++i);if(56320<=s&&57343>=s){e=1024*(e-55296)+s-56320+65536,r[n++]=e>>18|240,r[n++]=e>>12&63|128,r[n++]=e>>6&63|128,r[n++]=63&e|128;continue}i--}e=65533}r[n++]=e>>12|224,r[n++]=e>>6&63|128}r[n++]=63&e|128}}t=n===r.length?r:r.subarray(0,n)}return t}var u,l=e(610401301),d=e(188588736);const f=t.navigator;function p(t){return!!l&&(!!u&&u.brands.some((({brand:e})=>e&&-1!=e.indexOf(t))))}function g(e){var n;return(n=t.navigator)&&(n=n.userAgent)||(n=\"\"),-1!=n.indexOf(e)}function m(){return!!l&&(!!u&&0<u.brands.length)}function y(){return m()?p(\"Chromium\"):(g(\"Chrome\")||g(\"CriOS\"))&&!(!m()&&g(\"Edge\"))||g(\"Silk\")}function _(t){return _[\" \"](t),t}u=f&&f.userAgentData||null,_[\" \"]=function(){};var v=!m()&&(g(\"Trident\")||g(\"MSIE\"));!g(\"Android\")||y(),y(),g(\"Safari\")&&(y()||!m()&&g(\"Coast\")||!m()&&g(\"Opera\")||!m()&&g(\"Edge\")||(m()?p(\"Microsoft Edge\"):g(\"Edg/\"))||m()&&p(\"Opera\"));var E={},w=null;function T(t){var e=t.length,n=3*e/4;n%3?n=Math.floor(n):-1!=\"=.\".indexOf(t[e-1])&&(n=-1!=\"=.\".indexOf(t[e-2])?n-2:n-1);var r=new Uint8Array(n),i=0;return function(t,e){function n(e){for(;r<t.length;){var n=t.charAt(r++),i=w[n];if(null!=i)return i;if(!/^[\\s\\xa0]*$/.test(n))throw Error(\"Unknown base64 encoding at char: \"+n)}return e}A();for(var r=0;;){var i=n(-1),s=n(0),o=n(64),a=n(64);if(64===a&&-1===i)break;e(i<<2|s>>4),64!=o&&(e(s<<4&240|o>>2),64!=a&&e(o<<6&192|a))}}(t,(function(t){r[i++]=t})),i!==n?r.subarray(0,i):r}function A(){if(!w){w={};for(var t=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".split(\"\"),e=[\"+/=\",\"+/\",\"-_=\",\"-_.\",\"-_\"],n=0;5>n;n++){var r=t.concat(e[n].split(\"\"));E[n]=r;for(var i=0;i<r.length;i++){var s=r[i];void 0===w[s]&&(w[s]=i)}}}}var b=\"undefined\"!=typeof Uint8Array,k=!v&&\"function\"==typeof btoa;function x(t){if(!k){var e;void 0===e&&(e=0),A(),e=E[e];var n=Array(Math.floor(t.length/3)),r=e[64]||\"\";let h=0,c=0;for(;h<t.length-2;h+=3){var i=t[h],s=t[h+1],o=t[h+2],a=e[i>>2];i=e[(3&i)<<4|s>>4],s=e[(15&s)<<2|o>>6],o=e[63&o],n[c++]=a+i+s+o}switch(a=0,o=r,t.length-h){case 2:o=e[(15&(a=t[h+1]))<<2]||r;case 1:t=t[h],n[c]=e[t>>2]+e[(3&t)<<4|a>>4]+o+r}return n.join(\"\")}for(e=\"\",n=0,r=t.length-10240;n<r;)e+=String.fromCharCode.apply(null,t.subarray(n,n+=10240));return e+=String.fromCharCode.apply(null,n?t.subarray(n):t),btoa(e)}const S=/[-_.]/g,L={\"-\":\"+\",_:\"/\",\".\":\"=\"};function F(t){return L[t]||\"\"}function R(t){if(!k)return T(t);S.test(t)&&(t=t.replace(S,F)),t=atob(t);const e=new Uint8Array(t.length);for(let n=0;n<t.length;n++)e[n]=t.charCodeAt(n);return e}function M(t){return b&&null!=t&&t instanceof Uint8Array}let P;function C(){return P||=new Uint8Array(0)}var O={};let I;function U(t){if(t!==O)throw Error(\"illegal external caller\")}function D(){return I||=new B(null,O)}function N(t){U(O);var e=t.g;return null==(e=null==e||M(e)?e:\"string\"==typeof e?R(e):null)?e:t.g=e}var B=class{constructor(t,e){if(U(e),this.g=t,null!=t&&0===t.length)throw Error(\"ByteString should be constructed with non-empty values\")}h(){const t=N(this);return t?new Uint8Array(t):C()}};function G(t,e){return Error(`Invalid wire type: ${t} (at position ${e})`)}function j(){return Error(\"Failed to read varint, encoding is invalid.\")}function V(t,e){return Error(`Tried to read past the end of the data ${e} > ${t}`)}function X(t){if(\"string\"==typeof t)return{buffer:R(t),P:!1};if(Array.isArray(t))return{buffer:new Uint8Array(t),P:!1};if(t.constructor===Uint8Array)return{buffer:t,P:!1};if(t.constructor===ArrayBuffer)return{buffer:new Uint8Array(t),P:!1};if(t.constructor===B)return{buffer:N(t)||C(),P:!0};if(t instanceof Uint8Array)return{buffer:new Uint8Array(t.buffer,t.byteOffset,t.byteLength),P:!1};throw Error(\"Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers\")}function H(){return\"function\"==typeof BigInt}const W=\"function\"==typeof Uint8Array.prototype.slice;let z,K=0,Y=0;function $(t){const e=0>t;let n=(t=Math.abs(t))>>>0;if(t=Math.floor((t-n)/4294967296),e){const[e,r]=rt(n,t);t=r,n=e}K=n>>>0,Y=t>>>0}function q(t){const e=z||=new DataView(new ArrayBuffer(8));e.setFloat32(0,+t,!0),Y=0,K=e.getUint32(0,!0)}function J(t,e){return 4294967296*e+(t>>>0)}function Z(t,e){const n=2147483648&e;return n&&(e=~e>>>0,0==(t=1+~t>>>0)&&(e=e+1>>>0)),t=J(t,e),n?-t:t}function Q(t,e){if(t>>>=0,2097151>=(e>>>=0))var n=\"\"+(4294967296*e+t);else H()?n=\"\"+(BigInt(e)<<BigInt(32)|BigInt(t)):(t=(16777215&t)+6777216*(n=16777215&(t>>>24|e<<8))+6710656*(e=e>>16&65535),n+=8147497*e,e*=2,1e7<=t&&(n+=Math.floor(t/1e7),t%=1e7),1e7<=n&&(e+=Math.floor(n/1e7),n%=1e7),n=e+tt(n)+tt(t));return n}function tt(t){return t=String(t),\"0000000\".slice(t.length)+t}function et(){var t=K,e=Y;if(2147483648&e)if(H())t=\"\"+(BigInt(0|e)<<BigInt(32)|BigInt(t>>>0));else{const[n,r]=rt(t,e);t=\"-\"+Q(n,r)}else t=Q(t,e);return t}function nt(t){if(16>t.length)$(Number(t));else if(H())t=BigInt(t),K=Number(t&BigInt(4294967295))>>>0,Y=Number(t>>BigInt(32)&BigInt(4294967295));else{const e=+(\"-\"===t[0]);Y=K=0;const n=t.length;for(let r=e,i=(n-e)%6+e;i<=n;r=i,i+=6){const e=Number(t.slice(r,i));Y*=1e6,K=1e6*K+e,4294967296<=K&&(Y+=Math.trunc(K/4294967296),Y>>>=0,K>>>=0)}if(e){const[t,e]=rt(K,Y);K=t,Y=e}}}function rt(t,e){return e=~e,t?t=1+~t:e+=1,[t,e]}function it(t,e){let n,r=0,i=0,s=0;const o=t.h;let a=t.g;do{n=o[a++],r|=(127&n)<<s,s+=7}while(32>s&&128&n);for(32<s&&(i|=(127&n)>>4),s=3;32>s&&128&n;s+=7)n=o[a++],i|=(127&n)<<s;if(dt(t,a),128>n)return e(r>>>0,i>>>0);throw j()}function st(t){let e=0,n=t.g;const r=n+10,i=t.h;for(;n<r;){const r=i[n++];if(e|=r,0==(128&r))return dt(t,n),!!(127&e)}throw j()}function ot(t){const e=t.h;let n=t.g,r=e[n++],i=127&r;if(128&r&&(r=e[n++],i|=(127&r)<<7,128&r&&(r=e[n++],i|=(127&r)<<14,128&r&&(r=e[n++],i|=(127&r)<<21,128&r&&(r=e[n++],i|=r<<28,128&r&&128&e[n++]&&128&e[n++]&&128&e[n++]&&128&e[n++]&&128&e[n++])))))throw j();return dt(t,n),i}function at(t){return ot(t)>>>0}function ht(t){var e=t.h;const n=t.g,r=e[n],i=e[n+1],s=e[n+2];return e=e[n+3],dt(t,t.g+4),(r<<0|i<<8|s<<16|e<<24)>>>0}function ct(t){var e=ht(t);t=2*(e>>31)+1;const n=e>>>23&255;return e&=8388607,255==n?e?NaN:1/0*t:0==n?t*Math.pow(2,-149)*e:t*Math.pow(2,n-150)*(e+Math.pow(2,23))}function ut(t){return ot(t)}function lt(t,e,{ca:n=!1}={}){t.ca=n,e&&(e=X(e),t.h=e.buffer,t.m=e.P,t.j=0,t.l=t.h.length,t.g=t.j)}function dt(t,e){if(t.g=e,e>t.l)throw V(t.l,e)}function ft(t,e){if(0>e)throw Error(`Tried to read a negative byte length: ${e}`);const n=t.g,r=n+e;if(r>t.l)throw V(e,t.l-n);return t.g=r,n}function pt(t,e){if(0==e)return D();var n=ft(t,e);return t.ca&&t.m?n=t.h.subarray(n,n+e):(t=t.h,n=n===(e=n+e)?C():W?t.slice(n,e):new Uint8Array(t.subarray(n,e))),0==n.length?D():new B(n,O)}var gt=[];function mt(t){var e=t.g;if(e.g==e.l)return!1;t.l=t.g.g;var n=at(t.g);if(e=n>>>3,!(0<=(n&=7)&&5>=n))throw G(n,t.l);if(1>e)throw Error(`Invalid field number: ${e} (at position ${t.l})`);return t.m=e,t.h=n,!0}function yt(t){switch(t.h){case 0:0!=t.h?yt(t):st(t.g);break;case 1:dt(t=t.g,t.g+8);break;case 2:if(2!=t.h)yt(t);else{var e=at(t.g);dt(t=t.g,t.g+e)}break;case 5:dt(t=t.g,t.g+4);break;case 3:for(e=t.m;;){if(!mt(t))throw Error(\"Unmatched start-group tag: stream EOF\");if(4==t.h){if(t.m!=e)throw Error(\"Unmatched end-group tag\");break}yt(t)}break;default:throw G(t.h,t.l)}}function _t(t,e,n){const r=t.g.l,i=at(t.g),s=t.g.g+i;let o=s-r;if(0>=o&&(t.g.l=s,n(e,t,void 0,void 0,void 0),o=s-t.g.g),o)throw Error(`Message parsing ended unexpectedly. Expected to read ${i} bytes, instead read ${i-o} bytes, either the data ended unexpectedly or the message misreported its own length`);return t.g.g=s,t.g.l=r,e}function vt(t){var e=at(t.g),a=ft(t=t.g,e);if(t=t.h,o){var h,c=t;(h=s)||(h=s=new TextDecoder(\"utf-8\",{fatal:!0})),e=a+e,c=0===a&&e===c.length?c:c.subarray(a,e);try{var u=h.decode(c)}catch(t){if(void 0===i){try{h.decode(new Uint8Array([128]))}catch(t){}try{h.decode(new Uint8Array([97])),i=!0}catch(t){i=!1}}throw!i&&(s=void 0),t}}else{e=(u=a)+e,a=[];let i,s=null;for(;u<e;){var l=t[u++];128>l?a.push(l):224>l?u>=e?n():(i=t[u++],194>l||128!=(192&i)?(u--,n()):a.push((31&l)<<6|63&i)):240>l?u>=e-1?n():(i=t[u++],128!=(192&i)||224===l&&160>i||237===l&&160<=i||128!=(192&(h=t[u++]))?(u--,n()):a.push((15&l)<<12|(63&i)<<6|63&h)):244>=l?u>=e-2?n():(i=t[u++],128!=(192&i)||0!=i-144+(l<<28)>>30||128!=(192&(h=t[u++]))||128!=(192&(c=t[u++]))?(u--,n()):(l=(7&l)<<18|(63&i)<<12|(63&h)<<6|63&c,l-=65536,a.push(55296+(l>>10&1023),56320+(1023&l)))):n(),8192<=a.length&&(s=r(s,a),a.length=0)}u=r(s,a)}return u}function Et(t){const e=at(t.g);return pt(t.g,e)}function wt(t,e,n){var r=at(t.g);for(r=t.g.g+r;t.g.g<r;)n.push(e(t.g))}var Tt=[];function At(t){return t?/^\\d+$/.test(t)?(nt(t),new bt(K,Y)):null:kt||=new bt(0,0)}var bt=class{constructor(t,e){this.h=t>>>0,this.g=e>>>0}};let kt;function xt(t){return t?/^-?\\d+$/.test(t)?(nt(t),new St(K,Y)):null:Lt||=new St(0,0)}var St=class{constructor(t,e){this.h=t>>>0,this.g=e>>>0}};let Lt;function Ft(t,e,n){for(;0<n||127<e;)t.g.push(127&e|128),e=(e>>>7|n<<25)>>>0,n>>>=7;t.g.push(e)}function Rt(t,e){for(;127<e;)t.g.push(127&e|128),e>>>=7;t.g.push(e)}function Mt(t,e){if(0<=e)Rt(t,e);else{for(let n=0;9>n;n++)t.g.push(127&e|128),e>>=7;t.g.push(1)}}function Pt(t,e){t.g.push(e>>>0&255),t.g.push(e>>>8&255),t.g.push(e>>>16&255),t.g.push(e>>>24&255)}function Ct(t,e){0!==e.length&&(t.l.push(e),t.h+=e.length)}function Ot(t,e,n){Rt(t.g,8*e+n)}function It(t,e){return Ot(t,e,2),e=t.g.end(),Ct(t,e),e.push(t.h),e}function Ut(t,e){var n=e.pop();for(n=t.h+t.g.length()-n;127<n;)e.push(127&n|128),n>>>=7,t.h++;e.push(n),t.h++}function Dt(t,e,n){Ot(t,e,2),Rt(t.g,n.length),Ct(t,t.g.end()),Ct(t,n)}function Nt(t,e,n,r){null!=n&&(e=It(t,e),r(n,t),Ut(t,e))}class Bt{constructor(t,e,n,r){this.g=t,this.h=e,this.l=n,this.pa=r}}function Gt(t){return Array.prototype.slice.call(t)}function jt(t){return\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol()?Symbol():t}var Vt=jt(),Xt=jt(\"0di\"),Ht=jt(\"2ex\"),Wt=jt(\"0dg\"),zt=Vt?(t,e)=>{t[Vt]|=e}:(t,e)=>{void 0!==t.g?t.g|=e:Object.defineProperties(t,{g:{value:e,configurable:!0,writable:!0,enumerable:!1}})},Kt=Vt?(t,e)=>{t[Vt]&=~e}:(t,e)=>{void 0!==t.g&&(t.g&=~e)};function Yt(t,e,n){return n?t|e:t&~e}var $t=Vt?t=>0|t[Vt]:t=>0|t.g,qt=Vt?t=>t[Vt]:t=>t.g,Jt=Vt?(t,e)=>(t[Vt]=e,t):(t,e)=>(void 0!==t.g?t.g=e:Object.defineProperties(t,{g:{value:e,configurable:!0,writable:!0,enumerable:!1}}),t);function Zt(t){return zt(t,34),t}function Qt(t,e){Jt(e,-14591&(0|t))}function te(t,e){Jt(e,-14557&(34|t))}function ee(t){return 0===(t=t>>14&1023)?536870912:t}var ne,re={},ie={};function se(t){return!(!t||\"object\"!=typeof t||t.Ja!==ie)}function oe(t){return null!==t&&\"object\"==typeof t&&!Array.isArray(t)&&t.constructor===Object}function ae(t,e,n){if(null!=t)if(\"string\"==typeof t)t=t?new B(t,O):D();else if(t.constructor!==B)if(M(t))t=t.length?new B(n?t:new Uint8Array(t),O):D();else{if(!e)throw Error();t=void 0}return t}function he(t,e,n){if(!Array.isArray(t)||t.length)return!1;const r=$t(t);return!!(1&r)||!(!e||!(Array.isArray(e)?e.includes(n):e.has(n)))&&(Jt(t,1|r),!0)}const ce=[];function ue(t){if(2&t)throw Error()}Jt(ce,55),ne=Object.freeze(ce);class le{constructor(t,e,n){this.l=0,this.g=t,this.h=e,this.m=n}next(){if(this.l<this.g.length){const t=this.g[this.l++];return{done:!1,value:this.h?this.h.call(this.m,t):t}}return{done:!0,value:void 0}}[Symbol.iterator](){return new le(this.g,this.h,this.m)}}let de,fe,pe;function ge(t,e){(e=de?e[de]:void 0)&&(t[de]=Gt(e))}function me(t,e){t.__closure__error__context__984382||(t.__closure__error__context__984382={}),t.__closure__error__context__984382.severity=e}function ye(){const e=Error();me(e,\"incident\"),function(e){t.setTimeout((()=>{throw e}),0)}(e)}function _e(t){return me(t=Error(t),\"warning\"),t}function ve(t){return null==t||\"number\"==typeof t?t:\"NaN\"===t||\"Infinity\"===t||\"-Infinity\"===t?Number(t):void 0}function Ee(t){return null==t||\"boolean\"==typeof t?t:\"number\"==typeof t?!!t:void 0}Object.freeze(new class{}),Object.freeze(new class{});const we=/^-?([1-9][0-9]*|0)(\\.[0-9]+)?$/;function Te(t){const e=typeof t;return\"number\"===e?Number.isFinite(t):\"string\"===e&&we.test(t)}function Ae(t){if(null==t)return t;if(\"string\"==typeof t){if(!t)return;t=+t}return\"number\"==typeof t&&Number.isFinite(t)?0|t:void 0}function be(t){if(null==t)return t;if(\"string\"==typeof t){if(!t)return;t=+t}return\"number\"==typeof t&&Number.isFinite(t)?t>>>0:void 0}function ke(t){return\"-\"!==t[0]&&(20>t.length||20===t.length&&184467>Number(t.substring(0,6)))}function xe(t){return\"-\"===t[0]?20>t.length||20===t.length&&-922337<Number(t.substring(0,7)):19>t.length||19===t.length&&922337>Number(t.substring(0,6))}function Se(t){return t=Math.trunc(t),Number.isSafeInteger(t)||($(t),t=Z(K,Y)),t}function Le(t){var e=Math.trunc(Number(t));return Number.isSafeInteger(e)?String(e):(-1!==(e=t.indexOf(\".\"))&&(t=t.substring(0,e)),xe(t)||(nt(t),t=et()),t)}function Fe(t){return null==t?t:Te(t)?\"number\"==typeof t?Se(t):Le(t):void 0}function Re(t){if(\"string\"!=typeof t)throw Error();return t}function Me(t){if(null!=t&&\"string\"!=typeof t)throw Error();return t}function Pe(t){return null==t||\"string\"==typeof t?t:void 0}function Ce(t,e,n,r){if(null!=t&&\"object\"==typeof t&&t.X===re)return t;if(!Array.isArray(t))return n?2&r?(t=e[Xt])?e=t:(Zt((t=new e).s),e=e[Xt]=t):e=new e:e=void 0,e;let i=n=$t(t);return 0===i&&(i|=32&r),i|=2&r,i!==n&&Jt(t,i),new e(t)}function Oe(t,e,n){if(e){var r=!!r;if(!Te(e=t))throw _e(\"int64\");\"string\"==typeof e?r=Le(e):r?(r=Math.trunc(e),Number.isSafeInteger(r)?r=String(r):xe(e=String(r))?r=e:($(r),r=et())):r=Se(e)}else r=Fe(t);return\"string\"==typeof(n=null==(t=r)?n?0:void 0:t)&&(r=+n,Number.isSafeInteger(r))?r:n}let Ie,Ue,De;function Ne(t){switch(typeof t){case\"boolean\":return Ue||=[0,void 0,!0];case\"number\":return 0<t?void 0:0===t?De||=[0,void 0]:[-t,void 0];case\"string\":return[0,t];case\"object\":return t}}function Be(t,e){return Ge(t,e[0],e[1])}function Ge(t,e,n){if(null==t&&(t=Ie),Ie=void 0,null==t){var r=96;n?(t=[n],r|=512):t=[],e&&(r=-16760833&r|(1023&e)<<14)}else{if(!Array.isArray(t))throw Error(\"narr\");if(2048&(r=$t(t)))throw Error(\"farr\");if(64&r)return t;if(r|=64,n&&(r|=512,n!==t[0]))throw Error(\"mid\");t:{const i=(n=t).length;if(i){const t=i-1;if(oe(n[t])){if(1024<=(e=t-(+!!(512&(r|=256))-1)))throw Error(\"pvtlmt\");r=-16760833&r|(1023&e)<<14;break t}}if(e){if(1024<(e=Math.max(e,i-(+!!(512&r)-1))))throw Error(\"spvt\");r=-16760833&r|(1023&e)<<14}}}return Jt(t,r),t}const je={};let Ve=function(){try{return _(new class extends Map{constructor(){super()}}),!1}catch{return!0}}();class Xe{constructor(){this.g=new Map}get(t){return this.g.get(t)}set(t,e){return this.g.set(t,e),this.size=this.g.size,this}delete(t){return t=this.g.delete(t),this.size=this.g.size,t}clear(){this.g.clear(),this.size=this.g.size}has(t){return this.g.has(t)}entries(){return this.g.entries()}keys(){return this.g.keys()}values(){return this.g.values()}forEach(t,e){return this.g.forEach(t,e)}[Symbol.iterator](){return this.entries()}}const He=Ve?(Object.setPrototypeOf(Xe.prototype,Map.prototype),Object.defineProperties(Xe.prototype,{size:{value:0,configurable:!0,enumerable:!0,writable:!0}}),Xe):class extends Map{constructor(){super()}};function We(t){return t}function ze(t){if(2&t.N)throw Error(\"Cannot mutate an immutable Map\")}var Ke=class extends He{constructor(t,e,n=We,r=We){super();let i=$t(t);i|=64,Jt(t,i),this.N=i,this.U=e,this.S=n,this.Z=this.U?Ye:r;for(let s=0;s<t.length;s++){const o=t[s],a=n(o[0],!1,!0);let h=o[1];e?void 0===h&&(h=null):h=r(o[1],!1,!0,void 0,void 0,i),super.set(a,h)}}oa(t=$e){if(0!==this.size)return this.Y(t)}Y(t=$e){const e=[],n=super.entries();for(var r;!(r=n.next()).done;)(r=r.value)[0]=t(r[0]),r[1]=t(r[1]),e.push(r);return e}clear(){ze(this),super.clear()}delete(t){return ze(this),super.delete(this.S(t,!0,!1))}entries(){var t=this.na();return new le(t,qe,this)}keys(){return this.Ia()}values(){var t=this.na();return new le(t,Ke.prototype.get,this)}forEach(t,e){super.forEach(((n,r)=>{t.call(e,this.get(r),r,this)}))}set(t,e){return ze(this),null==(t=this.S(t,!0,!1))?this:null==e?(super.delete(t),this):super.set(t,this.Z(e,!0,!0,this.U,!1,this.N))}Oa(t){const e=this.S(t[0],!1,!0);t=t[1],t=this.U?void 0===t?null:t:this.Z(t,!1,!0,void 0,!1,this.N),super.set(e,t)}has(t){return super.has(this.S(t,!1,!1))}get(t){t=this.S(t,!1,!1);const e=super.get(t);if(void 0!==e){var n=this.U;return n?((n=this.Z(e,!1,!0,n,this.ta,this.N))!==e&&super.set(t,n),n):e}}na(){return Array.from(super.keys())}Ia(){return super.keys()}[Symbol.iterator](){return this.entries()}};function Ye(t,e,n,r,i,s){return t=Ce(t,r,n,s),i&&(t=an(t)),t}function $e(t){return t}function qe(t){return[t,this.get(t)]}let Je;function Ze(){return Je||=new Ke(Zt([]),void 0,void 0,void 0,je)}function Qe(t,e,n,r,i){if(null!=t){if(Array.isArray(t))t=he(t,void 0,0)?void 0:i&&2&$t(t)?t:tn(t,e,n,void 0!==r,i);else if(oe(t)){const s={};for(let o in t)s[o]=Qe(t[o],e,n,r,i);t=s}else t=e(t,r);return t}}function tn(t,e,n,r,i){const s=r||n?$t(t):0;r=r?!!(32&s):void 0;const o=Gt(t);for(let t=0;t<o.length;t++)o[t]=Qe(o[t],e,n,r,i);return n&&(ge(o,t),n(s,o)),o}function en(t){return Qe(t,nn,void 0,void 0,!1)}function nn(t){return t.X===re?t.toJSON():t instanceof Ke?t.oa(en):function(t){switch(typeof t){case\"number\":return isFinite(t)?t:String(t);case\"boolean\":return t?1:0;case\"object\":if(t)if(Array.isArray(t)){if(he(t,void 0,0))return}else{if(M(t))return x(t);if(t instanceof B){const e=t.g;return null==e?\"\":\"string\"==typeof e?e:t.g=x(e)}if(t instanceof Ke)return t.oa()}}return t}(t)}function rn(t,e,n=te){if(null!=t){if(b&&t instanceof Uint8Array)return e?t:new Uint8Array(t);if(Array.isArray(t)){var r=$t(t);return 2&r||(e&&=0===r||!!(32&r)&&!(64&r||!(16&r)),t=e?Jt(t,-12293&(34|r)):tn(t,rn,4&r?te:n,!0,!0)),t}return t.X===re?(n=t.s,t=2&(r=qt(n))?t:sn(t,n,r,!0)):t instanceof Ke&&!(2&t.N)&&(n=Zt(t.Y(rn)),t=new Ke(n,t.U,t.S,t.Z)),t}}function sn(t,e,n,r){return t=t.constructor,Ie=e=on(e,n,r),e=new t(e),Ie=void 0,e}function on(t,e,n){const r=n||2&e?te:Qt,i=!!(32&e);return t=function(t,e,n){const r=Gt(t);var i=r.length;const s=256&e?r[i-1]:void 0;for(i+=s?-1:0,e=512&e?1:0;e<i;e++)r[e]=n(r[e]);if(s){e=r[e]={};for(const t in s)e[t]=n(s[t])}return ge(r,t),r}(t,e,(t=>rn(t,i,r))),zt(t,32|(n?2:0)),t}function an(t){const e=t.s,n=qt(e);return 2&n?sn(t,e,n,!1):t}function hn(t,e,n,r){return!(4&e)||null!=n&&(!r&&0===n&&(4096&e||8192&e)&&5>(t.constructor[Wt]=1+(0|t.constructor[Wt]))&&ye(),0!==n&&!(n&e))}function cn(t,e){return ln(t=t.s,qt(t),e)}function un(t,e,n,r){if(!(0>(e=r+(+!!(512&e)-1))||e>=t.length||e>=n))return t[e]}function ln(t,e,n,r){if(-1===n)return null;const i=ee(e);if(!(n>=i)){var s=t.length;return r&&256&e&&null!=(r=t[s-1][n])?(un(t,e,i,n)&&null!=Ht&&(4<=(e=(t=pe??={})[Ht]||0)||(t[Ht]=e+1,ye())),r):un(t,e,i,n)}return 256&e?t[t.length-1][n]:void 0}function dn(t,e,n,r){const i=t.s;let s=qt(i);return ue(s),fn(i,s,e,n,r),t}function fn(t,e,n,r,i){const s=ee(e);if(n>=s||i){let o=e;if(256&e)i=t[t.length-1];else{if(null==r)return o;i=t[s+(+!!(512&e)-1)]={},o|=256}return i[n]=r,n<s&&(t[n+(+!!(512&e)-1)]=void 0),o!==e&&Jt(t,o),o}return t[n+(+!!(512&e)-1)]=r,256&e&&(n in(t=t[t.length-1])&&delete t[n]),e}function pn(t,e,n,r,i){var s=2&e;let o=ln(t,e,n,i);Array.isArray(o)||(o=ne);const a=!(2&r);r=!(1&r);const h=!!(32&e);let c=$t(o);return 0!==c||!h||s||a?1&c||(c|=1,Jt(o,c)):(c|=33,Jt(o,c)),s?(t=!1,2&c||(Zt(o),t=!!(4&c)),(r||t)&&Object.freeze(o)):(s=!!(2&c)||!!(2048&c),r&&s?(o=Gt(o),r=1,h&&!a&&(r|=32),Jt(o,r),fn(t,e,n,o,i)):a&&32&c&&!s&&Kt(o,32)),o}function gn(t,e){t=t.s;let n=qt(t);const r=ln(t,n,e),i=ve(r);return null!=i&&i!==r&&fn(t,n,e,i),i}function mn(t){t=t.s;let e=qt(t);const n=ln(t,e,1),r=ae(n,!0,!!(34&e));return null!=r&&r!==n&&fn(t,e,1,r),r}function yn(t,e,n){const r=t.s;let i=qt(r);const s=2&i?1:2;let o=_n(r,i,e);var a=$t(o);if(hn(t,a,void 0,!1)){(4&a||Object.isFrozen(o))&&(o=Gt(o),a=In(a,i),i=fn(r,i,e,o));let s=t=0;for(;t<o.length;t++){const e=n(o[t]);null!=e&&(o[s++]=e)}s<t&&(o.length=s),a=Yt(a=vn(a,i),20,!0),a=Yt(a,4096,!1),a=Yt(a,8192,!1),Jt(o,a),2&a&&Object.freeze(o)}return En(a)||(n=a,(a=(t=1===s||4===s&&!!(32&a))?Yt(a,2,!0):Un(a,i,!1))!==n&&Jt(o,a),t&&Object.freeze(o)),2===s&&En(a)&&(o=Gt(o),a=Un(a=In(a,i),i,!1),Jt(o,a),fn(r,i,e,o)),o}function _n(t,e,n){return t=ln(t,e,n),Array.isArray(t)?t:ne}function vn(t,e){return 0===t&&(t=In(t,e)),Yt(t,1,!0)}function En(t){return!!(2&t)&&!!(4&t)||!!(2048&t)}function wn(t){t=Gt(t);for(let e=0;e<t.length;e++){const n=t[e]=Gt(t[e]);Array.isArray(n[1])&&(n[1]=Zt(n[1]))}return t}function Tn(t,e,n){{const a=t.s;let h=qt(a);if(ue(h),null==n)fn(a,h,e);else{var r,i=$t(n),s=i,o=!!(2&i)||Object.isFrozen(n);if((r=!o)&&(r=!1),hn(t,i))for(i=21,o&&(n=Gt(n),s=0,i=Un(i=In(i,h),h,!0)),t=0;t<n.length;t++)n[t]=Re(n[t]);r&&(n=Gt(n),s=0,i=Un(i=In(i,h),h,!0)),i!==s&&Jt(n,i),fn(a,h,e,n)}}}function An(t,e,n,r){t=t.s;let i=qt(t);ue(i),fn(t,i,e,(\"0\"===r?0===Number(n):n===r)?void 0:n)}function bn(t,e,n,r){const i=qt(t);ue(i),t=pn(t,i,e,2),r=n(r,!!(4&(e=$t(t)))&&!!(4096&e)),t.push(r)}function kn(t){return t}function xn(t,e){return Sn(t=t.s,qt(t),ws)===e?e:-1}function Sn(t,e,n){let r=0;for(let i=0;i<n.length;i++){const s=n[i];null!=ln(t,e,s)&&(0!==r&&(e=fn(t,e,r)),r=s)}return r}function Ln(t,e,n,r){let i=qt(t);ue(i);const s=ln(t,i,n,r);let o;if(null!=s&&s.X===re)return(e=an(s))!==s&&fn(t,i,n,e,r),e.s;if(Array.isArray(s)){const t=$t(s);o=2&t?on(s,t,!1):s,o=Be(o,e)}else o=Be(void 0,e);return o!==s&&fn(t,i,n,o,r),o}function Fn(t,e,n,r){t=t.s;let i=qt(t);const s=ln(t,i,n,r);return(e=Ce(s,e,!1,i))!==s&&null!=e&&fn(t,i,n,e,r),e}function Rn(t,e,n,r=!1){if(null==(e=Fn(t,e,n,r)))return e;t=t.s;let i=qt(t);if(!(2&i)){const s=an(e);s!==e&&fn(t,i,n,e=s,r)}return e}function Mn(t,e,n,r,i,s){var o=2,a=!!(2&e);o=a?1:o,i=!!i,s&&=!a,a=_n(t,e,r);var h=$t(a);const c=!!(4&h);if(!c){var u=a,l=e;const t=!!(2&(h=vn(h,e)));t&&(l=Yt(l,2,!0));let r=!t,i=!0,s=0,o=0;for(;s<u.length;s++){const e=Ce(u[s],n,!1,l);if(e instanceof n){if(!t){const t=!!(2&$t(e.s));r&&=!t,i&&=t}u[o++]=e}}o<s&&(u.length=o),h=Yt(h,4,!0),h=Yt(h,16,i),h=Yt(h,8,r),Jt(u,h),t&&Object.freeze(u)}if(s&&!(8&h||!a.length&&(1===o||4===o&&32&h))){for(En(h)&&(a=Gt(a),h=In(h,e),e=fn(t,e,r,a)),n=a,s=h,u=0;u<n.length;u++)(h=n[u])!==(l=an(h))&&(n[u]=l);s=Yt(s,8,!0),s=Yt(s,16,!n.length),Jt(n,s),h=s}return En(h)||(n=h,(h=(s=1===o||4===o&&!!(32&h))?Yt(h,!a.length||16&h&&(!c||32&h)?2:2048,!0):Un(h,e,i))!==n&&Jt(a,h),s&&Object.freeze(a)),2===o&&En(h)&&(a=Gt(a),h=Un(h=In(h,e),e,i),Jt(a,h),fn(t,e,r,a)),a}function Pn(t,e,n){t=t.s;const r=qt(t);return Mn(t,r,e,n,!1,!(2&r))}function Cn(t,e,n,r,i){return null==r&&(r=void 0),dn(t,n,r,i)}function On(t,e,n,r){null==r&&(r=void 0),t=t.s;let i=qt(t);ue(i),(n=Sn(t,i,n))&&n!==e&&null!=r&&(i=fn(t,i,n)),fn(t,i,e,r)}function In(t,e){return t=Yt(t,2,!!(2&e)),t=Yt(t,32,!0),Yt(t,2048,!1)}function Un(t,e,n){return 32&e&&n||(t=Yt(t,32,!1)),t}function Dn(t,e,n,r){t=t.s;const i=qt(t);ue(i),e=Mn(t,i,n,e,!0),n=null!=r?r:new n,e.push(n),2&$t(n.s)?Kt(e,8):Kt(e,16)}function Nn(t,e){return Ae(cn(t,e))}function Bn(t,e){return t??e}function Gn(t,e){return Bn(gn(t,e),0)}function jn(t,e){return Bn(Pe(cn(t,e)),\"\")}function Vn(t,e,n){if(null!=n&&\"boolean\"!=typeof n)throw t=typeof n,Error(`Expected boolean but got ${\"object\"!=t?t:n?Array.isArray(n)?\"array\":t:\"null\"}: ${n}`);dn(t,e,n)}function Xn(t,e,n){if(null!=n){if(\"number\"!=typeof n)throw _e(\"int32\");if(!Number.isFinite(n))throw _e(\"int32\");n|=0}dn(t,e,n)}function Hn(t,e,n){if(null!=n&&\"number\"!=typeof n)throw Error(`Value of float/double field must be a number, found ${typeof n}: ${n}`);dn(t,e,n)}function Wn(t,e,n){e.g?e.m(t,e.g,e.h,n,!0):e.m(t,e.h,n,!0)}Ke.prototype.toJSON=void 0,Ke.prototype.Ja=ie;var zn=class{constructor(t,e){this.s=Ge(t,e)}toJSON(){return Kn(this,tn(this.s,nn,void 0,void 0,!1),!0)}l(){var t=ko;return t.g?t.l(this,t.g,t.h,!0):t.l(this,t.h,t.defaultValue,!0)}clone(){const t=this.s;return sn(this,t,qt(t),!1)}P(){return!!(2&$t(this.s))}};function Kn(t,e,n){var r=d?void 0:t.constructor.B;const i=qt(n?t.s:e);if(!(t=e.length))return e;let s,o;if(oe(n=e[t-1])){t:{var a=n;let t={},e=!1;for(var h in a){let n=a[h];if(Array.isArray(n)){let t=n;(he(n,r,+h)||se(n)&&0===n.size)&&(n=null),n!=t&&(e=!0)}null!=n?t[h]=n:e=!0}if(e){for(var c in t){a=t;break t}a=null}}a!=n&&(s=!0),t--}for(h=+!!(512&i)-1;0<t&&(n=e[c=t-1],c-=h,null==n||he(n,r,c)||se(n)&&0===n.size);t--)o=!0;return s||o?(e=Array.prototype.slice.call(e,0,t),a&&e.push(a),e):e}function Yn(t){return Array.isArray(t)?t[0]instanceof Bt?t:[$r,t]:[t,void 0]}function $n(t,e){if(Array.isArray(e)){var n=$t(e);if(4&n)return e;for(var r=0,i=0;r<e.length;r++){const n=t(e[r]);null!=n&&(e[i++]=n)}return i<r&&(e.length=i),Jt(e,-12289&(5|n)),2&n&&Object.freeze(e),e}}zn.prototype.X=re,zn.prototype.toString=function(){return Kn(this,this.s,!1).toString()};const qn=Symbol();function Jn(t){let e=t[qn];if(!e){const n=sr(t),r=yr(t),i=r.l;e=i?(t,e)=>i(t,e,r):(t,e)=>{for(;mt(e)&&4!=e.h;){var i=e.m,s=r[i];if(!s){var o=r.ea;o&&(o=o[i])&&(s=r[i]=Zn(o))}s&&s(e,t,i)||(i=(s=e).l,yt(s),s.ia?s=void 0:(o=s.g.g-i,s.g.g=i,s=pt(s.g,o)),i=t,s&&(de||=Symbol(),(o=i[de])?o.push(s):i[de]=[s]))}n===tr||n===er||n.j||(t[fe||=Symbol()]=n)},t[qn]=e}return e}function Zn(t){const e=(t=Yn(t))[0].g;if(t=t[1]){const n=Jn(t),r=yr(t).T;return(t,i,s)=>e(t,i,s,r,n)}return e}class Qn{}let tr,er;const nr=Symbol();function rr(t,e,n){const r=n[1];let i;if(r){const n=r[nr];i=n?n.T:Ne(r[0]),t[e]=n??r}i&&i===Ue?(t.g||(t.g=new Set)).add(e):n[0]&&(t.h||(t.h=new Set)).add(e)}function ir(t,e){return[t.l,!e||0<e[0]?void 0:e]}function sr(t){var e=t[nr];if(e)return e;if(!(e=ar(t,t[nr]=new Qn,ir,ir,rr)).ea&&!e.h&&!e.g){let n=!0;for(let t in e)isNaN(t)||(n=!1);n?(Ne(t[0])===Ue?er?e=er:((e=new Qn).T=Ne(!0),e=er=e):e=tr||=new Qn,e=t[nr]=e):e.j=!0}return e}function or(t,e,n){t[e]=n}function ar(t,e,n,r,i=or){e.T=Ne(t[0]);let s=0;var o=t[++s];o&&o.constructor===Object&&(e.ea=o,\"function\"==typeof(o=t[++s])&&(e.l=o,e.m=t[++s],o=t[++s]));const a={};for(;Array.isArray(o)&&\"number\"==typeof o[0]&&0<o[0];){for(var h=0;h<o.length;h++)a[o[h]]=o;o=t[++s]}for(h=1;void 0!==o;){let l;\"number\"==typeof o&&(h+=o,o=t[++s]);var c=void 0;if(o instanceof Bt?l=o:(l=qr,s--),l.pa){o=t[++s],c=t;var u=s;\"function\"==typeof o&&(o=o(),c[u]=o),c=o}for(u=h+1,\"number\"==typeof(o=t[++s])&&0>o&&(u-=o,o=t[++s]);h<u;h++){const t=a[h];i(e,h,c?r(l,c,t):n(l,t))}}return e}const hr=Symbol();function cr(t){let e=t[hr];if(!e){const n=fr(t);e=(t,e)=>Er(t,e,n),t[hr]=e}return e}const ur=Symbol();function lr(t){return t.h}function dr(t,e){let n,r;const i=t.h;return(t,s,o)=>i(t,s,o,r||=fr(e).T,n||=cr(e))}function fr(t){let e=t[ur];return e||(e=ar(t,t[ur]={},lr,dr),_r(t),e)}const pr=Symbol();function gr(t,e){const n=t.g;return e?(t,r,i)=>n(t,r,i,e):n}function mr(t,e,n){const r=t.g;let i,s;return(t,o,a)=>r(t,o,a,s||=yr(e).T,i||=Jn(e),n)}function yr(t){let e=t[pr];return e||(sr(t),e=ar(t,t[pr]={},gr,mr),_r(t),e)}function _r(t){pr in t&&nr in t&&ur in t&&(t.length=0)}function vr(t,e){var n=t[e];if(n)return n;if((n=t.ea)&&(n=n[e])){var r=(n=Yn(n))[0].h;if(n=n[1]){const e=cr(n),i=fr(n).T;n=(n=t.m)?n(i,e):(t,n,s)=>r(t,n,s,i,e)}else n=r;return t[e]=n}}function Er(t,e,n){for(var r=qt(t),i=+!!(512&r)-1,s=t.length,o=512&r?1:0,a=s+(256&r?-1:0);o<a;o++){const r=t[o];if(null==r)continue;const s=o-i,a=vr(n,s);a&&a(e,r,s)}if(256&r){r=t[s-1];for(let t in r)i=+t,Number.isNaN(i)||null!=(s=r[t])&&(a=vr(n,i))&&a(e,s,i)}if(t=de?t[de]:void 0)for(Ct(e,e.g.end()),n=0;n<t.length;n++)Ct(e,N(t[n])||C())}function wr(t,e){return new Bt(t,e,!1,!1)}function Tr(t,e){return new Bt(t,e,!0,!1)}function Ar(t,e){return new Bt(t,e,!1,!0)}function br(t,e,n){fn(t,qt(t),e,n)}var kr=Ar((function(t,e,n,r,i){return 2===t.h&&(t=_t(t,Be([void 0,void 0],r),i),ue(r=qt(e)),(i=ln(e,r,n))instanceof Ke?0!=(2&i.N)?((i=i.Y()).push(t),fn(e,r,n,i)):i.Oa(t):Array.isArray(i)?(2&$t(i)&&fn(e,r,n,i=wn(i)),i.push(t)):fn(e,r,n,[t]),!0)}),(function(t,e,n,r,i){if(e instanceof Ke)e.forEach(((e,s)=>{Nt(t,n,Be([s,e],r),i)}));else if(Array.isArray(e))for(let s=0;s<e.length;s++){const o=e[s];Array.isArray(o)&&Nt(t,n,Be(o,r),i)}}));function xr(t,e,n){t:if(null!=e){if(Te(e)){if(\"string\"==typeof e){e=Le(e);break t}if(\"number\"==typeof e){e=Se(e);break t}}e=void 0}null!=e&&(\"string\"==typeof e&&xt(e),null!=e&&(Ot(t,n,0),\"number\"==typeof e?(t=t.g,$(e),Ft(t,K,Y)):(n=xt(e),Ft(t.g,n.h,n.g))))}function Sr(t,e,n){null!=(e=Ae(e))&&null!=e&&(Ot(t,n,0),Mt(t.g,e))}function Lr(t,e,n){null!=(e=Ee(e))&&(Ot(t,n,0),t.g.g.push(e?1:0))}function Fr(t,e,n){null!=(e=Pe(e))&&Dt(t,n,c(e))}function Rr(t,e,n,r,i){Nt(t,n,e instanceof zn?e.s:Array.isArray(e)?Be(e,r):void 0,i)}function Mr(t,e,n){null!=(e=null==e||\"string\"==typeof e||M(e)||e instanceof B?e:void 0)&&Dt(t,n,X(e).buffer)}function Pr(t,e,n){return(5===t.h||2===t.h)&&(e=pn(e,qt(e),n,2,!1),2==t.h?wt(t,ct,e):e.push(ct(t.g)),!0)}var Cr,Or=wr((function(t,e,n){if(1!==t.h)return!1;var r=t.g;t=ht(r);const i=ht(r);r=2*(i>>31)+1;const s=i>>>20&2047;return t=4294967296*(1048575&i)+t,br(e,n,2047==s?t?NaN:1/0*r:0==s?r*Math.pow(2,-1074)*t:r*Math.pow(2,s-1075)*(t+4503599627370496)),!0}),(function(t,e,n){null!=(e=ve(e))&&(Ot(t,n,1),t=t.g,(n=z||=new DataView(new ArrayBuffer(8))).setFloat64(0,+e,!0),K=n.getUint32(0,!0),Y=n.getUint32(4,!0),Pt(t,K),Pt(t,Y))})),Ir=wr((function(t,e,n){return 5===t.h&&(br(e,n,ct(t.g)),!0)}),(function(t,e,n){null!=(e=ve(e))&&(Ot(t,n,5),t=t.g,q(e),Pt(t,K))})),Ur=Tr(Pr,(function(t,e,n){if(null!=(e=$n(ve,e)))for(let o=0;o<e.length;o++){var r=t,i=n,s=e[o];null!=s&&(Ot(r,i,5),r=r.g,q(s),Pt(r,K))}})),Dr=Tr(Pr,(function(t,e,n){if(null!=(e=$n(ve,e))&&e.length){Ot(t,n,2),Rt(t.g,4*e.length);for(let r=0;r<e.length;r++)n=t.g,q(e[r]),Pt(n,K)}})),Nr=wr((function(t,e,n){return 0===t.h&&(br(e,n,it(t.g,Z)),!0)}),xr),Br=wr((function(t,e,n){return 0===t.h&&(br(e,n,0===(t=it(t.g,Z))?void 0:t),!0)}),xr),Gr=wr((function(t,e,n){return 0===t.h&&(br(e,n,it(t.g,J)),!0)}),(function(t,e,n){t:if(null!=e){if(Te(e)){if(\"string\"==typeof e){var r=Math.trunc(Number(e));Number.isSafeInteger(r)&&0<=r?e=String(r):(-1!==(r=e.indexOf(\".\"))&&(e=e.substring(0,r)),ke(e)||(nt(e),e=Q(K,Y)));break t}if(\"number\"==typeof e){e=0<=(e=Math.trunc(e))&&Number.isSafeInteger(e)?e:function(t){if(0>t){$(t);const e=Q(K,Y);return t=Number(e),Number.isSafeInteger(t)?t:e}return ke(String(t))?t:($(t),J(K,Y))}(e);break t}}e=void 0}null!=e&&(\"string\"==typeof e&&At(e),null!=e&&(Ot(t,n,0),\"number\"==typeof e?(t=t.g,$(e),Ft(t,K,Y)):(n=At(e),Ft(t.g,n.h,n.g))))})),jr=wr((function(t,e,n){return 0===t.h&&(br(e,n,ot(t.g)),!0)}),Sr),Vr=Tr((function(t,e,n){return(0===t.h||2===t.h)&&(e=pn(e,qt(e),n,2,!1),2==t.h?wt(t,ot,e):e.push(ot(t.g)),!0)}),(function(t,e,n){if(null!=(e=$n(Ae,e))&&e.length){n=It(t,n);for(let n=0;n<e.length;n++)Mt(t.g,e[n]);Ut(t,n)}})),Xr=wr((function(t,e,n){return 0===t.h&&(br(e,n,0===(t=ot(t.g))?void 0:t),!0)}),Sr),Hr=wr((function(t,e,n){return 0===t.h&&(br(e,n,st(t.g)),!0)}),Lr),Wr=wr((function(t,e,n){return 0===t.h&&(br(e,n,!1===(t=st(t.g))?void 0:t),!0)}),Lr),zr=Tr((function(t,e,n){return 2===t.h&&(bn(e,n,kn,t=vt(t)),!0)}),(function(t,e,n){if(null!=(e=$n(Pe,e)))for(let o=0;o<e.length;o++){var r=t,i=n,s=e[o];null!=s&&Dt(r,i,c(s))}})),Kr=wr((function(t,e,n){return 2===t.h&&(br(e,n,\"\"===(t=vt(t))?void 0:t),!0)}),Fr),Yr=wr((function(t,e,n){return 2===t.h&&(br(e,n,vt(t)),!0)}),Fr),$r=Ar((function(t,e,n,r,i){return 2===t.h&&(_t(t,Ln(e,r,n,!0),i),!0)}),Rr),qr=Ar((function(t,e,n,r,i){return 2===t.h&&(_t(t,Ln(e,r,n),i),!0)}),Rr);Cr=new Bt((function(t,e,n,r,i){if(2!==t.h)return!1;r=Be(void 0,r);let s=qt(e);ue(s);let o=pn(e,s,n,3);return s=qt(e),4&$t(o)&&(o=Gt(o),Jt(o,-2079&(1|$t(o))),fn(e,s,n,o)),o.push(r),_t(t,r,i),!0}),(function(t,e,n,r,i){if(Array.isArray(e))for(let s=0;s<e.length;s++)Rr(t,e[s],n,r,i)}),!0,!0);var Jr=Ar((function(t,e,n,r,i,s){if(2!==t.h)return!1;let o=qt(e);return ue(o),(s=Sn(e,o,s))&&n!==s&&fn(e,o,s),_t(t,e=Ln(e,r,n),i),!0}),Rr),Zr=wr((function(t,e,n){return 2===t.h&&(br(e,n,Et(t)),!0)}),Mr),Qr=Tr((function(t,e,n){return(0===t.h||2===t.h)&&(e=pn(e,qt(e),n,2,!1),2==t.h?wt(t,at,e):e.push(at(t.g)),!0)}),(function(t,e,n){if(null!=(e=$n(be,e)))for(let o=0;o<e.length;o++){var r=t,i=n,s=e[o];null!=s&&(Ot(r,i,0),Rt(r.g,s))}})),ti=wr((function(t,e,n){return 0===t.h&&(br(e,n,ot(t.g)),!0)}),(function(t,e,n){null!=(e=Ae(e))&&(e=parseInt(e,10),Ot(t,n,0),Mt(t.g,e))})),ei=Tr((function(t,e,n){return(0===t.h||2===t.h)&&(e=pn(e,qt(e),n,2,!1),2==t.h?wt(t,ut,e):e.push(ot(t.g)),!0)}),(function(t,e,n){if(null!=(e=$n(Ae,e))&&e.length){n=It(t,n);for(let n=0;n<e.length;n++)Mt(t.g,e[n]);Ut(t,n)}}));class ni{constructor(t,e){this.h=t,this.g=e,this.l=Rn,this.m=Cn,this.defaultValue=void 0}}function ri(t,e){return new ni(t,e)}function ii(t,e){return(n,r)=>{if(Tt.length){const t=Tt.pop();t.o(r),lt(t.g,n,r),n=t}else n=new class{constructor(t,e){if(gt.length){const n=gt.pop();lt(n,t,e),t=n}else t=new class{constructor(t,e){this.h=null,this.m=!1,this.g=this.l=this.j=0,lt(this,t,e)}clear(){this.h=null,this.m=!1,this.g=this.l=this.j=0,this.ca=!1}}(t,e);this.g=t,this.l=this.g.g,this.h=this.m=-1,this.o(e)}o({ia:t=!1}={}){this.ia=t}}(n,r);try{const r=new t,s=r.s;Jn(e)(s,n);var i=r}finally{n.g.clear(),n.m=-1,n.h=-1,100>Tt.length&&Tt.push(n)}return i}}function si(t){return function(){const e=new class{constructor(){this.l=[],this.h=0,this.g=new class{constructor(){this.g=[]}length(){return this.g.length}end(){const t=this.g;return this.g=[],t}}}};Er(this.s,e,fr(t)),Ct(e,e.g.end());const n=new Uint8Array(e.h),r=e.l,i=r.length;let s=0;for(let t=0;t<i;t++){const e=r[t];n.set(e,s),s+=e.length}return e.l=[n],n}}var oi=class extends zn{constructor(t){super(t)}},ai=[0,Kr,wr((function(t,e,n){return 2===t.h&&(br(e,n,(t=Et(t))===D()?void 0:t),!0)}),(function(t,e,n){if(null!=e){if(e instanceof zn){const r=e.Qa;return void(r&&(e=r(e),null!=e&&Dt(t,n,X(e).buffer)))}if(Array.isArray(e))return}Mr(t,e,n)}))],hi=[0,Yr],ci=[0,jr,ti,Hr,-1,Vr,ti,-1],ui=[0,Hr,-1],li=class extends zn{constructor(){super()}};li.B=[6];var di=[0,Hr,Yr,Hr,ti,-1,ei,Yr,-1,ui,ti],fi=[0,Yr,-2],pi=class extends zn{constructor(){super()}},gi=[0],mi=[0,jr,Hr,-4],yi=class extends zn{constructor(t){super(t,2)}},_i={},vi=[-2,_i,Hr];_i[336783863]=[0,Yr,Hr,-1,jr,[0,[1,2,3,4,5,6],Jr,gi,Jr,di,Jr,fi,Jr,mi,Jr,ci,Jr,[0,Yr]],hi,Hr,[0,[1,3],[2,4],Jr,[0,Vr],-1,Jr,[0,zr],-1,Cr,[0,Yr,-1]],Yr];var Ei=[0,Kr,Wr],wi=[0,Br,-1,Wr,-3,Br,Vr,Kr,Xr,Br,-1,Wr,Xr,Wr,-2,Kr],Ti=[-1,{}],Ai=[0,Yr,1,Ti],bi=[0,Yr,zr,Ti];function ki(t,e){An(t,2,Me(e),\"\")}function xi(t,e){bn(t.s,3,Re,e)}function Si(t,e){bn(t.s,4,Re,e)}var Li=class extends zn{constructor(t){super(t,500)}o(t){return Cn(this,0,7,t)}};Li.B=[3,4,5,6,8,13,17,1005];var Fi=[-500,Kr,-1,zr,-3,vi,Cr,ai,Xr,-1,Ai,bi,Cr,Ei,Kr,wi,Xr,zr,987,zr],Ri=[0,Kr,-1,Ti],Mi=[-500,Yr,-1,[-1,{}],998,Yr],Pi=[-500,Yr,zr,-1,[-2,{},Hr],997,zr,-1],Ci=[-500,Yr,zr,Ti,998,zr];function Oi(t,e){Dn(t,1,Li,e)}function Ii(t,e){bn(t.s,10,Re,e)}function Ui(t,e){bn(t.s,15,Re,e)}var Di=class extends zn{constructor(t){super(t,500)}o(t){return Cn(this,0,1001,t)}};Di.B=[1,6,7,9,10,15,16,17,14,1002];var Ni=[-500,Cr,Fi,4,Cr,Mi,Cr,Pi,Xr,Cr,Ci,zr,Xr,Ai,bi,Cr,Ri,zr,-2,wi,Kr,-1,Wr,979,Ti,Cr,ai],Bi=ii(Di,Ni);Di.prototype.g=si(Ni);var Gi=[0,Cr,[0,jr,-2]],ji=class extends zn{constructor(t){super(t)}},Vi=[0,jr,Ir,Yr,-1],Xi=class extends zn{constructor(t){super(t)}g(){return Pn(this,ji,1)}};Xi.B=[1];var Hi=[0,Cr,Vi],Wi=ii(Xi,Hi),zi=[0,jr,Ir],Ki=[0,jr,-1,Gi],Yi=class extends zn{constructor(t){super(t)}},$i=[0,jr,-3],qi=[0,Ir,-3],Ji=class extends zn{constructor(t){super(t)}},Zi=[0,Ir,-1,Yr,Ir],Qi=class extends zn{constructor(t){super(t)}h(){return Rn(this,Yi,2)}g(){return Pn(this,Ji,5)}};Qi.B=[5];var ts=[0,ti,$i,qi,Ki,Cr,Zi],es=class extends zn{constructor(t){super(t)}};es.B=[1,2,3,8,9];var ns=ii(es,[0,zr,Vr,Dr,ts,Yr,-1,Nr,Cr,zi,zr,Nr]),rs=class extends zn{constructor(t){super(t)}},is=[0,Ir,-4],ss=class extends zn{constructor(t){super(t)}};ss.B=[1];var os=ii(ss,[0,Cr,is]),as=class extends zn{constructor(t){super(t)}},hs=[0,Ir,-4],cs=class extends zn{constructor(t){super(t)}};cs.B=[1];var us=ii(cs,[0,Cr,hs]),ls=class extends zn{constructor(t){super(t)}};ls.B=[3];var ds=[0,jr,-1,Dr,ti],fs=class extends zn{constructor(){super()}};fs.prototype.g=si([0,Ir,-4,Nr]);var ps=class extends zn{constructor(t){super(t)}},gs=[0,1,jr,Yr,Hi],ms=class extends zn{constructor(t){super(t)}};ms.B=[1];var ys=ii(ms,[0,Cr,gs,Nr]),_s=class extends zn{constructor(t){super(t)}};_s.B=[1];var vs=class extends zn{constructor(t){super(t)}qa(){const t=mn(this);return null==t?D():t}},Es=class extends zn{constructor(t){super(t)}},ws=[1,2],Ts=[0,ws,Jr,[0,Dr],Jr,[0,Zr],jr,Yr],As=class extends zn{constructor(t){super(t)}};As.B=[1];var bs=ii(As,[0,Cr,Ts,Nr]),ks=class extends zn{constructor(t){super(t)}};ks.B=[4,5];var xs=[0,Yr,jr,Ir,zr,-1],Ss=class extends zn{constructor(t){super(t)}},Ls=[0,Hr,-1],Fs=class extends zn{constructor(t){super(t)}},Rs=[1,2,3,4,5],Ms=class extends zn{constructor(t){super(t)}g(){return null!=mn(this)}h(){return null!=Pe(cn(this,2))}},Ps=[0,Zr,Yr,[0,jr,Nr,-1],[0,Gr,Nr]],Cs=class extends zn{constructor(t){super(t)}g(){return Ee(cn(this,2))??!1}},Os=[0,Ps,Hr,[0,Rs,Jr,mi,Jr,di,Jr,ci,Jr,gi,Jr,fi],ti],Is=class extends zn{constructor(t){super(t)}},Us=[0,Os,Ir,-1,jr],Ds=ri(502141897,Is);_i[502141897]=Us;var Ns=[0,Ps];_i[512499200]=Ns;var Bs=[0,Ns];_i[515723506]=Bs;var Gs=ii(class extends zn{constructor(t){super(t)}},[0,[0,ti,-1,Ur,Qr],ds]),js=[0,Os];_i[508981768]=js;var Vs=class extends zn{constructor(t){super(t)}},Xs=[0,Os,Ir,js,Hr],Hs=class extends zn{constructor(t){super(t)}},Ws=[0,Os,Us,Xs,Ir,Bs];_i[508968149]=Xs;var zs=ri(508968150,Hs);_i[508968150]=Ws;var Ks=class extends zn{constructor(t){super(t)}},Ys=ri(513916220,Ks);_i[513916220]=[0,Os,Ws,jr];var $s=class extends zn{constructor(t){super(t)}h(){return Rn(this,ks,2)}g(){dn(this,2)}},qs=[0,Os,xs];_i[478825465]=qs;var Js=[0,Os];_i[478825422]=Js;var Zs=class extends zn{constructor(t){super(t)}},Qs=[0,Os,Js,qs,-1],to=class extends zn{constructor(t){super(t)}},eo=[0,Os,Ir,jr],no=class extends zn{constructor(t){super(t)}},ro=[0,Os,Ir],io=class extends zn{constructor(t){super(t)}},so=[0,Os,eo,ro,Ir],oo=class extends zn{constructor(t){super(t)}},ao=[0,Os,so,Qs];_i[463370452]=Qs,_i[464864288]=eo,_i[474472470]=ro;var ho=ri(462713202,io);_i[462713202]=so;var co=ri(479097054,oo);_i[479097054]=ao;var uo=class extends zn{constructor(t){super(t)}},lo=[0,Os],fo=class extends zn{constructor(t){super(t)}},po=[0,Os,Ir,-1,jr];_i[514774813]=po;var go=class extends zn{constructor(t){super(t)}},mo=[0,Os,Ir,Hr];_i[518928384]=mo;var yo=class extends zn{constructor(){super()}};yo.prototype.g=si([0,Os,ro,lo,Us,Xs,po,mo]);var _o=class extends zn{constructor(t){super(t)}},vo=ri(456383383,_o);_i[456383383]=[0,Os,xs];var Eo=class extends zn{constructor(t){super(t)}},wo=ri(476348187,Eo);_i[476348187]=[0,Os,Ls];var To=class extends zn{constructor(t){super(t)}},Ao=[0,ti,-1],bo=class extends zn{constructor(t){super(t)}};bo.B=[3];var ko=ri(458105876,class extends zn{constructor(t){super(t)}g(){var t=this.s;const e=qt(t);var n=2&e;return t=function(t,e,n){var r=bo;const i=2&e;let s=!1;if(null==n){if(i)return Ze();n=[]}else if(n.constructor===Ke){if(0==(2&n.N)||i)return n;n=n.Y()}else Array.isArray(n)?s=!!(2&$t(n)):n=[];if(i){if(!n.length)return Ze();s||(s=!0,Zt(n))}else s&&(s=!1,n=wn(n));return s||(64&$t(n)?Kt(n,32):32&e&&zt(n,32)),fn(t,e,2,r=new Ke(n,r,Oe,void 0),!1),r}(t,e,ln(t,e,2)),null==t||!n&&bo&&(t.ta=!0),n=t}});_i[458105876]=[0,Ao,kr,[!0,Nr,[0,Yr,-1,zr]]];var xo=class extends zn{constructor(t){super(t)}},So=ri(458105758,xo);_i[458105758]=[0,Os,Yr,Ao];var Lo=class extends zn{constructor(t){super(t)}};Lo.B=[5,6];var Fo=ri(443442058,Lo);_i[443442058]=[0,Os,Yr,jr,Ir,zr,-1];var Ro=class extends zn{constructor(t){super(t)}},Mo=ri(516587230,Ro);function Po(t,e){return e=e?e.clone():new ks,void 0!==t.displayNamesLocale?dn(e,1,Me(t.displayNamesLocale)):void 0===t.displayNamesLocale&&dn(e,1),void 0!==t.maxResults?Xn(e,2,t.maxResults):\"maxResults\"in t&&dn(e,2),void 0!==t.scoreThreshold?Hn(e,3,t.scoreThreshold):\"scoreThreshold\"in t&&dn(e,3),void 0!==t.categoryAllowlist?Tn(e,4,t.categoryAllowlist):\"categoryAllowlist\"in t&&dn(e,4),void 0!==t.categoryDenylist?Tn(e,5,t.categoryDenylist):\"categoryDenylist\"in t&&dn(e,5),e}function Co(t,e=-1,n=\"\"){return{categories:t.map((t=>({index:Bn(Nn(t,1),0)??-1,score:Gn(t,2)??0,categoryName:jn(t,3)??\"\",displayName:jn(t,4)??\"\"}))),headIndex:e,headName:n}}function Oo(t){var e=yn(t,3,ve),n=yn(t,2,Ae),r=yn(t,1,Pe),i=yn(t,9,Pe);const s={categories:[],keypoints:[]};for(let t=0;t<e.length;t++)s.categories.push({score:e[t],index:n[t]??-1,categoryName:r[t]??\"\",displayName:i[t]??\"\"});if((e=Rn(t,Qi,4)?.h())&&(s.boundingBox={originX:Nn(e,1)??0,originY:Nn(e,2)??0,width:Nn(e,3)??0,height:Nn(e,4)??0,angle:0}),Rn(t,Qi,4)?.g().length)for(const e of Rn(t,Qi,4).g())s.keypoints.push({x:gn(e,1)??0,y:gn(e,2)??0,score:gn(e,4)??0,label:Pe(cn(e,3))??\"\"});return s}function Io(t){const e=[];for(const n of Pn(t,as,1))e.push({x:Gn(n,1)??0,y:Gn(n,2)??0,z:Gn(n,3)??0,visibility:Gn(n,4)??0});return e}function Uo(t){const e=[];for(const n of Pn(t,rs,1))e.push({x:Gn(n,1)??0,y:Gn(n,2)??0,z:Gn(n,3)??0,visibility:Gn(n,4)??0});return e}function Do(t){return Array.from(t,(t=>127<t?t-256:t))}function No(t,e){if(t.length!==e.length)throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${t.length} vs. ${e.length}).`);let n=0,r=0,i=0;for(let s=0;s<t.length;s++)n+=t[s]*e[s],r+=t[s]*t[s],i+=e[s]*e[s];if(0>=r||0>=i)throw Error(\"Cannot compute cosine similarity on embedding with 0 norm.\");return n/Math.sqrt(r*i)}let Bo;_i[516587230]=[0,Os,po,mo,Ir];const Go=new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,10,1,8,0,65,0,253,15,253,98,11]);async function jo(){if(void 0===Bo)try{await WebAssembly.instantiate(Go),Bo=!0}catch{Bo=!1}return Bo}async function Vo(t,e=\"\"){const n=await jo()?\"wasm_internal\":\"wasm_nosimd_internal\";return{wasmLoaderPath:`${e}/${t}_${n}.js`,wasmBinaryPath:`${e}/${t}_${n}.wasm`}}var Xo=class{};function Ho(){var t=navigator;return\"undefined\"!=typeof OffscreenCanvas&&(!function(t=navigator){return(t=t.userAgent).includes(\"Safari\")&&!t.includes(\"Chrome\")}(t)||!!((t=t.userAgent.match(/Version\\/([\\d]+).*Safari/))&&1<=t.length&&17<=Number(t[1])))}async function Wo(t){if(\"function\"!=typeof importScripts){const e=document.createElement(\"script\");return e.src=t.toString(),e.crossOrigin=\"anonymous\",new Promise(((t,n)=>{e.addEventListener(\"load\",(()=>{t()}),!1),e.addEventListener(\"error\",(t=>{n(t)}),!1),document.body.appendChild(e)}))}importScripts(t.toString())}function zo(t){return void 0!==t.videoWidth?[t.videoWidth,t.videoHeight]:void 0!==t.naturalWidth?[t.naturalWidth,t.naturalHeight]:void 0!==t.displayWidth?[t.displayWidth,t.displayHeight]:[t.width,t.height]}function Ko(t,e,n){t.m||console.error(\"No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target\"),n(e=t.i.stringToNewUTF8(e)),t.i._free(e)}function Yo(t,e,n){if(!t.i.canvas)throw Error(\"No OpenGL canvas configured.\");if(n?t.i._bindTextureToStream(n):t.i._bindTextureToCanvas(),!(n=t.i.canvas.getContext(\"webgl2\")||t.i.canvas.getContext(\"webgl\")))throw Error(\"Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.\");t.i.gpuOriginForWebTexturesIsBottomLeft&&n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!0),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e),t.i.gpuOriginForWebTexturesIsBottomLeft&&n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!1);const[r,i]=zo(e);return!t.l||r===t.i.canvas.width&&i===t.i.canvas.height||(t.i.canvas.width=r,t.i.canvas.height=i),[r,i]}function $o(t,e,n){t.m||console.error(\"No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target\");const r=new Uint32Array(e.length);for(let n=0;n<e.length;n++)r[n]=t.i.stringToNewUTF8(e[n]);e=t.i._malloc(4*r.length),t.i.HEAPU32.set(r,e>>2),n(e);for(const e of r)t.i._free(e);t.i._free(e)}function qo(t,e,n){t.i.simpleListeners=t.i.simpleListeners||{},t.i.simpleListeners[e]=n}function Jo(t,e,n){let r=[];t.i.simpleListeners=t.i.simpleListeners||{},t.i.simpleListeners[e]=(t,e,i)=>{e?(n(r,i),r=[]):r.push(t)}}Xo.forVisionTasks=function(t){return Vo(\"vision\",t)},Xo.forTextTasks=function(t){return Vo(\"text\",t)},Xo.forGenAiExperimentalTasks=function(t){return Vo(\"genai_experimental\",t)},Xo.forGenAiTasks=function(t){return Vo(\"genai\",t)},Xo.forAudioTasks=function(t){return Vo(\"audio\",t)},Xo.isSimdSupported=function(){return jo()};async function Zo(t,e,n,r){return t=await(async(t,e,n,r,i)=>{if(e&&await Wo(e),!self.ModuleFactory)throw Error(\"ModuleFactory not set.\");if(n&&(await Wo(n),!self.ModuleFactory))throw Error(\"ModuleFactory not set.\");return self.Module&&i&&((e=self.Module).locateFile=i.locateFile,i.mainScriptUrlOrBlob&&(e.mainScriptUrlOrBlob=i.mainScriptUrlOrBlob)),i=await self.ModuleFactory(self.Module||i),self.ModuleFactory=self.Module=void 0,new t(i,r)})(t,n.wasmLoaderPath,n.assetLoaderPath,e,{locateFile:t=>t.endsWith(\".wasm\")?n.wasmBinaryPath.toString():n.assetBinaryPath&&t.endsWith(\".data\")?n.assetBinaryPath.toString():t}),await t.o(r),t}function Qo(t,e){const n=Rn(t.baseOptions,Ms,1)||new Ms;\"string\"==typeof e?(dn(n,2,Me(e)),dn(n,1)):e instanceof Uint8Array&&(dn(n,1,ae(e,!1,!1)),dn(n,2)),Cn(t.baseOptions,0,1,n)}function ta(t){try{const e=t.K.length;if(1===e)throw Error(t.K[0].message);if(1<e)throw Error(\"Encountered multiple errors: \"+t.K.map((t=>t.message)).join(\", \"))}finally{t.K=[]}}function ea(t,e){t.J=Math.max(t.J,e)}function na(t,e){t.C=new Li,ki(t.C,\"PassThroughCalculator\"),xi(t.C,\"free_memory\"),Si(t.C,\"free_memory_unused_out\"),Ii(e,\"free_memory\"),Oi(e,t.C)}function ra(t,e){xi(t.C,e),Si(t.C,e+\"_unused_out\")}function ia(t){t.g.addBoolToStream(!0,\"free_memory\",t.J)}var sa=class{constructor(t){this.g=t,this.K=[],this.J=0,this.g.setAutoRenderToScreen(!1)}l(t,e=!0){if(e){const e=t.baseOptions||{};if(t.baseOptions?.modelAssetBuffer&&t.baseOptions?.modelAssetPath)throw Error(\"Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer\");if(!(Rn(this.baseOptions,Ms,1)?.g()||Rn(this.baseOptions,Ms,1)?.h()||t.baseOptions?.modelAssetBuffer||t.baseOptions?.modelAssetPath))throw Error(\"Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set\");if(function(t,e){let n=Rn(t.baseOptions,Fs,3);if(!n){var r=n=new Fs,i=new pi;On(r,4,Rs,i)}\"delegate\"in e&&(\"GPU\"===e.delegate?(e=n,r=new li,On(e,2,Rs,r)):(e=n,r=new pi,On(e,4,Rs,r))),Cn(t.baseOptions,0,3,n)}(this,e),e.modelAssetPath)return fetch(e.modelAssetPath.toString()).then((t=>{if(t.ok)return t.arrayBuffer();throw Error(`Failed to fetch model: ${e.modelAssetPath} (${t.status})`)})).then((t=>{try{this.g.i.FS_unlink(\"/model.dat\")}catch{}this.g.i.FS_createDataFile(\"/\",\"model.dat\",new Uint8Array(t),!0,!1,!1),Qo(this,\"/model.dat\"),this.m(),this.L()}));if(e.modelAssetBuffer instanceof Uint8Array)Qo(this,e.modelAssetBuffer);else if(e.modelAssetBuffer)return async function(t){const e=[];for(var n=0;;){const{done:r,value:i}=await t.read();if(r)break;e.push(i),n+=i.length}if(0===e.length)return new Uint8Array(0);if(1===e.length)return e[0];t=new Uint8Array(n),n=0;for(const r of e)t.set(r,n),n+=r.length;return t}(e.modelAssetBuffer).then((t=>{Qo(this,t),this.m(),this.L()}))}return this.m(),this.L(),Promise.resolve()}L(){}fa(){let t;if(this.g.fa((e=>{t=Bi(e)})),!t)throw Error(\"Failed to retrieve CalculatorGraphConfig\");return t}setGraph(t,e){this.g.attachErrorListener(((t,e)=>{this.K.push(Error(e))})),this.g.Ma(),this.g.setGraph(t,e),this.C=void 0,ta(this)}finishProcessing(){this.g.finishProcessing(),ta(this)}close(){this.C=void 0,this.g.closeGraph()}};function oa(t,e){if(!t)throw Error(`Unable to obtain required WebGL resource: ${e}`);return t}sa.prototype.close=sa.prototype.close,function(e,n){e=e.split(\".\");var r,i=t;e[0]in i||void 0===i.execScript||i.execScript(\"var \"+e[0]);for(;e.length&&(r=e.shift());)e.length||void 0===n?i=i[r]&&i[r]!==Object.prototype[r]?i[r]:i[r]={}:i[r]=n}(\"TaskRunner\",sa);class aa{constructor(t,e,n,r){this.g=t,this.h=e,this.m=n,this.l=r}bind(){this.g.bindVertexArray(this.h)}close(){this.g.deleteVertexArray(this.h),this.g.deleteBuffer(this.m),this.g.deleteBuffer(this.l)}}function ha(t,e,n){const r=t.g;if(n=oa(r.createShader(n),\"Failed to create WebGL shader\"),r.shaderSource(n,e),r.compileShader(n),!r.getShaderParameter(n,r.COMPILE_STATUS))throw Error(`Could not compile WebGL shader: ${r.getShaderInfoLog(n)}`);return r.attachShader(t.h,n),n}function ca(t,e){const n=t.g,r=oa(n.createVertexArray(),\"Failed to create vertex array\");n.bindVertexArray(r);const i=oa(n.createBuffer(),\"Failed to create buffer\");n.bindBuffer(n.ARRAY_BUFFER,i),n.enableVertexAttribArray(t.K),n.vertexAttribPointer(t.K,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW);const s=oa(n.createBuffer(),\"Failed to create buffer\");return n.bindBuffer(n.ARRAY_BUFFER,s),n.enableVertexAttribArray(t.J),n.vertexAttribPointer(t.J,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array(e?[0,1,0,0,1,0,1,1]:[0,0,0,1,1,1,1,0]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.bindVertexArray(null),new aa(n,r,i,s)}function ua(t,e){if(t.g){if(e!==t.g)throw Error(\"Cannot change GL context once initialized\")}else t.g=e}function la(t,e,n,r){return ua(t,e),t.h||(t.m(),t.D()),n?(t.v||(t.v=ca(t,!0)),n=t.v):(t.A||(t.A=ca(t,!1)),n=t.A),e.useProgram(t.h),n.bind(),t.l(),t=r(),n.g.bindVertexArray(null),t}function da(t,e,n){return ua(t,e),t=oa(e.createTexture(),\"Failed to create texture\"),e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,n??e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,n??e.LINEAR),e.bindTexture(e.TEXTURE_2D,null),t}function fa(t,e,n){ua(t,e),t.u||(t.u=oa(e.createFramebuffer(),\"Failed to create framebuffe.\")),e.bindFramebuffer(e.FRAMEBUFFER,t.u),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0)}function pa(t){t.g?.bindFramebuffer(t.g.FRAMEBUFFER,null)}var ga=class{H(){return\"\\n  precision mediump float;\\n  varying vec2 vTex;\\n  uniform sampler2D inputTexture;\\n  void main() {\\n    gl_FragColor = texture2D(inputTexture, vTex);\\n  }\\n \"}m(){const t=this.g;if(this.h=oa(t.createProgram(),\"Failed to create WebGL program\"),this.ba=ha(this,\"\\n  attribute vec2 aVertex;\\n  attribute vec2 aTex;\\n  varying vec2 vTex;\\n  void main(void) {\\n    gl_Position = vec4(aVertex, 0.0, 1.0);\\n    vTex = aTex;\\n  }\",t.VERTEX_SHADER),this.aa=ha(this,this.H(),t.FRAGMENT_SHADER),t.linkProgram(this.h),!t.getProgramParameter(this.h,t.LINK_STATUS))throw Error(`Error during program linking: ${t.getProgramInfoLog(this.h)}`);this.K=t.getAttribLocation(this.h,\"aVertex\"),this.J=t.getAttribLocation(this.h,\"aTex\")}D(){}l(){}close(){if(this.h){const t=this.g;t.deleteProgram(this.h),t.deleteShader(this.ba),t.deleteShader(this.aa)}this.u&&this.g.deleteFramebuffer(this.u),this.A&&this.A.close(),this.v&&this.v.close()}};var ma=class extends ga{H(){return\"\\n  precision mediump float;\\n  uniform sampler2D backgroundTexture;\\n  uniform sampler2D maskTexture;\\n  uniform sampler2D colorMappingTexture;\\n  varying vec2 vTex;\\n  void main() {\\n    vec4 backgroundColor = texture2D(backgroundTexture, vTex);\\n    float category = texture2D(maskTexture, vTex).r;\\n    vec4 categoryColor = texture2D(colorMappingTexture, vec2(category, 0.0));\\n    gl_FragColor = mix(backgroundColor, categoryColor, categoryColor.a);\\n  }\\n \"}D(){const t=this.g;t.activeTexture(t.TEXTURE1),this.C=da(this,t,t.LINEAR),t.activeTexture(t.TEXTURE2),this.j=da(this,t,t.NEAREST)}m(){super.m();const t=this.g;this.M=oa(t.getUniformLocation(this.h,\"backgroundTexture\"),\"Uniform location\"),this.V=oa(t.getUniformLocation(this.h,\"colorMappingTexture\"),\"Uniform location\"),this.L=oa(t.getUniformLocation(this.h,\"maskTexture\"),\"Uniform location\")}l(){super.l();const t=this.g;t.uniform1i(this.L,0),t.uniform1i(this.M,1),t.uniform1i(this.V,2)}close(){this.C&&this.g.deleteTexture(this.C),this.j&&this.g.deleteTexture(this.j),super.close()}},ya=class extends ga{H(){return\"\\n  precision mediump float;\\n  uniform sampler2D maskTexture;\\n  uniform sampler2D defaultTexture;\\n  uniform sampler2D overlayTexture;\\n  varying vec2 vTex;\\n  void main() {\\n    float confidence = texture2D(maskTexture, vTex).r;\\n    vec4 defaultColor = texture2D(defaultTexture, vTex);\\n    vec4 overlayColor = texture2D(overlayTexture, vTex);\\n    // Apply the alpha from the overlay and merge in the default color\\n    overlayColor = mix(defaultColor, overlayColor, overlayColor.a);\\n    gl_FragColor = mix(defaultColor, overlayColor, confidence);\\n  }\\n \"}D(){const t=this.g;t.activeTexture(t.TEXTURE1),this.j=da(this,t),t.activeTexture(t.TEXTURE2),this.C=da(this,t)}m(){super.m();const t=this.g;this.L=oa(t.getUniformLocation(this.h,\"defaultTexture\"),\"Uniform location\"),this.M=oa(t.getUniformLocation(this.h,\"overlayTexture\"),\"Uniform location\"),this.I=oa(t.getUniformLocation(this.h,\"maskTexture\"),\"Uniform location\")}l(){super.l();const t=this.g;t.uniform1i(this.I,0),t.uniform1i(this.L,1),t.uniform1i(this.M,2)}close(){this.j&&this.g.deleteTexture(this.j),this.C&&this.g.deleteTexture(this.C),super.close()}};function _a(t,e){switch(e){case 0:return t.g.find((t=>t instanceof Uint8Array));case 1:return t.g.find((t=>t instanceof Float32Array));case 2:return t.g.find((t=>\"undefined\"!=typeof WebGLTexture&&t instanceof WebGLTexture));default:throw Error(`Type is not supported: ${e}`)}}function va(t){var e=_a(t,1);if(!e){if(e=_a(t,0))e=new Float32Array(e).map((t=>t/255));else{e=new Float32Array(t.width*t.height);const r=wa(t);var n=Aa(t);if(fa(n,r,Ea(t)),\"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod\".split(\";\").includes(navigator.platform)||navigator.userAgent.includes(\"Mac\")&&\"ontouchend\"in self.document){n=new Float32Array(t.width*t.height*4),r.readPixels(0,0,t.width,t.height,r.RGBA,r.FLOAT,n);for(let t=0,r=0;t<e.length;++t,r+=4)e[t]=n[r]}else r.readPixels(0,0,t.width,t.height,r.RED,r.FLOAT,e)}t.g.push(e)}return e}function Ea(t){let e=_a(t,2);if(!e){const n=wa(t);e=ba(t);const r=va(t),i=Ta(t);n.texImage2D(n.TEXTURE_2D,0,i,t.width,t.height,0,n.RED,n.FLOAT,r),ka(t)}return e}function wa(t){if(!t.canvas)throw Error(\"Conversion to different image formats require that a canvas is passed when initializing the image.\");return t.h||(t.h=oa(t.canvas.getContext(\"webgl2\"),\"You cannot use a canvas that is already bound to a different type of rendering context.\")),t.h}function Ta(t){if(t=wa(t),!xa)if(t.getExtension(\"EXT_color_buffer_float\")&&t.getExtension(\"OES_texture_float_linear\")&&t.getExtension(\"EXT_float_blend\"))xa=t.R32F;else{if(!t.getExtension(\"EXT_color_buffer_half_float\"))throw Error(\"GPU does not fully support 4-channel float32 or float16 formats\");xa=t.R16F}return xa}function Aa(t){return t.l||(t.l=new ga),t.l}function ba(t){const e=wa(t);e.viewport(0,0,t.width,t.height),e.activeTexture(e.TEXTURE0);let n=_a(t,2);return n||(n=da(Aa(t),e,t.m?e.LINEAR:e.NEAREST),t.g.push(n),t.j=!0),e.bindTexture(e.TEXTURE_2D,n),n}function ka(t){t.h.bindTexture(t.h.TEXTURE_2D,null)}var xa,Sa=class{constructor(t,e,n,r,i,s,o){this.g=t,this.m=e,this.j=n,this.canvas=r,this.l=i,this.width=s,this.height=o,this.j&&(0===--La&&console.error(\"You seem to be creating MPMask instances without invoking .close(). This leaks resources.\"))}Ha(){return!!_a(this,0)}la(){return!!_a(this,1)}R(){return!!_a(this,2)}ka(){return(e=_a(t=this,0))||(e=va(t),e=new Uint8Array(e.map((t=>255*t))),t.g.push(e)),e;var t,e}ja(){return va(this)}O(){return Ea(this)}clone(){const t=[];for(const e of this.g){let n;if(e instanceof Uint8Array)n=new Uint8Array(e);else if(e instanceof Float32Array)n=new Float32Array(e);else{if(!(e instanceof WebGLTexture))throw Error(`Type is not supported: ${e}`);{const t=wa(this),e=Aa(this);t.activeTexture(t.TEXTURE1),n=da(e,t,this.m?t.LINEAR:t.NEAREST),t.bindTexture(t.TEXTURE_2D,n);const r=Ta(this);t.texImage2D(t.TEXTURE_2D,0,r,this.width,this.height,0,t.RED,t.FLOAT,null),t.bindTexture(t.TEXTURE_2D,null),fa(e,t,n),la(e,t,!1,(()=>{ba(this),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.drawArrays(t.TRIANGLE_FAN,0,4),ka(this)})),pa(e),ka(this)}}t.push(n)}return new Sa(t,this.m,this.R(),this.canvas,this.l,this.width,this.height)}close(){this.j&&wa(this).deleteTexture(_a(this,2)),La=-1}};Sa.prototype.close=Sa.prototype.close,Sa.prototype.clone=Sa.prototype.clone,Sa.prototype.getAsWebGLTexture=Sa.prototype.O,Sa.prototype.getAsFloat32Array=Sa.prototype.ja,Sa.prototype.getAsUint8Array=Sa.prototype.ka,Sa.prototype.hasWebGLTexture=Sa.prototype.R,Sa.prototype.hasFloat32Array=Sa.prototype.la,Sa.prototype.hasUint8Array=Sa.prototype.Ha;var La=250;const Fa={color:\"white\",lineWidth:4,radius:6};function Ra(t){return{...Fa,fillColor:(t=t||{}).color,...t}}function Ma(t,e){return t instanceof Function?t(e):t}function Pa(t,e,n){return Math.max(Math.min(e,n),Math.min(Math.max(e,n),t))}function Ca(t){if(!t.l)throw Error(\"CPU rendering requested but CanvasRenderingContext2D not provided.\");return t.l}function Oa(t){if(!t.j)throw Error(\"GPU rendering requested but WebGL2RenderingContext not provided.\");return t.j}function Ia(t,e,n){if(e.R())n(e.O());else{const r=e.la()?e.ja():e.ka();t.m=t.m??new ga;const i=Oa(t);n((t=new Sa([r],e.m,!1,i.canvas,t.m,e.width,e.height)).O()),t.close()}}function Ua(t,e,n,r){const i=function(t){return t.g||(t.g=new ma),t.g}(t),s=Oa(t),o=Array.isArray(n)?new ImageData(new Uint8ClampedArray(n),1,1):n;la(i,s,!0,(()=>{!function(t,e,n,r){const i=t.g;if(i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,e),i.activeTexture(i.TEXTURE1),i.bindTexture(i.TEXTURE_2D,t.C),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,n),t.I&&function(t,e){if(t!==e)return!1;t=t.entries(),e=e.entries();for(const[r,i]of t){t=r;const s=i;var n=e.next();if(n.done)return!1;const[o,a]=n.value;if(n=a,t!==o||s[0]!==n[0]||s[1]!==n[1]||s[2]!==n[2]||s[3]!==n[3])return!1}return!!e.next().done}(t.I,r))i.activeTexture(i.TEXTURE2),i.bindTexture(i.TEXTURE_2D,t.j);else{t.I=r;const e=Array(1024).fill(0);r.forEach(((t,n)=>{if(4!==t.length)throw Error(`Color at index ${n} is not a four-channel value.`);e[4*n]=t[0],e[4*n+1]=t[1],e[4*n+2]=t[2],e[4*n+3]=t[3]})),i.activeTexture(i.TEXTURE2),i.bindTexture(i.TEXTURE_2D,t.j),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,256,1,0,i.RGBA,i.UNSIGNED_BYTE,new Uint8Array(e))}}(i,e,o,r),s.clearColor(0,0,0,0),s.clear(s.COLOR_BUFFER_BIT),s.drawArrays(s.TRIANGLE_FAN,0,4);const t=i.g;t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,null),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,null),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,null)}))}function Da(t,e,n,r){const i=Oa(t),s=function(t){return t.h||(t.h=new ya),t.h}(t),o=Array.isArray(n)?new ImageData(new Uint8ClampedArray(n),1,1):n,a=Array.isArray(r)?new ImageData(new Uint8ClampedArray(r),1,1):r;la(s,i,!0,(()=>{var t=s.g;t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,s.j),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,o),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,s.C),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,a),i.clearColor(0,0,0,0),i.clear(i.COLOR_BUFFER_BIT),i.drawArrays(i.TRIANGLE_FAN,0,4),i.bindTexture(i.TEXTURE_2D,null),(t=s.g).activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,null),t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,null),t.activeTexture(t.TEXTURE2),t.bindTexture(t.TEXTURE_2D,null)}))}var Na=class{constructor(t,e){t instanceof CanvasRenderingContext2D||t instanceof OffscreenCanvasRenderingContext2D?(this.l=t,this.j=e):this.j=t}Aa(t,e){if(t){var n=Ca(this);e=Ra(e),n.save();var r=n.canvas,i=0;for(const s of t)n.fillStyle=Ma(e.fillColor,{index:i,from:s}),n.strokeStyle=Ma(e.color,{index:i,from:s}),n.lineWidth=Ma(e.lineWidth,{index:i,from:s}),(t=new Path2D).arc(s.x*r.width,s.y*r.height,Ma(e.radius,{index:i,from:s}),0,2*Math.PI),n.fill(t),n.stroke(t),++i;n.restore()}}za(t,e,n){if(t&&e){var r=Ca(this);n=Ra(n),r.save();var i=r.canvas,s=0;for(const o of e){r.beginPath(),e=t[o.start];const a=t[o.end];e&&a&&(r.strokeStyle=Ma(n.color,{index:s,from:e,to:a}),r.lineWidth=Ma(n.lineWidth,{index:s,from:e,to:a}),r.moveTo(e.x*i.width,e.y*i.height),r.lineTo(a.x*i.width,a.y*i.height)),++s,r.stroke()}r.restore()}}wa(t,e){const n=Ca(this);e=Ra(e),n.save(),n.beginPath(),n.lineWidth=Ma(e.lineWidth,{}),n.strokeStyle=Ma(e.color,{}),n.fillStyle=Ma(e.fillColor,{}),n.moveTo(t.originX,t.originY),n.lineTo(t.originX+t.width,t.originY),n.lineTo(t.originX+t.width,t.originY+t.height),n.lineTo(t.originX,t.originY+t.height),n.lineTo(t.originX,t.originY),n.stroke(),n.fill(),n.restore()}xa(t,e,n=[0,0,0,255]){this.l?function(t,e,n,r){const i=Oa(t);Ia(t,e,(e=>{Ua(t,e,n,r),(e=Ca(t)).drawImage(i.canvas,0,0,e.canvas.width,e.canvas.height)}))}(this,t,n,e):Ua(this,t.O(),n,e)}ya(t,e,n){this.l?function(t,e,n,r){const i=Oa(t);Ia(t,e,(e=>{Da(t,e,n,r),(e=Ca(t)).drawImage(i.canvas,0,0,e.canvas.width,e.canvas.height)}))}(this,t,e,n):Da(this,t.O(),e,n)}close(){this.g?.close(),this.g=void 0,this.h?.close(),this.h=void 0,this.m?.close(),this.m=void 0}};function Ba(t,e){switch(e){case 0:return t.g.find((t=>t instanceof ImageData));case 1:return t.g.find((t=>\"undefined\"!=typeof ImageBitmap&&t instanceof ImageBitmap));case 2:return t.g.find((t=>\"undefined\"!=typeof WebGLTexture&&t instanceof WebGLTexture));default:throw Error(`Type is not supported: ${e}`)}}function Ga(t){var e=Ba(t,0);if(!e){e=Va(t);const n=Xa(t),r=new Uint8Array(t.width*t.height*4);fa(n,e,ja(t)),e.readPixels(0,0,t.width,t.height,e.RGBA,e.UNSIGNED_BYTE,r),pa(n),e=new ImageData(new Uint8ClampedArray(r.buffer),t.width,t.height),t.g.push(e)}return e}function ja(t){let e=Ba(t,2);if(!e){const n=Va(t);e=Ha(t);const r=Ba(t,1)||Ga(t);n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,r),Wa(t)}return e}function Va(t){if(!t.canvas)throw Error(\"Conversion to different image formats require that a canvas is passed when iniitializing the image.\");return t.h||(t.h=oa(t.canvas.getContext(\"webgl2\"),\"You cannot use a canvas that is already bound to a different type of rendering context.\")),t.h}function Xa(t){return t.l||(t.l=new ga),t.l}function Ha(t){const e=Va(t);e.viewport(0,0,t.width,t.height),e.activeTexture(e.TEXTURE0);let n=Ba(t,2);return n||(n=da(Xa(t),e),t.g.push(n),t.m=!0),e.bindTexture(e.TEXTURE_2D,n),n}function Wa(t){t.h.bindTexture(t.h.TEXTURE_2D,null)}function za(t){const e=Va(t);return la(Xa(t),e,!0,(()=>function(t,e){const n=t.canvas;if(n.width===t.width&&n.height===t.height)return e();const r=n.width,i=n.height;return n.width=t.width,n.height=t.height,t=e(),n.width=r,n.height=i,t}(t,(()=>{if(e.bindFramebuffer(e.FRAMEBUFFER,null),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT),e.drawArrays(e.TRIANGLE_FAN,0,4),!(t.canvas instanceof OffscreenCanvas))throw Error(\"Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas\");return t.canvas.transferToImageBitmap()}))))}Na.prototype.close=Na.prototype.close,Na.prototype.drawConfidenceMask=Na.prototype.ya,Na.prototype.drawCategoryMask=Na.prototype.xa,Na.prototype.drawBoundingBox=Na.prototype.wa,Na.prototype.drawConnectors=Na.prototype.za,Na.prototype.drawLandmarks=Na.prototype.Aa,Na.lerp=function(t,e,n,r,i){return Pa(r*(1-(t-e)/(n-e))+i*(1-(n-t)/(n-e)),r,i)},Na.clamp=Pa;var Ka=class{constructor(t,e,n,r,i,s,o){this.g=t,this.j=e,this.m=n,this.canvas=r,this.l=i,this.width=s,this.height=o,(this.j||this.m)&&(0===--Ya&&console.error(\"You seem to be creating MPImage instances without invoking .close(). This leaks resources.\"))}Ga(){return!!Ba(this,0)}ma(){return!!Ba(this,1)}R(){return!!Ba(this,2)}Ea(){return Ga(this)}Da(){var t=Ba(this,1);return t||(ja(this),Ha(this),t=za(this),Wa(this),this.g.push(t),this.j=!0),t}O(){return ja(this)}clone(){const t=[];for(const e of this.g){let n;if(e instanceof ImageData)n=new ImageData(e.data,this.width,this.height);else if(e instanceof WebGLTexture){const t=Va(this),e=Xa(this);t.activeTexture(t.TEXTURE1),n=da(e,t),t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,this.width,this.height,0,t.RGBA,t.UNSIGNED_BYTE,null),t.bindTexture(t.TEXTURE_2D,null),fa(e,t,n),la(e,t,!1,(()=>{Ha(this),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.drawArrays(t.TRIANGLE_FAN,0,4),Wa(this)})),pa(e),Wa(this)}else{if(!(e instanceof ImageBitmap))throw Error(`Type is not supported: ${e}`);ja(this),Ha(this),n=za(this),Wa(this)}t.push(n)}return new Ka(t,this.ma(),this.R(),this.canvas,this.l,this.width,this.height)}close(){this.j&&Ba(this,1).close(),this.m&&Va(this).deleteTexture(Ba(this,2)),Ya=-1}};Ka.prototype.close=Ka.prototype.close,Ka.prototype.clone=Ka.prototype.clone,Ka.prototype.getAsWebGLTexture=Ka.prototype.O,Ka.prototype.getAsImageBitmap=Ka.prototype.Da,Ka.prototype.getAsImageData=Ka.prototype.Ea,Ka.prototype.hasWebGLTexture=Ka.prototype.R,Ka.prototype.hasImageBitmap=Ka.prototype.ma,Ka.prototype.hasImageData=Ka.prototype.Ga;var Ya=250;function $a(...t){return t.map((([t,e])=>({start:t,end:e})))}const qa=function(t){return class extends t{Ma(){this.i._registerModelResourcesGraphService()}}}((Ja=class{constructor(t,e){this.l=!0,this.i=t,this.g=null,this.h=0,this.m=\"function\"==typeof this.i._addIntToInputStream,void 0!==e?this.i.canvas=e:Ho()?this.i.canvas=new OffscreenCanvas(1,1):(console.warn(\"OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas.\"),this.i.canvas=document.createElement(\"canvas\"))}async initializeGraph(t){const e=await(await fetch(t)).arrayBuffer();t=!(t.endsWith(\".pbtxt\")||t.endsWith(\".textproto\")),this.setGraph(new Uint8Array(e),t)}setGraphFromString(t){this.setGraph((new TextEncoder).encode(t),!1)}setGraph(t,e){const n=t.length,r=this.i._malloc(n);this.i.HEAPU8.set(t,r),e?this.i._changeBinaryGraph(n,r):this.i._changeTextGraph(n,r),this.i._free(r)}configureAudio(t,e,n,r,i){this.i._configureAudio||console.warn('Attempting to use configureAudio without support for input audio. Is build dep \":gl_graph_runner_audio\" missing?'),Ko(this,r||\"input_audio\",(r=>{Ko(this,i=i||\"audio_header\",(i=>{this.i._configureAudio(r,i,t,e,n)}))}))}setAutoResizeCanvas(t){this.l=t}setAutoRenderToScreen(t){this.i._setAutoRenderToScreen(t)}setGpuBufferVerticalFlip(t){this.i.gpuOriginForWebTexturesIsBottomLeft=t}fa(t){qo(this,\"__graph_config__\",(e=>{t(e)})),Ko(this,\"__graph_config__\",(t=>{this.i._getGraphConfig(t,void 0)})),delete this.i.simpleListeners.__graph_config__}attachErrorListener(t){this.i.errorListener=t}attachEmptyPacketListener(t,e){this.i.emptyPacketListeners=this.i.emptyPacketListeners||{},this.i.emptyPacketListeners[t]=e}addAudioToStream(t,e,n){this.addAudioToStreamWithShape(t,0,0,e,n)}addAudioToStreamWithShape(t,e,n,r,i){const s=4*t.length;this.h!==s&&(this.g&&this.i._free(this.g),this.g=this.i._malloc(s),this.h=s),this.i.HEAPF32.set(t,this.g/4),Ko(this,r,(t=>{this.i._addAudioToInputStream(this.g,e,n,t,i)}))}addGpuBufferToStream(t,e,n){Ko(this,e,(e=>{const[r,i]=Yo(this,t,e);this.i._addBoundTextureToStream(e,r,i,n)}))}addBoolToStream(t,e,n){Ko(this,e,(e=>{this.i._addBoolToInputStream(t,e,n)}))}addDoubleToStream(t,e,n){Ko(this,e,(e=>{this.i._addDoubleToInputStream(t,e,n)}))}addFloatToStream(t,e,n){Ko(this,e,(e=>{this.i._addFloatToInputStream(t,e,n)}))}addIntToStream(t,e,n){Ko(this,e,(e=>{this.i._addIntToInputStream(t,e,n)}))}addUintToStream(t,e,n){Ko(this,e,(e=>{this.i._addUintToInputStream(t,e,n)}))}addStringToStream(t,e,n){Ko(this,e,(e=>{Ko(this,t,(t=>{this.i._addStringToInputStream(t,e,n)}))}))}addStringRecordToStream(t,e,n){Ko(this,e,(e=>{$o(this,Object.keys(t),(r=>{$o(this,Object.values(t),(i=>{this.i._addFlatHashMapToInputStream(r,i,Object.keys(t).length,e,n)}))}))}))}addProtoToStream(t,e,n,r){Ko(this,n,(n=>{Ko(this,e,(e=>{const i=this.i._malloc(t.length);this.i.HEAPU8.set(t,i),this.i._addProtoToInputStream(i,t.length,e,n,r),this.i._free(i)}))}))}addEmptyPacketToStream(t,e){Ko(this,t,(t=>{this.i._addEmptyPacketToInputStream(t,e)}))}addBoolVectorToStream(t,e,n){Ko(this,e,(e=>{const r=this.i._allocateBoolVector(t.length);if(!r)throw Error(\"Unable to allocate new bool vector on heap.\");for(const e of t)this.i._addBoolVectorEntry(r,e);this.i._addBoolVectorToInputStream(r,e,n)}))}addDoubleVectorToStream(t,e,n){Ko(this,e,(e=>{const r=this.i._allocateDoubleVector(t.length);if(!r)throw Error(\"Unable to allocate new double vector on heap.\");for(const e of t)this.i._addDoubleVectorEntry(r,e);this.i._addDoubleVectorToInputStream(r,e,n)}))}addFloatVectorToStream(t,e,n){Ko(this,e,(e=>{const r=this.i._allocateFloatVector(t.length);if(!r)throw Error(\"Unable to allocate new float vector on heap.\");for(const e of t)this.i._addFloatVectorEntry(r,e);this.i._addFloatVectorToInputStream(r,e,n)}))}addIntVectorToStream(t,e,n){Ko(this,e,(e=>{const r=this.i._allocateIntVector(t.length);if(!r)throw Error(\"Unable to allocate new int vector on heap.\");for(const e of t)this.i._addIntVectorEntry(r,e);this.i._addIntVectorToInputStream(r,e,n)}))}addUintVectorToStream(t,e,n){Ko(this,e,(e=>{const r=this.i._allocateUintVector(t.length);if(!r)throw Error(\"Unable to allocate new unsigned int vector on heap.\");for(const e of t)this.i._addUintVectorEntry(r,e);this.i._addUintVectorToInputStream(r,e,n)}))}addStringVectorToStream(t,e,n){Ko(this,e,(e=>{const r=this.i._allocateStringVector(t.length);if(!r)throw Error(\"Unable to allocate new string vector on heap.\");for(const e of t)Ko(this,e,(t=>{this.i._addStringVectorEntry(r,t)}));this.i._addStringVectorToInputStream(r,e,n)}))}addBoolToInputSidePacket(t,e){Ko(this,e,(e=>{this.i._addBoolToInputSidePacket(t,e)}))}addDoubleToInputSidePacket(t,e){Ko(this,e,(e=>{this.i._addDoubleToInputSidePacket(t,e)}))}addFloatToInputSidePacket(t,e){Ko(this,e,(e=>{this.i._addFloatToInputSidePacket(t,e)}))}addIntToInputSidePacket(t,e){Ko(this,e,(e=>{this.i._addIntToInputSidePacket(t,e)}))}addUintToInputSidePacket(t,e){Ko(this,e,(e=>{this.i._addUintToInputSidePacket(t,e)}))}addStringToInputSidePacket(t,e){Ko(this,e,(e=>{Ko(this,t,(t=>{this.i._addStringToInputSidePacket(t,e)}))}))}addProtoToInputSidePacket(t,e,n){Ko(this,n,(n=>{Ko(this,e,(e=>{const r=this.i._malloc(t.length);this.i.HEAPU8.set(t,r),this.i._addProtoToInputSidePacket(r,t.length,e,n),this.i._free(r)}))}))}addBoolVectorToInputSidePacket(t,e){Ko(this,e,(e=>{const n=this.i._allocateBoolVector(t.length);if(!n)throw Error(\"Unable to allocate new bool vector on heap.\");for(const e of t)this.i._addBoolVectorEntry(n,e);this.i._addBoolVectorToInputSidePacket(n,e)}))}addDoubleVectorToInputSidePacket(t,e){Ko(this,e,(e=>{const n=this.i._allocateDoubleVector(t.length);if(!n)throw Error(\"Unable to allocate new double vector on heap.\");for(const e of t)this.i._addDoubleVectorEntry(n,e);this.i._addDoubleVectorToInputSidePacket(n,e)}))}addFloatVectorToInputSidePacket(t,e){Ko(this,e,(e=>{const n=this.i._allocateFloatVector(t.length);if(!n)throw Error(\"Unable to allocate new float vector on heap.\");for(const e of t)this.i._addFloatVectorEntry(n,e);this.i._addFloatVectorToInputSidePacket(n,e)}))}addIntVectorToInputSidePacket(t,e){Ko(this,e,(e=>{const n=this.i._allocateIntVector(t.length);if(!n)throw Error(\"Unable to allocate new int vector on heap.\");for(const e of t)this.i._addIntVectorEntry(n,e);this.i._addIntVectorToInputSidePacket(n,e)}))}addUintVectorToInputSidePacket(t,e){Ko(this,e,(e=>{const n=this.i._allocateUintVector(t.length);if(!n)throw Error(\"Unable to allocate new unsigned int vector on heap.\");for(const e of t)this.i._addUintVectorEntry(n,e);this.i._addUintVectorToInputSidePacket(n,e)}))}addStringVectorToInputSidePacket(t,e){Ko(this,e,(e=>{const n=this.i._allocateStringVector(t.length);if(!n)throw Error(\"Unable to allocate new string vector on heap.\");for(const e of t)Ko(this,e,(t=>{this.i._addStringVectorEntry(n,t)}));this.i._addStringVectorToInputSidePacket(n,e)}))}attachBoolListener(t,e){qo(this,t,e),Ko(this,t,(t=>{this.i._attachBoolListener(t)}))}attachBoolVectorListener(t,e){Jo(this,t,e),Ko(this,t,(t=>{this.i._attachBoolVectorListener(t)}))}attachIntListener(t,e){qo(this,t,e),Ko(this,t,(t=>{this.i._attachIntListener(t)}))}attachIntVectorListener(t,e){Jo(this,t,e),Ko(this,t,(t=>{this.i._attachIntVectorListener(t)}))}attachUintListener(t,e){qo(this,t,e),Ko(this,t,(t=>{this.i._attachUintListener(t)}))}attachUintVectorListener(t,e){Jo(this,t,e),Ko(this,t,(t=>{this.i._attachUintVectorListener(t)}))}attachDoubleListener(t,e){qo(this,t,e),Ko(this,t,(t=>{this.i._attachDoubleListener(t)}))}attachDoubleVectorListener(t,e){Jo(this,t,e),Ko(this,t,(t=>{this.i._attachDoubleVectorListener(t)}))}attachFloatListener(t,e){qo(this,t,e),Ko(this,t,(t=>{this.i._attachFloatListener(t)}))}attachFloatVectorListener(t,e){Jo(this,t,e),Ko(this,t,(t=>{this.i._attachFloatVectorListener(t)}))}attachStringListener(t,e){qo(this,t,e),Ko(this,t,(t=>{this.i._attachStringListener(t)}))}attachStringVectorListener(t,e){Jo(this,t,e),Ko(this,t,(t=>{this.i._attachStringVectorListener(t)}))}attachProtoListener(t,e,n){qo(this,t,e),Ko(this,t,(t=>{this.i._attachProtoListener(t,n||!1)}))}attachProtoVectorListener(t,e,n){Jo(this,t,e),Ko(this,t,(t=>{this.i._attachProtoVectorListener(t,n||!1)}))}attachAudioListener(t,e,n){this.i._attachAudioListener||console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep \":gl_graph_runner_audio_out\" missing?'),qo(this,t,((t,n)=>{t=new Float32Array(t.buffer,t.byteOffset,t.length/4),e(t,n)})),Ko(this,t,(t=>{this.i._attachAudioListener(t,n||!1)}))}finishProcessing(){this.i._waitUntilIdle()}closeGraph(){this.i._closeGraph(),this.i.simpleListeners=void 0,this.i.emptyPacketListeners=void 0}},class extends Ja{get ha(){return this.i}sa(t,e,n){Ko(this,e,(e=>{const[r,i]=Yo(this,t,e);this.ha._addBoundTextureAsImageToStream(e,r,i,n)}))}W(t,e){qo(this,t,e),Ko(this,t,(t=>{this.ha._attachImageListener(t)}))}da(t,e){Jo(this,t,e),Ko(this,t,(t=>{this.ha._attachImageVectorListener(t)}))}}));var Ja,Za=class extends qa{};async function Qa(t,e,n){return async function(t,e,n,r){return Zo(t,e,n,r)}(t,n.canvas??(Ho()?void 0:document.createElement(\"canvas\")),e,n)}function th(t,e,n,r){if(t.V){const s=new fs;if(n?.regionOfInterest){if(!t.ra)throw Error(\"This task doesn't support region-of-interest.\");var i=n.regionOfInterest;if(i.left>=i.right||i.top>=i.bottom)throw Error(\"Expected RectF with left < right and top < bottom.\");if(0>i.left||0>i.top||1<i.right||1<i.bottom)throw Error(\"Expected RectF values to be in [0,1].\");Hn(s,1,(i.left+i.right)/2),Hn(s,2,(i.top+i.bottom)/2),Hn(s,4,i.right-i.left),Hn(s,3,i.bottom-i.top)}else Hn(s,1,.5),Hn(s,2,.5),Hn(s,4,1),Hn(s,3,1);if(n?.rotationDegrees){if(0!=n?.rotationDegrees%90)throw Error(\"Expected rotation to be a multiple of 90Â°.\");if(Hn(s,5,-Math.PI*n.rotationDegrees/180),0!=n?.rotationDegrees%180){const[t,r]=zo(e);n=Gn(s,3)*r/t,i=Gn(s,4)*t/r,Hn(s,4,n),Hn(s,3,i)}}t.g.addProtoToStream(s.g(),\"mediapipe.NormalizedRect\",t.V,r)}t.g.sa(e,t.ba,r??performance.now()),t.finishProcessing()}function eh(t,e,n){if(t.baseOptions?.g())throw Error(\"Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.\");th(t,e,n,t.J+1)}function nh(t,e,n,r){if(!t.baseOptions?.g())throw Error(\"Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.\");th(t,e,n,r)}function rh(t,e,n,r){var i=e.data;const s=e.width,o=s*(e=e.height);if((i instanceof Uint8Array||i instanceof Float32Array)&&i.length!==o)throw Error(\"Unsupported channel count: \"+i.length/o);return t=new Sa([i],n,!1,t.g.i.canvas,t.M,s,e),r?t.clone():t}var ih=class extends sa{constructor(t,e,n,r){super(t),this.g=t,this.ba=e,this.V=n,this.ra=r,this.M=new ga}l(t,e=!0){if(\"runningMode\"in t&&Vn(this.baseOptions,2,!!t.runningMode&&\"IMAGE\"!==t.runningMode),void 0!==t.canvas&&this.g.i.canvas!==t.canvas)throw Error(\"You must create a new task to reset the canvas.\");return super.l(t,e)}close(){this.M.close(),super.close()}};ih.prototype.close=ih.prototype.close;var sh=class extends ih{constructor(t,e){super(new Za(t,e),\"image_in\",\"norm_rect_in\",!1),this.j={detections:[]},Cn(t=this.h=new Is,0,1,e=new Cs),Hn(this.h,2,.5),Hn(this.h,3,.3)}get baseOptions(){return Rn(this.h,Cs,1)}set baseOptions(t){Cn(this.h,0,1,t)}o(t){return\"minDetectionConfidence\"in t&&Hn(this.h,2,t.minDetectionConfidence??.5),\"minSuppressionThreshold\"in t&&Hn(this.h,3,t.minSuppressionThreshold??.3),this.l(t)}F(t,e){return this.j={detections:[]},eh(this,t,e),this.j}G(t,e,n){return this.j={detections:[]},nh(this,t,n,e),this.j}m(){var t=new Di;Ii(t,\"image_in\"),Ii(t,\"norm_rect_in\"),Ui(t,\"detections\");const e=new yi;Wn(e,Ds,this.h);const n=new Li;ki(n,\"mediapipe.tasks.vision.face_detector.FaceDetectorGraph\"),xi(n,\"IMAGE:image_in\"),xi(n,\"NORM_RECT:norm_rect_in\"),Si(n,\"DETECTIONS:detections\"),n.o(e),Oi(t,n),this.g.attachProtoVectorListener(\"detections\",((t,e)=>{for(const e of t)t=ns(e),this.j.detections.push(Oo(t));ea(this,e)})),this.g.attachEmptyPacketListener(\"detections\",(t=>{ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};sh.prototype.detectForVideo=sh.prototype.G,sh.prototype.detect=sh.prototype.F,sh.prototype.setOptions=sh.prototype.o,sh.createFromModelPath=async function(t,e){return Qa(sh,t,{baseOptions:{modelAssetPath:e}})},sh.createFromModelBuffer=function(t,e){return Qa(sh,t,{baseOptions:{modelAssetBuffer:e}})},sh.createFromOptions=function(t,e){return Qa(sh,t,e)};var oh=$a([61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]),ah=$a([263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]),hh=$a([276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]),ch=$a([474,475],[475,476],[476,477],[477,474]),uh=$a([33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]),lh=$a([46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]),dh=$a([469,470],[470,471],[471,472],[472,469]),fh=$a([10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]),ph=[...oh,...ah,...hh,...uh,...lh,...fh],gh=$a([127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]);function mh(t){t.u={faceLandmarks:[],faceBlendshapes:[],facialTransformationMatrixes:[]}}var yh=class extends ih{constructor(t,e){super(new Za(t,e),\"image_in\",\"norm_rect\",!1),this.u={faceLandmarks:[],faceBlendshapes:[],facialTransformationMatrixes:[]},this.outputFacialTransformationMatrixes=this.outputFaceBlendshapes=!1,Cn(t=this.h=new Hs,0,1,e=new Cs),this.H=new Vs,Cn(this.h,0,3,this.H),this.j=new Is,Cn(this.h,0,2,this.j),Xn(this.j,4,1),Hn(this.j,2,.5),Hn(this.H,2,.5),Hn(this.h,4,.5)}get baseOptions(){return Rn(this.h,Cs,1)}set baseOptions(t){Cn(this.h,0,1,t)}o(t){return\"numFaces\"in t&&Xn(this.j,4,t.numFaces??1),\"minFaceDetectionConfidence\"in t&&Hn(this.j,2,t.minFaceDetectionConfidence??.5),\"minTrackingConfidence\"in t&&Hn(this.h,4,t.minTrackingConfidence??.5),\"minFacePresenceConfidence\"in t&&Hn(this.H,2,t.minFacePresenceConfidence??.5),\"outputFaceBlendshapes\"in t&&(this.outputFaceBlendshapes=!!t.outputFaceBlendshapes),\"outputFacialTransformationMatrixes\"in t&&(this.outputFacialTransformationMatrixes=!!t.outputFacialTransformationMatrixes),this.l(t)}F(t,e){return mh(this),eh(this,t,e),this.u}G(t,e,n){return mh(this),nh(this,t,n,e),this.u}m(){var t=new Di;Ii(t,\"image_in\"),Ii(t,\"norm_rect\"),Ui(t,\"face_landmarks\");const e=new yi;Wn(e,zs,this.h);const n=new Li;ki(n,\"mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph\"),xi(n,\"IMAGE:image_in\"),xi(n,\"NORM_RECT:norm_rect\"),Si(n,\"NORM_LANDMARKS:face_landmarks\"),n.o(e),Oi(t,n),this.g.attachProtoVectorListener(\"face_landmarks\",((t,e)=>{for(const e of t)t=us(e),this.u.faceLandmarks.push(Io(t));ea(this,e)})),this.g.attachEmptyPacketListener(\"face_landmarks\",(t=>{ea(this,t)})),this.outputFaceBlendshapes&&(Ui(t,\"blendshapes\"),Si(n,\"BLENDSHAPES:blendshapes\"),this.g.attachProtoVectorListener(\"blendshapes\",((t,e)=>{if(this.outputFaceBlendshapes)for(const e of t)t=Wi(e),this.u.faceBlendshapes.push(Co(t.g()??[]));ea(this,e)})),this.g.attachEmptyPacketListener(\"blendshapes\",(t=>{ea(this,t)}))),this.outputFacialTransformationMatrixes&&(Ui(t,\"face_geometry\"),Si(n,\"FACE_GEOMETRY:face_geometry\"),this.g.attachProtoVectorListener(\"face_geometry\",((t,e)=>{if(this.outputFacialTransformationMatrixes)for(const e of t)(t=Rn(Gs(e),ls,2))&&this.u.facialTransformationMatrixes.push({rows:Bn(Nn(t,1),0)??0,columns:Bn(Nn(t,2),0)??0,data:yn(t,3,ve).slice()??[]});ea(this,e)})),this.g.attachEmptyPacketListener(\"face_geometry\",(t=>{ea(this,t)}))),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};yh.prototype.detectForVideo=yh.prototype.G,yh.prototype.detect=yh.prototype.F,yh.prototype.setOptions=yh.prototype.o,yh.createFromModelPath=function(t,e){return Qa(yh,t,{baseOptions:{modelAssetPath:e}})},yh.createFromModelBuffer=function(t,e){return Qa(yh,t,{baseOptions:{modelAssetBuffer:e}})},yh.createFromOptions=function(t,e){return Qa(yh,t,e)},yh.FACE_LANDMARKS_LIPS=oh,yh.FACE_LANDMARKS_LEFT_EYE=ah,yh.FACE_LANDMARKS_LEFT_EYEBROW=hh,yh.FACE_LANDMARKS_LEFT_IRIS=ch,yh.FACE_LANDMARKS_RIGHT_EYE=uh,yh.FACE_LANDMARKS_RIGHT_EYEBROW=lh,yh.FACE_LANDMARKS_RIGHT_IRIS=dh,yh.FACE_LANDMARKS_FACE_OVAL=fh,yh.FACE_LANDMARKS_CONTOURS=ph,yh.FACE_LANDMARKS_TESSELATION=gh;var _h=class extends ih{constructor(t,e){super(new Za(t,e),\"image_in\",\"norm_rect\",!0),Cn(t=this.j=new Ks,0,1,e=new Cs)}get baseOptions(){return Rn(this.j,Cs,1)}set baseOptions(t){Cn(this.j,0,1,t)}o(t){return super.l(t)}Pa(t,e,n){const r=\"function\"!=typeof e?e:{};if(this.h=\"function\"==typeof e?e:n,eh(this,t,r??{}),!this.h)return this.u}m(){var t=new Di;Ii(t,\"image_in\"),Ii(t,\"norm_rect\"),Ui(t,\"stylized_image\");const e=new yi;Wn(e,Ys,this.j);const n=new Li;ki(n,\"mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph\"),xi(n,\"IMAGE:image_in\"),xi(n,\"NORM_RECT:norm_rect\"),Si(n,\"STYLIZED_IMAGE:stylized_image\"),n.o(e),Oi(t,n),this.g.W(\"stylized_image\",((t,e)=>{var n=!this.h,r=t.data,i=t.width;const s=i*(t=t.height);if(r instanceof Uint8Array)if(r.length===3*s){const e=new Uint8ClampedArray(4*s);for(let t=0;t<s;++t)e[4*t]=r[3*t],e[4*t+1]=r[3*t+1],e[4*t+2]=r[3*t+2],e[4*t+3]=255;r=new ImageData(e,i,t)}else{if(r.length!==4*s)throw Error(\"Unsupported channel count: \"+r.length/s);r=new ImageData(new Uint8ClampedArray(r.buffer,r.byteOffset,r.length),i,t)}else if(!(r instanceof WebGLTexture))throw Error(`Unsupported format: ${r.constructor.name}`);i=new Ka([r],!1,!1,this.g.i.canvas,this.M,i,t),this.u=n=n?i.clone():i,this.h&&this.h(n),ea(this,e)})),this.g.attachEmptyPacketListener(\"stylized_image\",(t=>{this.u=null,this.h&&this.h(null),ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};_h.prototype.stylize=_h.prototype.Pa,_h.prototype.setOptions=_h.prototype.o,_h.createFromModelPath=function(t,e){return Qa(_h,t,{baseOptions:{modelAssetPath:e}})},_h.createFromModelBuffer=function(t,e){return Qa(_h,t,{baseOptions:{modelAssetBuffer:e}})},_h.createFromOptions=function(t,e){return Qa(_h,t,e)};var vh=$a([0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[0,17],[17,18],[18,19],[19,20]);function Eh(t){t.gestures=[],t.landmarks=[],t.worldLandmarks=[],t.handedness=[]}function wh(t){return 0===t.gestures.length?{gestures:[],landmarks:[],worldLandmarks:[],handedness:[],handednesses:[]}:{gestures:t.gestures,landmarks:t.landmarks,worldLandmarks:t.worldLandmarks,handedness:t.handedness,handednesses:t.handedness}}function Th(t,e=!0){const n=[];for(const i of t){var r=Wi(i);t=[];for(const n of r.g())r=e&&null!=Nn(n,1)?Bn(Nn(n,1),0):-1,t.push({score:Gn(n,2)??0,index:r,categoryName:jn(n,3)??\"\",displayName:jn(n,4)??\"\"});n.push(t)}return n}var Ah=class extends ih{constructor(t,e){super(new Za(t,e),\"image_in\",\"norm_rect\",!1),this.gestures=[],this.landmarks=[],this.worldLandmarks=[],this.handedness=[],Cn(t=this.v=new oo,0,1,e=new Cs),this.A=new io,Cn(this.v,0,2,this.A),this.u=new no,Cn(this.A,0,3,this.u),this.h=new to,Cn(this.A,0,2,this.h),this.j=new Zs,Cn(this.v,0,3,this.j),Hn(this.h,2,.5),Hn(this.A,4,.5),Hn(this.u,2,.5)}get baseOptions(){return Rn(this.v,Cs,1)}set baseOptions(t){Cn(this.v,0,1,t)}o(t){if(Xn(this.h,3,t.numHands??1),\"minHandDetectionConfidence\"in t&&Hn(this.h,2,t.minHandDetectionConfidence??.5),\"minTrackingConfidence\"in t&&Hn(this.A,4,t.minTrackingConfidence??.5),\"minHandPresenceConfidence\"in t&&Hn(this.u,2,t.minHandPresenceConfidence??.5),t.cannedGesturesClassifierOptions){var e=new $s,n=e,r=Po(t.cannedGesturesClassifierOptions,Rn(this.j,$s,3)?.h());Cn(n,0,2,r),Cn(this.j,0,3,e)}else void 0===t.cannedGesturesClassifierOptions&&Rn(this.j,$s,3)?.g();return t.customGesturesClassifierOptions?(Cn(n=e=new $s,0,2,r=Po(t.customGesturesClassifierOptions,Rn(this.j,$s,4)?.h())),Cn(this.j,0,4,e)):void 0===t.customGesturesClassifierOptions&&Rn(this.j,$s,4)?.g(),this.l(t)}Ka(t,e){return Eh(this),eh(this,t,e),wh(this)}La(t,e,n){return Eh(this),nh(this,t,n,e),wh(this)}m(){var t=new Di;Ii(t,\"image_in\"),Ii(t,\"norm_rect\"),Ui(t,\"hand_gestures\"),Ui(t,\"hand_landmarks\"),Ui(t,\"world_hand_landmarks\"),Ui(t,\"handedness\");const e=new yi;Wn(e,co,this.v);const n=new Li;ki(n,\"mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph\"),xi(n,\"IMAGE:image_in\"),xi(n,\"NORM_RECT:norm_rect\"),Si(n,\"HAND_GESTURES:hand_gestures\"),Si(n,\"LANDMARKS:hand_landmarks\"),Si(n,\"WORLD_LANDMARKS:world_hand_landmarks\"),Si(n,\"HANDEDNESS:handedness\"),n.o(e),Oi(t,n),this.g.attachProtoVectorListener(\"hand_landmarks\",((t,e)=>{for(const e of t){t=us(e);const n=[];for(const e of Pn(t,as,1))n.push({x:Gn(e,1)??0,y:Gn(e,2)??0,z:Gn(e,3)??0,visibility:Gn(e,4)??0});this.landmarks.push(n)}ea(this,e)})),this.g.attachEmptyPacketListener(\"hand_landmarks\",(t=>{ea(this,t)})),this.g.attachProtoVectorListener(\"world_hand_landmarks\",((t,e)=>{for(const e of t){t=os(e);const n=[];for(const e of Pn(t,rs,1))n.push({x:Gn(e,1)??0,y:Gn(e,2)??0,z:Gn(e,3)??0,visibility:Gn(e,4)??0});this.worldLandmarks.push(n)}ea(this,e)})),this.g.attachEmptyPacketListener(\"world_hand_landmarks\",(t=>{ea(this,t)})),this.g.attachProtoVectorListener(\"hand_gestures\",((t,e)=>{this.gestures.push(...Th(t,!1)),ea(this,e)})),this.g.attachEmptyPacketListener(\"hand_gestures\",(t=>{ea(this,t)})),this.g.attachProtoVectorListener(\"handedness\",((t,e)=>{this.handedness.push(...Th(t)),ea(this,e)})),this.g.attachEmptyPacketListener(\"handedness\",(t=>{ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};function bh(t){return{landmarks:t.landmarks,worldLandmarks:t.worldLandmarks,handednesses:t.handedness,handedness:t.handedness}}Ah.prototype.recognizeForVideo=Ah.prototype.La,Ah.prototype.recognize=Ah.prototype.Ka,Ah.prototype.setOptions=Ah.prototype.o,Ah.createFromModelPath=function(t,e){return Qa(Ah,t,{baseOptions:{modelAssetPath:e}})},Ah.createFromModelBuffer=function(t,e){return Qa(Ah,t,{baseOptions:{modelAssetBuffer:e}})},Ah.createFromOptions=function(t,e){return Qa(Ah,t,e)},Ah.HAND_CONNECTIONS=vh;var kh=class extends ih{constructor(t,e){super(new Za(t,e),\"image_in\",\"norm_rect\",!1),this.landmarks=[],this.worldLandmarks=[],this.handedness=[],Cn(t=this.j=new io,0,1,e=new Cs),this.u=new no,Cn(this.j,0,3,this.u),this.h=new to,Cn(this.j,0,2,this.h),Xn(this.h,3,1),Hn(this.h,2,.5),Hn(this.u,2,.5),Hn(this.j,4,.5)}get baseOptions(){return Rn(this.j,Cs,1)}set baseOptions(t){Cn(this.j,0,1,t)}o(t){return\"numHands\"in t&&Xn(this.h,3,t.numHands??1),\"minHandDetectionConfidence\"in t&&Hn(this.h,2,t.minHandDetectionConfidence??.5),\"minTrackingConfidence\"in t&&Hn(this.j,4,t.minTrackingConfidence??.5),\"minHandPresenceConfidence\"in t&&Hn(this.u,2,t.minHandPresenceConfidence??.5),this.l(t)}F(t,e){return this.landmarks=[],this.worldLandmarks=[],this.handedness=[],eh(this,t,e),bh(this)}G(t,e,n){return this.landmarks=[],this.worldLandmarks=[],this.handedness=[],nh(this,t,n,e),bh(this)}m(){var t=new Di;Ii(t,\"image_in\"),Ii(t,\"norm_rect\"),Ui(t,\"hand_landmarks\"),Ui(t,\"world_hand_landmarks\"),Ui(t,\"handedness\");const e=new yi;Wn(e,ho,this.j);const n=new Li;ki(n,\"mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph\"),xi(n,\"IMAGE:image_in\"),xi(n,\"NORM_RECT:norm_rect\"),Si(n,\"LANDMARKS:hand_landmarks\"),Si(n,\"WORLD_LANDMARKS:world_hand_landmarks\"),Si(n,\"HANDEDNESS:handedness\"),n.o(e),Oi(t,n),this.g.attachProtoVectorListener(\"hand_landmarks\",((t,e)=>{for(const e of t)t=us(e),this.landmarks.push(Io(t));ea(this,e)})),this.g.attachEmptyPacketListener(\"hand_landmarks\",(t=>{ea(this,t)})),this.g.attachProtoVectorListener(\"world_hand_landmarks\",((t,e)=>{for(const e of t)t=os(e),this.worldLandmarks.push(Uo(t));ea(this,e)})),this.g.attachEmptyPacketListener(\"world_hand_landmarks\",(t=>{ea(this,t)})),this.g.attachProtoVectorListener(\"handedness\",((t,e)=>{var n=this.handedness,r=n.push;const i=[];for(const e of t){t=Wi(e);const n=[];for(const e of t.g())n.push({score:Gn(e,2)??0,index:Bn(Nn(e,1),0)??-1,categoryName:jn(e,3)??\"\",displayName:jn(e,4)??\"\"});i.push(n)}r.call(n,...i),ea(this,e)})),this.g.attachEmptyPacketListener(\"handedness\",(t=>{ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};kh.prototype.detectForVideo=kh.prototype.G,kh.prototype.detect=kh.prototype.F,kh.prototype.setOptions=kh.prototype.o,kh.createFromModelPath=function(t,e){return Qa(kh,t,{baseOptions:{modelAssetPath:e}})},kh.createFromModelBuffer=function(t,e){return Qa(kh,t,{baseOptions:{modelAssetBuffer:e}})},kh.createFromOptions=function(t,e){return Qa(kh,t,e)},kh.HAND_CONNECTIONS=vh;var xh=$a([0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]);function Sh(t){t.h={faceLandmarks:[],faceBlendshapes:[],poseLandmarks:[],poseWorldLandmarks:[],poseSegmentationMasks:[],leftHandLandmarks:[],leftHandWorldLandmarks:[],rightHandLandmarks:[],rightHandWorldLandmarks:[]}}function Lh(t){try{if(!t.I)return t.h;t.I(t.h)}finally{ia(t)}}function Fh(t,e){t=us(t),e.push(Io(t))}var Rh=class extends ih{constructor(t,e){super(new Za(t,e),\"input_frames_image\",null,!1),this.h={faceLandmarks:[],faceBlendshapes:[],poseLandmarks:[],poseWorldLandmarks:[],poseSegmentationMasks:[],leftHandLandmarks:[],leftHandWorldLandmarks:[],rightHandLandmarks:[],rightHandWorldLandmarks:[]},this.outputPoseSegmentationMasks=this.outputFaceBlendshapes=!1,Cn(t=this.A=new yo,0,1,e=new Cs),this.u=new no,Cn(this.A,0,2,this.u),this.aa=new uo,Cn(this.A,0,3,this.aa),this.j=new Is,Cn(this.A,0,4,this.j),this.H=new Vs,Cn(this.A,0,5,this.H),this.v=new fo,Cn(this.A,0,6,this.v),this.D=new go,Cn(this.A,0,7,this.D),Hn(this.j,2,.5),Hn(this.j,3,.3),Hn(this.H,2,.5),Hn(this.v,2,.5),Hn(this.v,3,.3),Hn(this.D,2,.5),Hn(this.u,2,.5)}get baseOptions(){return Rn(this.A,Cs,1)}set baseOptions(t){Cn(this.A,0,1,t)}o(t){return\"minFaceDetectionConfidence\"in t&&Hn(this.j,2,t.minFaceDetectionConfidence??.5),\"minFaceSuppressionThreshold\"in t&&Hn(this.j,3,t.minFaceSuppressionThreshold??.3),\"minFacePresenceConfidence\"in t&&Hn(this.H,2,t.minFacePresenceConfidence??.5),\"outputFaceBlendshapes\"in t&&(this.outputFaceBlendshapes=!!t.outputFaceBlendshapes),\"minPoseDetectionConfidence\"in t&&Hn(this.v,2,t.minPoseDetectionConfidence??.5),\"minPoseSuppressionThreshold\"in t&&Hn(this.v,3,t.minPoseSuppressionThreshold??.3),\"minPosePresenceConfidence\"in t&&Hn(this.D,2,t.minPosePresenceConfidence??.5),\"outputPoseSegmentationMasks\"in t&&(this.outputPoseSegmentationMasks=!!t.outputPoseSegmentationMasks),\"minHandLandmarksConfidence\"in t&&Hn(this.u,2,t.minHandLandmarksConfidence??.5),this.l(t)}F(t,e,n){const r=\"function\"!=typeof e?e:{};return this.I=\"function\"==typeof e?e:n,Sh(this),eh(this,t,r),Lh(this)}G(t,e,n,r){const i=\"function\"!=typeof n?n:{};return this.I=\"function\"==typeof n?n:r,Sh(this),nh(this,t,i,e),Lh(this)}m(){var t=new Di;Ii(t,\"input_frames_image\"),Ui(t,\"pose_landmarks\"),Ui(t,\"pose_world_landmarks\"),Ui(t,\"face_landmarks\"),Ui(t,\"left_hand_landmarks\"),Ui(t,\"left_hand_world_landmarks\"),Ui(t,\"right_hand_landmarks\"),Ui(t,\"right_hand_world_landmarks\");const e=new yi,n=new oi;An(n,1,Me(\"type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions\"),\"\"),function(t,e){if(null!=e)if(Array.isArray(e))dn(t,2,tn(e,nn,void 0,void 0,!1));else{if(!(\"string\"==typeof e||e instanceof B||M(e)))throw Error(\"invalid value in Any.value field: \"+e+\" expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array\");An(t,2,ae(e,!1,!1),D())}}(n,this.A.g());const r=new Li;ki(r,\"mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph\"),Dn(r,8,oi,n),xi(r,\"IMAGE:input_frames_image\"),Si(r,\"POSE_LANDMARKS:pose_landmarks\"),Si(r,\"POSE_WORLD_LANDMARKS:pose_world_landmarks\"),Si(r,\"FACE_LANDMARKS:face_landmarks\"),Si(r,\"LEFT_HAND_LANDMARKS:left_hand_landmarks\"),Si(r,\"LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks\"),Si(r,\"RIGHT_HAND_LANDMARKS:right_hand_landmarks\"),Si(r,\"RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks\"),r.o(e),Oi(t,r),na(this,t),this.g.attachProtoListener(\"pose_landmarks\",((t,e)=>{Fh(t,this.h.poseLandmarks),ea(this,e)})),this.g.attachEmptyPacketListener(\"pose_landmarks\",(t=>{ea(this,t)})),this.g.attachProtoListener(\"pose_world_landmarks\",((t,e)=>{var n=this.h.poseWorldLandmarks;t=os(t),n.push(Uo(t)),ea(this,e)})),this.g.attachEmptyPacketListener(\"pose_world_landmarks\",(t=>{ea(this,t)})),this.outputPoseSegmentationMasks&&(Si(r,\"POSE_SEGMENTATION_MASK:pose_segmentation_mask\"),ra(this,\"pose_segmentation_mask\"),this.g.W(\"pose_segmentation_mask\",((t,e)=>{this.h.poseSegmentationMasks=[rh(this,t,!0,!this.I)],ea(this,e)})),this.g.attachEmptyPacketListener(\"pose_segmentation_mask\",(t=>{this.h.poseSegmentationMasks=[],ea(this,t)}))),this.g.attachProtoListener(\"face_landmarks\",((t,e)=>{Fh(t,this.h.faceLandmarks),ea(this,e)})),this.g.attachEmptyPacketListener(\"face_landmarks\",(t=>{ea(this,t)})),this.outputFaceBlendshapes&&(Ui(t,\"extra_blendshapes\"),Si(r,\"FACE_BLENDSHAPES:extra_blendshapes\"),this.g.attachProtoListener(\"extra_blendshapes\",((t,e)=>{var n=this.h.faceBlendshapes;this.outputFaceBlendshapes&&(t=Wi(t),n.push(Co(t.g()??[]))),ea(this,e)})),this.g.attachEmptyPacketListener(\"extra_blendshapes\",(t=>{ea(this,t)}))),this.g.attachProtoListener(\"left_hand_landmarks\",((t,e)=>{Fh(t,this.h.leftHandLandmarks),ea(this,e)})),this.g.attachEmptyPacketListener(\"left_hand_landmarks\",(t=>{ea(this,t)})),this.g.attachProtoListener(\"left_hand_world_landmarks\",((t,e)=>{var n=this.h.leftHandWorldLandmarks;t=os(t),n.push(Uo(t)),ea(this,e)})),this.g.attachEmptyPacketListener(\"left_hand_world_landmarks\",(t=>{ea(this,t)})),this.g.attachProtoListener(\"right_hand_landmarks\",((t,e)=>{Fh(t,this.h.rightHandLandmarks),ea(this,e)})),this.g.attachEmptyPacketListener(\"right_hand_landmarks\",(t=>{ea(this,t)})),this.g.attachProtoListener(\"right_hand_world_landmarks\",((t,e)=>{var n=this.h.rightHandWorldLandmarks;t=os(t),n.push(Uo(t)),ea(this,e)})),this.g.attachEmptyPacketListener(\"right_hand_world_landmarks\",(t=>{ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};Rh.prototype.detectForVideo=Rh.prototype.G,Rh.prototype.detect=Rh.prototype.F,Rh.prototype.setOptions=Rh.prototype.o,Rh.createFromModelPath=function(t,e){return Qa(Rh,t,{baseOptions:{modelAssetPath:e}})},Rh.createFromModelBuffer=function(t,e){return Qa(Rh,t,{baseOptions:{modelAssetBuffer:e}})},Rh.createFromOptions=function(t,e){return Qa(Rh,t,e)},Rh.HAND_CONNECTIONS=vh,Rh.POSE_CONNECTIONS=xh,Rh.FACE_LANDMARKS_LIPS=oh,Rh.FACE_LANDMARKS_LEFT_EYE=ah,Rh.FACE_LANDMARKS_LEFT_EYEBROW=hh,Rh.FACE_LANDMARKS_LEFT_IRIS=ch,Rh.FACE_LANDMARKS_RIGHT_EYE=uh,Rh.FACE_LANDMARKS_RIGHT_EYEBROW=lh,Rh.FACE_LANDMARKS_RIGHT_IRIS=dh,Rh.FACE_LANDMARKS_FACE_OVAL=fh,Rh.FACE_LANDMARKS_CONTOURS=ph,Rh.FACE_LANDMARKS_TESSELATION=gh;var Mh=class extends ih{constructor(t,e){super(new Za(t,e),\"input_image\",\"norm_rect\",!0),this.j={classifications:[]},Cn(t=this.h=new _o,0,1,e=new Cs)}get baseOptions(){return Rn(this.h,Cs,1)}set baseOptions(t){Cn(this.h,0,1,t)}o(t){return Cn(this.h,0,2,Po(t,Rn(this.h,ks,2))),this.l(t)}ua(t,e){return this.j={classifications:[]},eh(this,t,e),this.j}va(t,e,n){return this.j={classifications:[]},nh(this,t,n,e),this.j}m(){var t=new Di;Ii(t,\"input_image\"),Ii(t,\"norm_rect\"),Ui(t,\"classifications\");const e=new yi;Wn(e,vo,this.h);const n=new Li;ki(n,\"mediapipe.tasks.vision.image_classifier.ImageClassifierGraph\"),xi(n,\"IMAGE:input_image\"),xi(n,\"NORM_RECT:norm_rect\"),Si(n,\"CLASSIFICATIONS:classifications\"),n.o(e),Oi(t,n),this.g.attachProtoListener(\"classifications\",((t,e)=>{this.j=function(t){const e={classifications:Pn(t,ps,1).map((t=>Co(Rn(t,Xi,4)?.g()??[],Bn(Nn(t,2),0),jn(t,3))))};return null!=Fe(cn(t,2))&&(e.timestampMs=Bn(Fe(cn(t,2)),0)),e}(ys(t)),ea(this,e)})),this.g.attachEmptyPacketListener(\"classifications\",(t=>{ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};Mh.prototype.classifyForVideo=Mh.prototype.va,Mh.prototype.classify=Mh.prototype.ua,Mh.prototype.setOptions=Mh.prototype.o,Mh.createFromModelPath=function(t,e){return Qa(Mh,t,{baseOptions:{modelAssetPath:e}})},Mh.createFromModelBuffer=function(t,e){return Qa(Mh,t,{baseOptions:{modelAssetBuffer:e}})},Mh.createFromOptions=function(t,e){return Qa(Mh,t,e)};var Ph=class extends ih{constructor(t,e){super(new Za(t,e),\"image_in\",\"norm_rect\",!0),this.h=new Eo,this.embeddings={embeddings:[]},Cn(t=this.h,0,1,e=new Cs)}get baseOptions(){return Rn(this.h,Cs,1)}set baseOptions(t){Cn(this.h,0,1,t)}o(t){var e=this.h,n=Rn(this.h,Ss,2);return n=n?n.clone():new Ss,void 0!==t.l2Normalize?Vn(n,1,t.l2Normalize):\"l2Normalize\"in t&&dn(n,1),void 0!==t.quantize?Vn(n,2,t.quantize):\"quantize\"in t&&dn(n,2),Cn(e,0,2,n),this.l(t)}Ba(t,e){return eh(this,t,e),this.embeddings}Ca(t,e,n){return nh(this,t,n,e),this.embeddings}m(){var t=new Di;Ii(t,\"image_in\"),Ii(t,\"norm_rect\"),Ui(t,\"embeddings_out\");const e=new yi;Wn(e,wo,this.h);const n=new Li;ki(n,\"mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph\"),xi(n,\"IMAGE:image_in\"),xi(n,\"NORM_RECT:norm_rect\"),Si(n,\"EMBEDDINGS:embeddings_out\"),n.o(e),Oi(t,n),this.g.attachProtoListener(\"embeddings_out\",((t,e)=>{t=bs(t),this.embeddings=function(t){return{embeddings:Pn(t,Es,1).map((t=>{const e={headIndex:Bn(Nn(t,3),0)??-1,headName:jn(t,4)??\"\"};if(void 0!==Fn(t,_s,xn(t,1)))t=yn(t=Rn(t,_s,xn(t,1)),1,ve),e.floatEmbedding=t.slice();else{const n=new Uint8Array(0);e.quantizedEmbedding=Rn(t,vs,xn(t,2))?.qa()?.h()??n}return e})),timestampMs:Bn(Fe(cn(t,2)),0)}}(t),ea(this,e)})),this.g.attachEmptyPacketListener(\"embeddings_out\",(t=>{ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};Ph.cosineSimilarity=function(t,e){if(t.floatEmbedding&&e.floatEmbedding)t=No(t.floatEmbedding,e.floatEmbedding);else{if(!t.quantizedEmbedding||!e.quantizedEmbedding)throw Error(\"Cannot compute cosine similarity between quantized and float embeddings.\");t=No(Do(t.quantizedEmbedding),Do(e.quantizedEmbedding))}return t},Ph.prototype.embedForVideo=Ph.prototype.Ca,Ph.prototype.embed=Ph.prototype.Ba,Ph.prototype.setOptions=Ph.prototype.o,Ph.createFromModelPath=function(t,e){return Qa(Ph,t,{baseOptions:{modelAssetPath:e}})},Ph.createFromModelBuffer=function(t,e){return Qa(Ph,t,{baseOptions:{modelAssetBuffer:e}})},Ph.createFromOptions=function(t,e){return Qa(Ph,t,e)};var Ch=class{constructor(t,e,n){this.confidenceMasks=t,this.categoryMask=e,this.qualityScores=n}close(){this.confidenceMasks?.forEach((t=>{t.close()})),this.categoryMask?.close()}};function Oh(t){t.categoryMask=void 0,t.confidenceMasks=void 0,t.qualityScores=void 0}function Ih(t){try{const e=new Ch(t.confidenceMasks,t.categoryMask,t.qualityScores);if(!t.j)return e;t.j(e)}finally{ia(t)}}Ch.prototype.close=Ch.prototype.close;var Uh=class extends ih{constructor(t,e){super(new Za(t,e),\"image_in\",\"norm_rect\",!1),this.u=[],this.outputCategoryMask=!1,this.outputConfidenceMasks=!0,this.h=new xo,this.v=new To,Cn(this.h,0,3,this.v),Cn(t=this.h,0,1,e=new Cs)}get baseOptions(){return Rn(this.h,Cs,1)}set baseOptions(t){Cn(this.h,0,1,t)}o(t){return void 0!==t.displayNamesLocale?dn(this.h,2,Me(t.displayNamesLocale)):\"displayNamesLocale\"in t&&dn(this.h,2),\"outputCategoryMask\"in t&&(this.outputCategoryMask=t.outputCategoryMask??!1),\"outputConfidenceMasks\"in t&&(this.outputConfidenceMasks=t.outputConfidenceMasks??!0),super.l(t)}L(){!function(t){const e=Pn(t.fa(),Li,1).filter((t=>jn(t,1).includes(\"mediapipe.tasks.TensorsToSegmentationCalculator\")));if(t.u=[],1<e.length)throw Error(\"The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.\");1===e.length&&(Rn(e[0],yi,7)?.l()?.g()??new Map).forEach(((e,n)=>{t.u[Number(n)]=jn(e,1)}))}(this)}ga(t,e,n){const r=\"function\"!=typeof e?e:{};return this.j=\"function\"==typeof e?e:n,Oh(this),eh(this,t,r),Ih(this)}Na(t,e,n,r){const i=\"function\"!=typeof n?n:{};return this.j=\"function\"==typeof n?n:r,Oh(this),nh(this,t,i,e),Ih(this)}Fa(){return this.u}m(){var t=new Di;Ii(t,\"image_in\"),Ii(t,\"norm_rect\");const e=new yi;Wn(e,So,this.h);const n=new Li;ki(n,\"mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph\"),xi(n,\"IMAGE:image_in\"),xi(n,\"NORM_RECT:norm_rect\"),n.o(e),Oi(t,n),na(this,t),this.outputConfidenceMasks&&(Ui(t,\"confidence_masks\"),Si(n,\"CONFIDENCE_MASKS:confidence_masks\"),ra(this,\"confidence_masks\"),this.g.da(\"confidence_masks\",((t,e)=>{this.confidenceMasks=t.map((t=>rh(this,t,!0,!this.j))),ea(this,e)})),this.g.attachEmptyPacketListener(\"confidence_masks\",(t=>{this.confidenceMasks=[],ea(this,t)}))),this.outputCategoryMask&&(Ui(t,\"category_mask\"),Si(n,\"CATEGORY_MASK:category_mask\"),ra(this,\"category_mask\"),this.g.W(\"category_mask\",((t,e)=>{this.categoryMask=rh(this,t,!1,!this.j),ea(this,e)})),this.g.attachEmptyPacketListener(\"category_mask\",(t=>{this.categoryMask=void 0,ea(this,t)}))),Ui(t,\"quality_scores\"),Si(n,\"QUALITY_SCORES:quality_scores\"),this.g.attachFloatVectorListener(\"quality_scores\",((t,e)=>{this.qualityScores=t,ea(this,e)})),this.g.attachEmptyPacketListener(\"quality_scores\",(t=>{this.categoryMask=void 0,ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};Uh.prototype.getLabels=Uh.prototype.Fa,Uh.prototype.segmentForVideo=Uh.prototype.Na,Uh.prototype.segment=Uh.prototype.ga,Uh.prototype.setOptions=Uh.prototype.o,Uh.createFromModelPath=function(t,e){return Qa(Uh,t,{baseOptions:{modelAssetPath:e}})},Uh.createFromModelBuffer=function(t,e){return Qa(Uh,t,{baseOptions:{modelAssetBuffer:e}})},Uh.createFromOptions=function(t,e){return Qa(Uh,t,e)};var Dh=class{constructor(t,e,n){this.confidenceMasks=t,this.categoryMask=e,this.qualityScores=n}close(){this.confidenceMasks?.forEach((t=>{t.close()})),this.categoryMask?.close()}};Dh.prototype.close=Dh.prototype.close;var Nh=class extends zn{constructor(t){super(t)}},Bh=[0,jr,-2],Gh=[0,Or,-3,Hr],jh=[0,Or,-3,Hr,Or,-1],Vh=[0,jh],Xh=[0,Vh,Bh],Hh=[0,jh,Bh],Wh=[0,jh,jr,-1],zh=[0,Wh,Bh],Kh=[0,Or,-3,Hr,Bh,-1],Yh=[0,Or,-3,Hr,ti],$h=class extends zn{constructor(t){super(t)}},qh=[0,Or,-1,Hr],Jh=class extends zn{constructor(){super()}};Jh.B=[1];var Zh=class extends zn{constructor(t){super(t)}},Qh=[1,2,3,4,5,6,7,8,9,10,14,15],tc=[0,Qh,Jr,jh,Jr,Hh,Jr,Vh,Jr,Xh,Jr,qh,Jr,Yh,Jr,Gh,Jr,[0,Yr,Or,-2,Hr,jr,Hr,-1,2,Or,Bh],Jr,Wh,Jr,zh,Or,Bh,Yr,Jr,Kh,Jr,[0,Cr,qh]],ec=[0,Yr,jr,-1,Hr],nc=class extends zn{constructor(){super()}};nc.B=[1],nc.prototype.g=si([0,Cr,tc,Yr,ec]);var rc=class extends ih{constructor(t,e){super(new Za(t,e),\"image_in\",\"norm_rect_in\",!1),this.outputCategoryMask=!1,this.outputConfidenceMasks=!0,this.h=new xo,this.v=new To,Cn(this.h,0,3,this.v),Cn(t=this.h,0,1,e=new Cs)}get baseOptions(){return Rn(this.h,Cs,1)}set baseOptions(t){Cn(this.h,0,1,t)}o(t){return\"outputCategoryMask\"in t&&(this.outputCategoryMask=t.outputCategoryMask??!1),\"outputConfidenceMasks\"in t&&(this.outputConfidenceMasks=t.outputConfidenceMasks??!0),super.l(t)}ga(t,e,n,r){const i=\"function\"!=typeof n?n:{};this.j=\"function\"==typeof n?n:r,this.qualityScores=this.categoryMask=this.confidenceMasks=void 0,n=this.J+1,r=new nc;const s=new Zh;var o=new Nh;if(Xn(o,1,255),Cn(s,0,12,o),e.keypoint&&e.scribble)throw Error(\"Cannot provide both keypoint and scribble.\");if(e.keypoint){var a=new $h;Vn(a,3,!0),Hn(a,1,e.keypoint.x),Hn(a,2,e.keypoint.y),On(s,5,Qh,a)}else{if(!e.scribble)throw Error(\"Must provide either a keypoint or a scribble.\");for(a of(o=new Jh,e.scribble))Vn(e=new $h,3,!0),Hn(e,1,a.x),Hn(e,2,a.y),Dn(o,1,$h,e);On(s,15,Qh,o)}Dn(r,1,Zh,s),this.g.addProtoToStream(r.g(),\"drishti.RenderData\",\"roi_in\",n),eh(this,t,i);t:{try{const t=new Dh(this.confidenceMasks,this.categoryMask,this.qualityScores);if(!this.j){var h=t;break t}this.j(t)}finally{ia(this)}h=void 0}return h}m(){var t=new Di;Ii(t,\"image_in\"),Ii(t,\"roi_in\"),Ii(t,\"norm_rect_in\");const e=new yi;Wn(e,So,this.h);const n=new Li;ki(n,\"mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph\"),xi(n,\"IMAGE:image_in\"),xi(n,\"ROI:roi_in\"),xi(n,\"NORM_RECT:norm_rect_in\"),n.o(e),Oi(t,n),na(this,t),this.outputConfidenceMasks&&(Ui(t,\"confidence_masks\"),Si(n,\"CONFIDENCE_MASKS:confidence_masks\"),ra(this,\"confidence_masks\"),this.g.da(\"confidence_masks\",((t,e)=>{this.confidenceMasks=t.map((t=>rh(this,t,!0,!this.j))),ea(this,e)})),this.g.attachEmptyPacketListener(\"confidence_masks\",(t=>{this.confidenceMasks=[],ea(this,t)}))),this.outputCategoryMask&&(Ui(t,\"category_mask\"),Si(n,\"CATEGORY_MASK:category_mask\"),ra(this,\"category_mask\"),this.g.W(\"category_mask\",((t,e)=>{this.categoryMask=rh(this,t,!1,!this.j),ea(this,e)})),this.g.attachEmptyPacketListener(\"category_mask\",(t=>{this.categoryMask=void 0,ea(this,t)}))),Ui(t,\"quality_scores\"),Si(n,\"QUALITY_SCORES:quality_scores\"),this.g.attachFloatVectorListener(\"quality_scores\",((t,e)=>{this.qualityScores=t,ea(this,e)})),this.g.attachEmptyPacketListener(\"quality_scores\",(t=>{this.categoryMask=void 0,ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};rc.prototype.segment=rc.prototype.ga,rc.prototype.setOptions=rc.prototype.o,rc.createFromModelPath=function(t,e){return Qa(rc,t,{baseOptions:{modelAssetPath:e}})},rc.createFromModelBuffer=function(t,e){return Qa(rc,t,{baseOptions:{modelAssetBuffer:e}})},rc.createFromOptions=function(t,e){return Qa(rc,t,e)};var ic=class extends ih{constructor(t,e){super(new Za(t,e),\"input_frame_gpu\",\"norm_rect\",!1),this.j={detections:[]},Cn(t=this.h=new Lo,0,1,e=new Cs)}get baseOptions(){return Rn(this.h,Cs,1)}set baseOptions(t){Cn(this.h,0,1,t)}o(t){return void 0!==t.displayNamesLocale?dn(this.h,2,Me(t.displayNamesLocale)):\"displayNamesLocale\"in t&&dn(this.h,2),void 0!==t.maxResults?Xn(this.h,3,t.maxResults):\"maxResults\"in t&&dn(this.h,3),void 0!==t.scoreThreshold?Hn(this.h,4,t.scoreThreshold):\"scoreThreshold\"in t&&dn(this.h,4),void 0!==t.categoryAllowlist?Tn(this.h,5,t.categoryAllowlist):\"categoryAllowlist\"in t&&dn(this.h,5),void 0!==t.categoryDenylist?Tn(this.h,6,t.categoryDenylist):\"categoryDenylist\"in t&&dn(this.h,6),this.l(t)}F(t,e){return this.j={detections:[]},eh(this,t,e),this.j}G(t,e,n){return this.j={detections:[]},nh(this,t,n,e),this.j}m(){var t=new Di;Ii(t,\"input_frame_gpu\"),Ii(t,\"norm_rect\"),Ui(t,\"detections\");const e=new yi;Wn(e,Fo,this.h);const n=new Li;ki(n,\"mediapipe.tasks.vision.ObjectDetectorGraph\"),xi(n,\"IMAGE:input_frame_gpu\"),xi(n,\"NORM_RECT:norm_rect\"),Si(n,\"DETECTIONS:detections\"),n.o(e),Oi(t,n),this.g.attachProtoVectorListener(\"detections\",((t,e)=>{for(const e of t)t=ns(e),this.j.detections.push(Oo(t));ea(this,e)})),this.g.attachEmptyPacketListener(\"detections\",(t=>{ea(this,t)})),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};ic.prototype.detectForVideo=ic.prototype.G,ic.prototype.detect=ic.prototype.F,ic.prototype.setOptions=ic.prototype.o,ic.createFromModelPath=async function(t,e){return Qa(ic,t,{baseOptions:{modelAssetPath:e}})},ic.createFromModelBuffer=function(t,e){return Qa(ic,t,{baseOptions:{modelAssetBuffer:e}})},ic.createFromOptions=function(t,e){return Qa(ic,t,e)};var sc=class{constructor(t,e,n){this.landmarks=t,this.worldLandmarks=e,this.segmentationMasks=n}close(){this.segmentationMasks?.forEach((t=>{t.close()}))}};function oc(t){t.landmarks=[],t.worldLandmarks=[],t.segmentationMasks=void 0}function ac(t){try{const e=new sc(t.landmarks,t.worldLandmarks,t.segmentationMasks);if(!t.j)return e;t.j(e)}finally{ia(t)}}sc.prototype.close=sc.prototype.close;var hc=class extends ih{constructor(t,e){super(new Za(t,e),\"image_in\",\"norm_rect\",!1),this.landmarks=[],this.worldLandmarks=[],this.outputSegmentationMasks=!1,Cn(t=this.h=new Ro,0,1,e=new Cs),this.D=new go,Cn(this.h,0,3,this.D),this.v=new fo,Cn(this.h,0,2,this.v),Xn(this.v,4,1),Hn(this.v,2,.5),Hn(this.D,2,.5),Hn(this.h,4,.5)}get baseOptions(){return Rn(this.h,Cs,1)}set baseOptions(t){Cn(this.h,0,1,t)}o(t){return\"numPoses\"in t&&Xn(this.v,4,t.numPoses??1),\"minPoseDetectionConfidence\"in t&&Hn(this.v,2,t.minPoseDetectionConfidence??.5),\"minTrackingConfidence\"in t&&Hn(this.h,4,t.minTrackingConfidence??.5),\"minPosePresenceConfidence\"in t&&Hn(this.D,2,t.minPosePresenceConfidence??.5),\"outputSegmentationMasks\"in t&&(this.outputSegmentationMasks=t.outputSegmentationMasks??!1),this.l(t)}F(t,e,n){const r=\"function\"!=typeof e?e:{};return this.j=\"function\"==typeof e?e:n,oc(this),eh(this,t,r),ac(this)}G(t,e,n,r){const i=\"function\"!=typeof n?n:{};return this.j=\"function\"==typeof n?n:r,oc(this),nh(this,t,i,e),ac(this)}m(){var t=new Di;Ii(t,\"image_in\"),Ii(t,\"norm_rect\"),Ui(t,\"normalized_landmarks\"),Ui(t,\"world_landmarks\"),Ui(t,\"segmentation_masks\");const e=new yi;Wn(e,Mo,this.h);const n=new Li;ki(n,\"mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph\"),xi(n,\"IMAGE:image_in\"),xi(n,\"NORM_RECT:norm_rect\"),Si(n,\"NORM_LANDMARKS:normalized_landmarks\"),Si(n,\"WORLD_LANDMARKS:world_landmarks\"),n.o(e),Oi(t,n),na(this,t),this.g.attachProtoVectorListener(\"normalized_landmarks\",((t,e)=>{this.landmarks=[];for(const e of t)t=us(e),this.landmarks.push(Io(t));ea(this,e)})),this.g.attachEmptyPacketListener(\"normalized_landmarks\",(t=>{this.landmarks=[],ea(this,t)})),this.g.attachProtoVectorListener(\"world_landmarks\",((t,e)=>{this.worldLandmarks=[];for(const e of t)t=os(e),this.worldLandmarks.push(Uo(t));ea(this,e)})),this.g.attachEmptyPacketListener(\"world_landmarks\",(t=>{this.worldLandmarks=[],ea(this,t)})),this.outputSegmentationMasks&&(Si(n,\"SEGMENTATION_MASK:segmentation_masks\"),ra(this,\"segmentation_masks\"),this.g.da(\"segmentation_masks\",((t,e)=>{this.segmentationMasks=t.map((t=>rh(this,t,!0,!this.j))),ea(this,e)})),this.g.attachEmptyPacketListener(\"segmentation_masks\",(t=>{this.segmentationMasks=[],ea(this,t)}))),t=t.g(),this.setGraph(new Uint8Array(t),!0)}};hc.prototype.detectForVideo=hc.prototype.G,hc.prototype.detect=hc.prototype.F,hc.prototype.setOptions=hc.prototype.o,hc.createFromModelPath=function(t,e){return Qa(hc,t,{baseOptions:{modelAssetPath:e}})},hc.createFromModelBuffer=function(t,e){return Qa(hc,t,{baseOptions:{modelAssetBuffer:e}})},hc.createFromOptions=function(t,e){return Qa(hc,t,e)},hc.POSE_CONNECTIONS=xh;\n//# sourceMappingURL=vision_bundle_mjs.js.map\n\n\n//# sourceURL=webpack://@maissaninc/kidjs/./node_modules/@mediapipe/tasks-vision/vision_bundle.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/libraries/hand-tracker/index.js");
/******/ 	
/******/ })()
;